---
title: 操作系统原理-进程线程模型
date: 2017-09-25 15:23:02
tags: 
- 摘录
categories: 
- Operating System
- Principle
---

**阅读更多**

<!--more-->

# 1 进程基本概念

## 1.1 为什么引入进程

**多道程序设计**：允许多个程序同时进入内存并运行，其目的是为了提高系统效率

**并发环境**：一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态，并且次序不是事先确定的

![fig1](/images/操作系统原理-进程线程模型/fig1.jpg)

## 1.2 进程的定义

进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统**进行资源分配和调度**的独立单位

* 程序的一次执行过程
* 是正在运行程序的抽象
* 将一个CPU变幻成多个虚拟的CPU
* 系统资源以进程为单位分配，如内存、文件、每个具有独立的地址空间...
* 操作系统将CPU调度给需要的进程

## 1.3 进程控制块PCB

PCB：Process Control Block

* 又称进程描述符、进程属性
* 操作系统用于管理控制进程的一个专门数据结构
* 记录进程的各种属性，描述进程的动态变化过程

**PCB是系统感知进程存在的唯一标志**

* 进程与PCB是一一对应的

**进程表：所有进程的PCB集合**

**PCB大致上包含以下四类信息**

1. **进程描述信息**
    * 进程标识符(process ID)，唯一，通常是一个整数
    * 进程名，通常基于可执行文件名，不唯一
    * 用户标识符(user ID)
    * 进程组关系
1. **进程控制信息**
    * 当前状态
    * 优先级(priority)
    * 代码执行入口地址
    * 程序的磁盘地址
    * 运行统计信息(执行时间、页面调度)
    * 进程间同步和通信
    * 进程的队列指针
    * 进程的消息队列指针
1. **所拥有的资源控制情况**
    * 虚拟地址空间的状况
    * 打开文件列表
1. **CPU现场**
    * 寄存器值(通用寄存器、程序计数器PC、程序状态字PSW、栈指针)
    * 指向该进程页表的指针

# 2 进程状态及状态转换

## 2.1 进程的三种基本状态

进程的三种基本状态：

* **运行态（Running）**：占有CPU，并在CPU上运行
* **就绪态（Ready）**：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
* **等待态（Waiting/Blocked）**：因等待某一事件而暂时不能运行

**三状态进程模型**的进程状态转移图如下

![fig2](/images/操作系统原理-进程线程模型/fig2.jpg)

## 2.2 进程的其他状态

进程的三种其他状态：

* **创建态（New）**：
    * 已完成创建一进程所必要的工作，例如创建PID、PCB
    * 但尚未同意执行该进程，因为资源有限
* **终止态（Terminate）**：
    * 终止执行后，进程进入该状态
    * 可完成一些数据统计工作
    * 资源回收
* **挂起态（Suspend）**：
    * 用于调节负载
    * 进程不占用内存空间，其进程映像交换到磁盘上

**五状态进程模型**的进程状态转移图如下

![fig3](/images/操作系统原理-进程线程模型/fig3.jpg)

**七状态进程模型**的进程状态转移图如下

![fig4](/images/操作系统原理-进程线程模型/fig4.jpg)

## 2.3 进程队列

操作系统为每一类进程建立一个或多个队列

* 队列元素为PCB
* 伴随进程状态的改变，其PCB从一个队列进入另一个队列

![fig5](/images/操作系统原理-进程线程模型/fig5.jpg)

**五状态进程模型**的队列模型如下

![fig6](/images/操作系统原理-进程线程模型/fig6.jpg)

# 3 进程控制

进程控制操作完成进程各状态之间的转换，由具有特定功能的**原语**完成

* 进程创建原语
* 进程撤消原语
* 阻塞原语
* 唤醒原语
* 挂起原语
* 激活原语
* 改变进程优先级

**什么是原语：完成某种特定功能的一段程序，具有不可分割性或不可中断性。即原语的执行必须是连续的，在执行过程中不允许被中断。也就是满足原子性**

## 3.1 进程的创建

进程创建包含如下操作

* 给新进程分配一个唯一标识以及进程控制块
* 为进程分配地址空间
* 初始化进程控制块。设置默认值 (如: 状态为 New，...)
* 设置相应的队列指针。如：把新进程加到就绪队列链表中

UNIX：fork/exec
WINDOWS：CreateProcess

## 3.2 进程的撤销

结束进程包含如下操作

* 收回进程所占有的资源
* 关闭打开的文件、断开网络连接、回收分配的内存...
* 撤消该进程的PCB

UNIX：exit
WINDOWS：TerminateProcess

## 3.3 进程阻塞

处于运行状态的进程，在其运行过程中期待某一事件发生，如等待键盘输入、等待磁盘数据传输完成、等待其它进程发送消息，当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态

UNIX：wait
WINDOWS：WaitForSingleObject

## 3.4 Unix的几个进程控制操作

fork()：通过复制调用进程来建立新的进程，是最基本的进程建立过程
exec()：包括一系列系统调用，它们都是通过用一段新的程序代码覆盖原来的地址空间，实现进程执行代码的转换
wait()：提供初级进程同步操作，能使一个进程等待另外一个进程的结束
exit()：用来终止一个进程的运行

Unix的fork()的实现

* 为子进程分配一个空闲的进程描述符（proc结构）
* 分配给子进程唯一标识pid
* 以一次一页的方式复制父进程地址空间
* 从父进程处继承共享资源，如打开的文件和当前工作目录等
* 将子进程的状态设为就绪，插入到就绪队列
* 对子进程返回标识符0
* 向父进程返回子进程的pid

# 4 深入理解进程概念

## 4.1 进程分类

进程可以有如下几种分类

* 系统进程与用户进程
* 前台进程与后台进程
* CPU密集型进程与I/O密集型进程

## 4.2 进程与程序的区别

* 进程更能准确刻画并发，而程序不能
* 程序是静态的，进程是动态的
* 进程有生命周期的，有诞生有消亡，是短暂的；而程序是相对长久的
* 一个程序可对应多个进程
* 进程具有创建其他进程的功能

## 4.3 进程地址空间

![fig7](/images/操作系统原理-进程线程模型/fig7.jpg)

## 4.4 进程映像（IMAGE）

**进程映像是对进程执行活动全过程的静态描述（又可称为进程执行的上下文环境），由进程地址空间内容、硬件寄存器内容及与该进程相关的内核数据结构、内核栈组成**

* 用户相关：进程地址空间（包括代码段、数据段、堆和栈、共享库）
* 寄存器相关：程序计数器、指令寄存器、程序状态寄存器、栈指针、通用寄存器等的值
* 内核相关：
    * 静态部分：PCB及各种资源数据结构
    * 动态部分：内核栈（不同进程在进入内核后使用不同的内核栈）

**概括起来就是：进程映像 = 程序 + 数据 + 栈(用户栈、内核栈) + PCB**

## 4.5 上下文切换

**将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换**

进程运行时，其硬件状态保存在CPU上的寄存器中，这些寄存器包括：程序计数器、程序状态寄存器、栈指针、通用寄存器、其他控制寄存器的值

**进程不运行时，这些寄存器的值保存在进程控制块PCB中**；当操作系统要运行一个新的进程时，将PCB中的相关值送到对应的寄存器中

# 5 线程

## 5.1 为什么要引入线程

1. 应用的需要
1. 开销的考虑
1. 性能的考虑

### 5.1.1 应用的需要

![fig8](/images/操作系统原理-进程线程模型/fig8.jpg)

典型的应用：Web服务器，其工作方式如下

* 从客户端接收网页请求（http协议）
* 从磁盘上检索相关网页，读入内存
* 将网页返回给对应的客户端
* 如何提高服务器工作效率？网页缓存（Web page Cache）

一个多线程的Web服务器如下

![fig9](/images/操作系统原理-进程线程模型/fig9.jpg)

### 5.1.2 开销的考虑

回顾进程的几个基本操作

1. 创建进程
1. 撤消进程
1. 进程通信
1. 进程切换
* 这些操作时间/空间开销大，限制了并发度的提高

**对比进程，线程具有如下优势**

* 线程的开销小
* 创建一个新线程花费时间少（撤销亦如此）
* 两个线程切换花费时间少
* 线程之间相互通信无须调用内核（同一进程内的线程共享内存和文件）

### 5.1.3 性能的考虑

多线程能够充分利用多核CPU的计算能力

## 5.2 线程的基本概念

![fig10](/images/操作系统原理-进程线程模型/fig10.jpg)

线程的属性

* 有标示符ID
* 有状态及状态转换 → 需要提供一些操作
* 不运行时需要保存的上下文
    * 线程的下文环境：程序计数器等寄存器
* 有自己的栈和栈指针
* 共享所在进程的地址空间和其他资源
* 可以创建、撤消另一个线程
    * 程序开始是以一个单线程进程方式运行的

# 6 线程机制的实现

线程的实现有三种方式

1. 用户级线程
1. 核心级线程
1. 混合—两者结合方法

## 6.1 用户级线程

![fig11](/images/操作系统原理-进程线程模型/fig11.jpg)

用户级线程有以下特点

* 在用户空间建立线程库：提供一组管理线程的过程
* 运行时系统：完成线程的管理工作（操作、线程表）
* **内核管理的还是进程，不知道线程的存在**
* 线程切换不需要内核态特权
* 例子：UNIX

**优点**：

* 线程切换快
* 调度算法是应用程序特定的
* 用户级线程可运行在任何操作系统上（只需要实现线程库）

**缺点**：

* 内核只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上
* 大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞

## 6.2 核心级线程

![fig12](/images/操作系统原理-进程线程模型/fig12.jpg)

核心级线程有以下特点

* 内核管理所有线程管理，并向应用程序提供API接口
* 内核维护进程和线程的上下文
* 线程的切换需要内核支持
* 以线程为基础进行调度
* 例子：Windows

## 6.3 混合模型

![fig13](/images/操作系统原理-进程线程模型/fig13.jpg)

混合模型有以下特点

* 线程创建在用户空间完成
* 线程调度等在核心态完成
* **多个用户级线程多路复用多个内核级线程**
* 例子：Solaris

# 7 参考

* 《MOOC-操作系统原理-陈向群》
