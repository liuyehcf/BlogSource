---
title: 消息中间件的消息发送一致性
date: 2017-07-31 14:53:23
tags: 
- 摘录
categories: 
- 分布式
- 消息中间件
---

__目录__

<!-- toc -->
<!--more-->

# 1 消息发送一致性的定义

首先，我们需要弄清楚消息发送一致性究竟是什么。消息发送一致性是指产生消息的业务动作与消息发送的一致。就是说，如果业务操作成功了，那么由这个操作产生的消息一定要发送出去，否则就丢失消息了。另一方面，如果这个业务行为没有发生或者失败，那么就不应该把消息发出去

可以看到，消息一致性关注的是业务操作与消息发送之间的一致性。而二次提交/三次提交/Paxos关注的是所有参与者的状态的一致性

# 2 消息发送所面临的问题

请看下面一段伪代码

```
void foo1(){
    // 业务操作，例如写数据库，调用服务等
    // 发送消息
}
```

上述的流程可能出现生以下问题

1. 业务操作在前，发送消息在后，如果业务操作成功，但是消息发送不出去(可能应用挂了)
1. 如果业务成功，应用也没有挂掉，但是消息系统挂掉了，也会导致消息发不出去

再来看另一段伪代码

```
void foo1(){
    // 发送消息
    // 业务操作，例如写数据库，调用服务等
}
```

这种方式更不可靠，在业务还没有做时消息就发送出去了。

在具体的工程实践中，第一种做法丢失消息的比例是相对很低的。当然，对于要求必须保证一致性的场景中，上面的两种方案都不能接受

# 3 基于消息中间件的解决办法

首先，我们来思考一下要解决的问题，我们希望保证业务操作与发送相关消息的动作是一致的，而前面的简单方案不能完全保证，但是出现问题的概率不大，所以，我们希望找到一种解决方案，这种方案对于正常流程的影响要尽可能小，而且在有问题的场景能解决问题

![fig1](/images/消息中间件的消息发送一致性/fig1.png)

流程介绍如下

1. 业务处理应用首先把消息发给消息中间件，标记消息的状态为待处理
1. 消息中间件收到消息后，把消息存储在消息存储中，并不投递该消息
1. 消息中间件返回消息处理的结果，结果是成功或者失败
1. 业务方收到消息中间件返回的结果并进行处理：
    * 如果收到的结果是失败，那么就放弃业务处理，结束
    * 如果收到的结果是成功，则进行业务自身的操作
1. 业务操作完成，把业务操作的结果发送给消息中间件
1. 消息中间件收到业务操作结果，根据结果进行处理：
    * 如果业务失败，则删除消息存储中的消息，结束
    * 如果业务成功，则更新消息存储中的消息状态为可发送，并且进行调度，进行消息的投递

在上述流程中，可能会产生很多种异常情况，我们将逐一进行分析

1. __业务应用发送消息给消息中间件__。如果这一步失败了，无论是网络原因还是消息中间件的原因，或是业务自身的原因，我们都会看到业务操作没有做，消息也没有被存储在消息中间件中，业务操作和消息的状态是一样的，没有问题
1. __消息中间件把消息入库__。如果这一步失败，无论是消息存储有问题，还是消息中间件收到业务消息后有问题，或是网络问题，可能造成的结果有两个：
    * 一是消息中间件失效，那么业务应用是收不到消息中间件的返回结果的
    * 二是消息中间件插入消息失败，并且有能力返回结果给应用，这时消息存储中没有信息
1. __业务应用接受消息中间件返回结果异常__。这里出现异常的原因可能是网络、消息中间件的问题，也可能是业务应用自身的问题。如果业务应用自身没问题，那么业务应用并不知道消息在消息中间件的处理结果，就会按照消息发送失败来处理，__如果这时消息在消息中间件中入库成功的话，就会造成不一致了__；如果未处理成功，则还是不一致
1. __业务应用进行业务操作__。这一步不会产生太大问题
1. __业务应用发送业务操作结果给消息中间件__。如果这一步出现问题，那么消息中间件将不知道该如何处理已经存储在消息存储中的消息，可能会造成不一致
1. __消息中间件更新消息状态__。如果这一步出现问题，与上一步所造成的结果类似

我们分别从业务应用和消息中间件的视角来梳理一下上述异常情况

* 从业务应用的视角分析异常情况

| 异常情况 | 可能的状态 |
|:--|:--|
| 发送消息给消息中间件前失败 | 业务操作未进行，消息未入存储 |
| 消息发出后没有收到消息中间件的响应 | 业务操作未进行，消息存入存储，状态为待处理<br>业务操作未进行，消息未入存储 |
| 收到消息中间件返回成功，但是没有来得及处理业务就失败 | 业务操作未进行，消息存入存储，状态为待处理 |

* 从消息中间件的视角分析异常情况

| 异常情况 | 可能的状态 |
|:--|:--|
| 没有收到业务应用关于业务操作的处理结果 | 业务操作未进行，消息存入存储，状态为待处理<br>业务操作未进行(回滚)，消息存入存储，状态为待处理<br>业务操作成功，消息存入存储，状态为待处理 |
| 收到业务应用的业务操作结果，处理存储中的消息状态失败 | 业务操作未进行，消息存入存储，状态为待处理<br>业务操作未进行(回滚)，消息存入存储，状态为待处理<br>业务操作成功，消息存入存储，状态为待处理 |

从上面的梳理和分析中可以看到，对于各种异常情况我们遇到的状态有如下三种

1. 业务操作未进行，消息未入存储
1. 业务操作未进行，消息存入存储，状态为待处理
1. 业务操作成功，消息存入存储，状态为待处理

对于上述第一种情况，不需要进行额外的处理，因为本身就是一致的。第二第三种情况都需要了解业务操作的结果，然后来处理已经在消息存储中、状态是待处理的消息

下图为补偿流程

![fig2](/images/消息中间件的消息发送一致性/fig2.png)

由消息中间件主动询问业务应用，获取待处理消息所对应的业务操作的结果，然后业务应用需要对业务操作的结果进行检查，并且把结果发送给消息中间件(业务处理结果有失败、成功、等待三种，等待是多出来的一种状态，代表业务操作还在处理中)，然后消息中间件根据这个处理结果，更新消息状态。可以说，这是发送消息的一个反向流程

同样，这个流程也会出现很多异常。不过这4步的流程就是为了确认业务处理操作的结果，真正的操作只是根据业务处理结果来更改消息的状态。所以，前面3步都与查询有关，如果失败就失败了，而最后一步的更新状态如果失败了，那么就定时重复这个反向流程，重复查询就可以

发送消息的正向流程和检查业务操作结果的反向流程结合起来，就是解决业务操作与发送消息一致性的方案。在大多数情况下，反向流程不需要工作。下面我们来看看正向流程是否带来了额外的负担

| 传统方式 | 解决一致性的方案 |
|:--|:--|
| (1)业务操作<br>(2)发送消息给消息中间件<br>(3)消息中间件入库消息<br>(4)消息中间件返回结果 | (1)发送消息给消息中间件<br>(2)消息中间件入库消息<br>(3)消息中间件返回结果<br>(4)业务操作<br>(5)发送业务操作结果给消息中间件<br>(6)更改存储中消息状态 |

可以看出，解决一致性的方案是只增加了一次网络和一次更新存储中消息状态的操作，就是第5和第6两步。前面4步和传统方式所做的事情都一样，只是顺序有所不同。所以整体上带来的额外开销并不大

下面就是业务应用的流程的伪代码

```
Result postMessage(Message, PostMessageCallback){
    // 发送消息给消息中间件
    // 获取返回结果
    // 如果失败，返回失败
    // 进行业务操作
    // 获取业务操作结果
    // 发送业务操作结果给消息中间件
    // 返回处理结果
}
```

# 4 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 大型网站系统与Java中间件实践
