---
title: InnoDB数据库引擎的事务隔离级别
date: 2017-09-02 14:13:31
tags: 
- 摘录
categories: 
- 数据库
- 基本概念
---

__目录__

<!-- toc -->
<!--more-->

# 1 ACID

__A：事务的原子性(Atomicity)__：指一个事务要么全部执行，要么不执行。也就是说一个事务不可能只执行了一半就停止了。比如你从取款机取钱，这个事务可以分成两个步骤：1划卡，2出钱。不可能划了卡，而钱却没出来。这两步必须同时完成，要么就不完成。
__C：事务的一致性(Consistency)__：指事务的运行并不改变数据库中数据的一致性。例如，完整性约束了a+b=10，一个事务改变了a，那么b也应该随之改变。
__I：独立性(Isolation)__：事务的独立性也有称作隔离性，是指两个以上的事务不会出现交错执行的状态。因为这样可能会导致数据不一致。
__D：持久性(Durability)__：事务的持久性是指事务执行成功以后，该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚。

# 2 名词解释

## 2.1 第一类丢失更新

A事务撤销时，把已经提交的B事务的更新数据覆盖了

| 时间 | 取款事务A | 转账事务B |
|:--|:--|:--|
| T1 | __开始事务__ | / |
| T2 | / | __开始事务__ |
| T3 | 查询账户余额为1000元 | / |
| T4 | / | 查询账户余额为1000元 |
| T5 | / | 汇入100元，把余额改为1100元 |
| T6 | / | __提交事务__ |
| T7 | 取出100元，把余额改为900元 | / |
| T8 | __撤销事务__ | / |
| T9 | __余额恢复为1000元(丢失更新)__ | / |

__第一类丢失更新的本质是：写操作所依赖的原数据是无效的，因此串行化写操作即可解决第一类丢失更新问题，即Read uncommitted可以解决第一类丢失更新的问题__

## 2.2 第二类丢失更新

A事务覆盖B事务已经提交的数据，造成B事务所作的操作丢失

| 时间 | 取款事务A | 转账事务B |
|:--|:--|:--|
| T1 | / | __开始事务__ |
| T2 | __开始事务__ | / |
| T3 | / | 查询账户余额为1000元 |
| T4 | 查询账户余额为1000元 | / |
| T5 | / | 取出100元，把余额改为900元 |
| T6 | / | __提交事务__ |
| T7 | 汇入100元 | / |
| T8 | __提交事务__ | / |
| T9 | __把余额改为1100元(丢失更新)__ | / |

__第二类丢失更新的本质是：取款事务A一开始查询的1000元是无效数据，如果在B事务提交后再查询一次账户余额，将会得到不同的结果。我们只要保证读取的一定是有效数据即可，即可重复读。因此Repeatable read可以解决第二类丢失更新问题__

## 2.3 脏读

脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

## 2.4 不可重复读

是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。

## 2.5 幻读

是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象
发生了幻觉一样。

# 3 事务隔离级别以及实现方式

## 3.1 Read uncommitted(读未提交)

__实现方式__：

* 事务读数据时不加锁
* 事务写数据的时候(写操作时才加锁而不是事务一开始就加锁)加__行级共享锁__，__事务结束释放__

行级别的共享锁可以防止两个同时的写操作，但是不会对读产生影响。因此可以避免第一类丢失更新，但是会产生脏读的问题。

## 3.2 Read committed(读已提交)

__实现方式__：

* 事务读数据的时候(读操作时才加锁而不是事务一开始就加锁)加__行级共享锁__，__读完释放__
* 事务写数据的时候(写操作时才加锁而不是事务一开始就加锁)加__行级独占锁__，__事务结束释放__

由于事务写操作加上独占锁，因此事务写操作时，读操作不能进行，因此，不能读到事务的未提交数据，避免了脏读问题，__但是由于读操作的锁加在读上面，而不是加在事务之上，所以，在同一事务的两次读操作之间可以插入其他事务的写操作，所以可能发生不可重复读的问题__

## 3.3 Repeatable read(可重复读)

__实现方式__：

* 事务读数据的时候(读操作时才加锁而不是事务一开始就加锁)加__行级共享锁__，__事务结束释放__
* 事务写数据的时候(写操作时才加锁而不是事务一开始就加锁)加__行级独占锁__，__事务结束释放__

由于事务读操作在事务结束后才释放共享锁，因此可以避免在同一读事务中读取到不同的数据，另外可以避免第二类丢失更新的问题。

## 3.4 Serializable(串行化)

__实现方式__：

* 事务读数据的时候(读操作时才加锁而不是事务一开始就加锁)加__表级共享锁__，__事务结束释放__
* 事务写数据的时候(写操作时才加锁而不是事务一开始就加锁)加__表级独占锁__，__事务结束释放__

# 4 总结

| 隔离级别 | 是否出现脏读 | 是否出现不可重复读 | 是否出现幻读 | 是否出现第一类丢失更新 | 是否出现第二类丢失更新 |
|:--|:--|:--|:--|:--|:--|
| Serializable | 否 | 否 | 否 | 否 | 否 |
| Repeatable read | 否 | 否 | 是 | 否 | 否 |
| Read committed | 否 | 是 | 是 | 否 | 是 |
| Read uncommitted | 是 | 是 | 是 | 否 | 是 |

# 5 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* [数据库事务隔离级别和锁的实现方式](http://blog.csdn.net/yangtianyu1218/article/details/51543634)
* [第一类第二类丢失更新](http://blog.csdn.net/lqglqglqg/article/details/48582905)
* [数据库事务隔离级别-- 脏读、幻读、不可重复读（清晰解释）](http://blog.csdn.net/jiesa/article/details/51317164)
