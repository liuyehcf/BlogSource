---
title: CleanCode
date: 2017-10-13 16:05:05
tags: 
- 摘录
categories: 
- 代码规范
---

__目录__

<!-- toc -->
<!--more-->

# 1 命名

1. 别用`accountList`来指称一组账号
    > List对于程序员有特殊的意义（容器）

1. 废话是一种没意义的区分，且废话都是冗余的
    > ProductInfo类与ProductData类，虽然名字不同，意思却无区别
    > NameString与Name，显然Name更好，String就是个废话

1. 对Java而言，不需要把类型或作用域编码进名称
    > Java是个强类型语言

1. 对Java而言，不需要使用成员前缀`m_`
1. 类名__不应当__是动词
1. 方法名应当是`动词`或`动词短语`
1. 重载构造器，使用描述了参数的静态工厂方法名
    > `Complex fulcrumPoint = Complex.FromRealNumber(23.0)`

1. 别用俚语作为方法名，__言到意到，意到言到__
    > 别用`eatMyShorts()`来表示`abort()`

1. __给每个抽象概念选一个词，且一以贯之__
    > 别同时出现fetch、retrieve和get

1. 避免将同一单词用于不同目的。同一术语用于不同概念，基本就是双关
    > 如果在多个类中add表示组合的含义，那么将元素插入集合就尽量别用add，可以选用insert或者append等等

1. 不要添加没用的语境
    > 若有一个名为”加油站豪华版“（Gas Station Deluxe）的应用，在其中给每个类添加GSD前缀就不是什么好点子

# 2 函数

1. __函数的第一个规则是要短小，第二条规则是还要更短小__
    > if语句块，else语句，while语句等，其中的代码块应该只有一行，大抵应该是一个函数调用语句，这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称

1. 函数，应该做一件事，做好这件事，只做这一件事
    > 如果函数只是做了该函数名下同一抽象层上的步骤，则函数还是只做了一件事
    > 如判断函数是否不止做了一件事：看能否再拆出一个函数，该函数不仅只是单纯地重新诠释其实现
    > P33

1. 每个函数一个抽象层级
    > 函数中混杂不同抽象层级，往往让人迷惑，读者可能无法判断某个表达式是基础概念还是细节

1. switch语句
    > 如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，其他部分看不到，那就还能够忍受
    > P35的例子

1. 最理想的参数数量是零，其次是一，再次是二，尽量避免三
    > 参数与函数名处于不同的抽象级别，它要求你了解目前并不特别重要的细节
    > 从测试的角度看，参数甚至叫人为难，编写能确保参数的各种组合运行正常的测试用例，是很困难的事情

1. __标志参数丑陋不堪__
    > 向函数传入布尔值简直就是骇人听闻的做法。这样做方法签名立刻变得复杂起来，宣布本函数不止做一件事情，如果标志为true会这样做，如果标志为false会那样做

1. 分隔指令与询问
    > 函数要么做什么事，要么回答什么事，二者不可得兼

1. 使用异常代替返回错误码
    > 返回错误码会导致更深层次的嵌套结构(if嵌套结构)，而且，当返回错误码时，就是要求调用者立刻处理错误
    > 如果使用异常，就能将错误处理代码从主路径代码中分离出来，得到简化
    > 另外，返回错误码通常暗示着某处有个类或者是枚举，如下
```Java
public enum Error {
    OK,
    INVALID,
    NO_SUCH,
    LOCKED,
    OUT_OF_RESOURCES,
    WAITING_FOR_EVENT;
}
```
    > 这会导致许多类都导入和使用它，当该枚举类修改时，所有这些依赖该枚举的类都得重新编译和部署，造成了负面压力

1. 抽离try/catch代码块
    > try/catch代码块搞乱了代码的结构，把错误处理与正常流程混为一谈，最好把try和catch代码块主体部分抽离出来，另外形成函数

1. 处理错误的函数不该做其他事情，__因为错误处理就是一件事__

# 3 注释

1. 注释的恰当使用是弥补我们在用代码表达意图时遭遇的__失败__
    > 注释存在时间越久，就离其所描述的代码越远。原因很简单，程序员不能坚持维护注释

1. 注释不能美化糟糕的代码
    > 有时间写注释，不如整理代码

1. 用代码来阐述，有时候只需要创建一个描述与注释所言相同的函数即可
    > 例如
```Java
// Check to see if the employee is eligible for full benefits
if ((employee.flags & HOURLY_FALG) &&
    (employee.age > 65))

if (employee.isEligibleForFullBenefits())
```

1. 对意图的解释，即解释后面一段代码的意图
1. //TODO注释是一种程序员认为应该做，但是由于某些原因目前还没有做的工作
1. 别写日志式注释
    > 这类注释就是记录每次的修改，现在有版本控制软件，这些就不需要了

1. 能用函数变量时就别用注释
1. 括号后面的注释
    > 形如
```Java
if(a == 1){
    while(true){
        // ...
    } // while
}// if
```
    > 当你想要写这类注释时，其实应该做的是缩短函数

1. 尽量避免注释的代码
    > 既然不用，就删掉这些代码。版本控制工具会帮我们记录这些东西

# 4 对象和数据结构

1. 隐藏实现并非只是在变量之间放上一个函数层那么简单。__隐藏关乎抽象__
1. 数据、对象的反对称性
    > 过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数。过程式代码难以添加新的数据结构，因为必须修改所有的函数
    > 面向对象代码便于在不改动既有函数的前提下添加新类。面向对象代码难以添加新函数，以为必须修改所有的类

1. 得墨忒耳律：模块不应了解它所操作对象的内部情形
    > 类C的方法f只应该调用以下对象的方法
    > * C
    > * 由f创建的对象
    > * 作为参数传递给f的对象
    > * 由C的实体变量持有的对象
    > 
    > 即方法不应调用由任何函数返回的对象的方法。换言之，只跟朋友谈话，不与陌生人谈话
    > `final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();`违反了得墨忒耳律

# 5 错误处理

1. 使用异常而非返回码
    > 返回码容易搞乱调用者代码，调用者必须在调用之后立即检查错误

1. 异常的巧妙处之一是，它们在程序中定义了一个范围
1. 尽量不要返回null值
    > 用特例对象代替null值，null值会造成太多的null检查语句，十分恶心

1. 尽量别传递null值
    > 在大多数编程语言中，没有良好的方法能对付由调用者意外传入的null值。恰当的做法就是禁止传入null值

1. 可控异常违反了开放/闭合原则
    > 如果某个最底层的函数修改成抛出一个可控异常，那么每个调用该函数的函数都要修改，捕获新异常，或者在签名中添加throws子句

1. 打包调用API，确保返回通用的异常类型（自定义异常类型，封装了API抛出的不同类型的异常），从而简化代码
    > P99-100例子

# 6 边界

1. 避免我们的代码过多地了解第三方代码中的特定信息
    > 依靠你能控制的东西，好过依靠你控制不了的东西（第三方代码），面得日后受它控制
    > P109的学习测试展示了：封装的函数正好用于屏蔽第三方代码的特定信息

# 7 单元测试(Test-Driven Development, TDD)

1. TDD三定律
    > 1. 在编写不能通过的单元测试前，不可编写生产代码
    > 1. 只可编写刚好无法通过的单元测试，不能编译也算不通过
    > 1. 只可编写刚好足以通过当前失败测试的生产代码

1. 测试代码和单元测试同样重要
1. 测试三要素：可读性、可读性和可读性
1. 构造-操作-检验模式(BUILD-OPERATE-CHECK)
    > 每个测试清晰地拆分为三个环节，每个环节封装成一个函数
    > 1. 第一个环节构造测试数(given开头的函数名)
    > 1. 第二个环节操作测试数据(when开头的函数名)
    > 1. 第三个环节检验操作是否得到期望结果(then开头的函数名)

1. 每个测试一个断言
    > 将测试都归结为一个能够快速方便理解的结论

1. 每个测试一个概念
    > 与函数类似，测试只测一件事

1. F.I.R.S.T
    > 1. 快速(Fast)
    > 1. 独立(Independent)
    > 1. 可重复(Repeatable)
    > 1. 自足验证(Self-Validating)
    > 1. 及时(Timely)

# 8 类

1. 类的第一条规则是短小，第二条规则还是要短小
    > 不要写出"神的类" :)

1. 类的名称应当描述其权责
    > 类的命名正是帮助判断类的长度的第一个手段。如果无法为某个类命以精确的名称，那么这个类可能太长了，职责太多了。比如Processor、Manager、Super等等命名的类，这些类往往有权责聚集的问题

1. 单一权责原则(Simple Responsibility Principle, RSP)
    > 系统应该由许多短小的类而不是少量巨大的类组成
    > 不要惧怕大量短小单一目的的类
    > 你是想把工具归置到有许多抽屉、每个抽屉中装有定义和标记良好的组件的工具箱中呢，还是想要少数几个能随便把所有东西都扔进去的抽屉？

1. 内聚
    > 类应该只有少量实体变量。类中的每个方法都应该操作一个或多个这种变量
    > 通常而言，方法操作的变量越多，就越黏聚到类上
    > 如果一个类中的每个变量都被每个方法使用，则该类具有最大的内聚性
    > 内聚性越高，意味着类中的方法和变量相互依赖，互相结合成一个逻辑整体

1. 保持内聚性就会得到许多短小的类
    > 将大函数拆分为许多小函数，往往也是将类拆分成多个小类的时机
    > 1. 拆分成小函数时，往往需要传入多个局部参数
    > 1. 此时我们可以将局部参数改写成类的实体变量
    > 1. 于是就变成了含有很多实体变量的大类，且呈现出分散的内聚性，于是可以拆分成小类

1. 通过扩展系统而非修改现有代码来添加新特性
1. 隔离修改
    > 我们可以借助接口和抽象类来隔离这些细节带来的影响
    > 依赖倒置原则，类应当依赖抽象而不是依赖具体细节

# 9 系统

1. 将系统的构造与使用分开
    > 软件系统应将起始过程和起始过程之后的运行时逻辑分开，在起始过程中构建应用对象，也会存在互相缠结的依赖关系

1. 依赖注入，控制反转

# 10 跌进

1. 设计必须制造出如逾期一般工作的系统，这是首要因素
    > 不可测试的系统同样不可验证。不可验证的系统，绝不应部署

1. 放心重构，测试消除了对清理代码就会破坏代码的恐惧
1. 不可重复
    > 重复是拥有良好设计系统的大敌，它代表着额外的工作，额外的风险且不必要的复杂度
    > 例如`isEmpty()`可以利用`return 0 == size();`来实现，即重用`size()`方法

1. 模板方法模式
1. 在保持SRP的原则上，也要尽可能减少类和方法的数目
    > 这条规则的优先级较小，首先要保证的是：`测试`、`消除重复`、`表达力`

# 11 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《代码整洁之道》
