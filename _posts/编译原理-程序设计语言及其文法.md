---
title: 编译原理-程序设计语言及其文法
date: 2017-10-14 10:14:56
mathjax: true
tags: 
- 摘录
categories: 
- 编译
---

__目录__

<!-- toc -->
<!--more-->

# 1 基本概念

## 1.1 字母表

__字母表$\sum$是一个有穷符号集合__

* 符号：字母、数字、标点符号、...

例：

1. 二进制字母表：{ 0,1 }
1. ASCII字符集
1. Unicode字符集

### 1.1.1 字母表上的运算

字母表$\sum_1$和$\sum_2$的__乘积(product)__

* $\sum_1 \sum_2 = \{ ab | a \in \sum_1, b \in \sum_2 \}$

字母表$\sum$的__n次幂(power)__

* $\begin{cases} \sum^0 = \{ \varepsilon \}\\
\sum^n = \sum^{n-1} \sum, n \ge 1 \end{cases}$

字母表$\sum$的__正闭包(positive closure)__，即长度为正数的符号串构成的集合

* $\sum^+ = \sum \cup \sum^2 \cup \sum^3 ...$

字母表$\sum$的__克林闭包(Kleene closure)__，任意符号串构成的集合

* $ \sum^* = \sum^0 \cup \sum^+ = \sum^0 \cup \sum \cup \sum^2 \cup \sum^3 ...$

## 1.2 串

设$\sum$是一个字母表，$\forall x \in \sum^*$，$x$称为是$\sum$上的一个串

* 串是字母表中符号的一个有穷序列
* 串s的长度，通常记作$|s|$，是指s中符号的个数
* 空串是长度为0的串，用$\varepsilon$（epsilon）表示

### 1.2.1 串上的运算

如果$x$和$y$是串，那么$x$和$y$的__连接(concatenation)__是把$y$附加到$x$后面而形成的串，记作$xy$

* 空串是连接运算的__单位元(identity)__，即对于任何串$s$都有，$\varepsilon s = s \varepsilon = s$

串$s$的__幂运算__

* $\begin{cases} s^0 = \{ \varepsilon \}\\
s^n = s^{n-1} s, n \ge 1 \end{cases}$

# 2 文法的定义

## 2.1 文法的形式化定义

文法可以用数学符号$G = (V_T, V_N, P, S)$表示

1. $V_T$：__终结符集合__。终结符(terminal symbol)是文法所定义的语言__基本符号__，有时也称为token。换言之，就是原子的，不可再分的（例如英文中的单词就是终结符）
1. $V_N$：__非终结符集合__。非终结符(nonterminal)是用来表示语法成分的符号，有时也称为__语法变量__。换言之，就是非原子的，可再分的（例如`<句子>`,`<名词短语>`,`<动词短语>`）
1. $P$：__产生式集合__。产生式(production)描述了将终结符和非终结符组合成串的方法。产生式的一般形式为：$$\alpha \to \beta$$
    * $\alpha \in (V_T \cup V_N)^+$，且$\alpha$中至少包含$V_N$中的一个元素，称为产生式的__头__(head)或__左部__(left side)
    * $\beta \in (V_T \cup V_N)^*$，称为产生式的__体__(body)或__右部__(right side)
1. $S$：__开始符号__。$S \in V_N$。开始符号(start symbol)表示的是该文法中最大的语法成分
* 另外，$V_T$与$V_N$满足
    * $V_T \cap V_N = \Phi$
    * $V_T \cup V_N = 文法符号集$
* __终结符(terminal symbol)__与__非终结符(nonterminal)__统称为__文法符号__

## 2.2 产生式的简写

对一组有相同左部的$\alpha$产生式
$$\alpha \to \beta_1, \alpha \to \beta_2, ..., \alpha \to \beta_n$$
可以简记为
$$\alpha \to \beta_1 | \beta_2 | ... | \beta_n$$
$\beta_1, \beta_2, ..., \beta_n$称为$\alpha$的__候选式__

## 2.3 符号约定

__下述符号是终结符__

1. 字母表中排在前面的小写字母，如a、b、c
1. 运算符，如+、*等
1. 标点符号，如逗号、括号等
1. 数字，0，1，2，...，9
1. 粗体字符串，如id，if等

__下述符号是非终结符__

1. 字母表中排在前面的大写字母
1. 字母S，通常表示__开始符号__
1. 小写、斜体的名字，如*expr、stmt*等
1. 代表程序构造的大写字母
    * E：表达式
    * T：项
    * F：因子

__其他规则__

1. 字母表中__排在后面的大写字母__，如X、Y、Z，表示__文法符号__（即终结符或非终结符）
1. 字母表中__排在后面的小写字母__，主要是u、v、...、z，表示__终结符号串__（包括空串）
1. 小写希腊字母，如$\alpha, \beta, \gamma$，表示__文法符号串__（包括空串）
1. 除非特别说明，第一个产生式的左部就是开始符号

# 3 语言的定义

## 3.1 推导和归约

给定文法$G = (V_T, V_N, P, S)$，如果$\alpha \to \beta \in P$，那么可以将符号串$\gamma \alpha \delta$中的$\alpha$__替换__为$\beta$，也就是说，将$\gamma \alpha \delta$__重写(rewrite)__为$\gamma \beta \delta$，记作$\gamma \alpha \delta \Rightarrow \gamma \beta \delta$。此时称文法中的符号串$\gamma \alpha \delta$__直接推导__出$\gamma \beta \delta$

* 简而言之，就是用__产生式的右部__替换__产生式的左部__

如果$\alpha_0 \Rightarrow \alpha_1, \alpha_1 \Rightarrow \alpha_2, ..., \alpha_{n-1} \Rightarrow \alpha_n$，则可以记作$\alpha_0 \Rightarrow \alpha_1  \Rightarrow \alpha_2 \Rightarrow ... \Rightarrow \alpha_{n-1} \Rightarrow \alpha_n$。称符号串$\alpha_0$__经过n步推导__出$\alpha_n$，简记为$\alpha_0 \Rightarrow^n \alpha_n$

* $\alpha \Rightarrow^0 \alpha$
* $\Rightarrow^+$表示“经过正数步推导”
* $\Rightarrow^*$表示“经过若干（可以是0）步推导”

__归约就是推导的逆过程__

如何判断某一词串是否是该语言的句子

* 句子的推导--从__生成__语言的角度
* 句子的归约--从__识别__语言的角度

## 3.2 句型和句子

如果$S \Rightarrow^\* \alpha, \alpha \in (V_T \cup V_N)^\*$，则称$\alpha$是$G$的一个__句型__(sentential form)

* 一个句型中既可以包含__终结符__，又可以包含__非终结符__，也可能是空串

如果$S \Rightarrow^\* w, w \in V_T^\*$，则称$w$是$G$的一个__句子__

* 句子是不包含非终结符的__句型__

## 3.3 语言的形式化定义

由文法$G$的开始符号$S$推导出的所有__句子__构成的集合称为__文法$G$生成的语言__，记为$L(G)$，即$$L(G) = \{ w | S \Rightarrow^\* w, w \in V_T^\*\}$$

# 4 Chomsky文法分类体系

## 4.1 0型文法（Type-0 Grammar）

$$\alpha \to \beta$$

0型文法又称为__无限制文法(Unrestricted Grammar)__或__短语结构文法(Phrase Structure Grammar, PSG)__

* $\forall \alpha \to \beta \in P$，$\alpha$中至少包含1个非终结符

0型语言：由0型文法$G$生成的语言$L(g)$

## 4.2 1型文法（Type-1 Grammar）

$$\alpha \to \beta$$

1型文法又称为__上下文有关的文法(Context-Sensitive Grammar, CSG)__

* $\forall \alpha \to \beta \in P, |\alpha| \le |\beta|$
* 产生式的一般形式：$\alpha_1 A \alpha_2 \to \alpha_1 \beta \alpha_2, \beta \ne \varepsilon$

1型语言（上下文有关语言）：由上下文有关文法（1型文法）$G$生成的语言$L(g)$

## 4.3 2型文法（Type-2 Grammar）

$$\alpha \to \beta$$

2型文法又称为__上下文无关文法(Context-Free Grammar, CFG)__

* $\forall \alpha \to \beta \in P, \alpha \in V_N$
* 产生式的一般形式：$A \to \beta$

2型语言（上下文无关语言）：由上下文无关文法（2型文法）$G$生成的语言$L(g)$

## 4.4 3型文法（Type-3 Grammar）

$$\alpha \to \beta$$

3型文法又称为__正则文法(Regular Grammar, RG)__

* __右线性(Right Linear)文法__：$A \to wB$或$A \to w$
* __左线性(Left Linear)文法__：$A \to Bw$或$A \to w$

3型语言（正则语言）：由正则文法（3型文法）$G$生成的语言$L(g)$

## 4.5 四种文法之间的关系

__逐级限制__

* 0型文法：$\alpha$中至少包含一个终结符
* 1型文法（CSG）：$|\alpha| \le |\beta|$
* 2型文法（CFG）：$\alpha \in V_N$
* 3型文法（RG）：$A \to wB$或$A \to w$($A \to Bw$或$A \to w$)

__逐级包含__

* 0型文法包含1型文法
* 1型文法包含2型文法
* 2型文法包含3型文法

# 5 文法的分类

## 5.1 CFG分析树

![fig1](/images/编译原理-程序设计语言及其文法/fig1.jpg)

1. __根节点__的标号为文法__开始符号__
1. __内部节点__表示对一个产生式$A \to \beta$的应用，该__节点的标号__是此__产生式左部$A$__。该节点的__子节点标号__从左到右构成了__产生式的右部$\beta$__
1. __叶节点__的标号既可以是__非终结符__，也可以是__终结符__。从左到右排列叶节点得到的符号串称为是这棵__树的产出(yield)__或__边缘(frontier)__

给定一个推导$S \Rightarrow \alpha_1 \Rightarrow \alpha_2 \Rightarrow ...  \Rightarrow \alpha_n$，对于推导过程中的每一个__句型$a_i$__，都可以构造出一个边缘为$a_i$的__分析树__

## 5.2 短语

给定一个句型，其分析树中__每一棵子树的边缘__，称为该句型的一个__短语(phrase)__

* 如果子树只有父子两代节点，那么这棵子树的边缘称为该句型的一个直接短语
* 直接短语一定是某产生式的右部
* 产生式的右部不一定是给定句型的直接短语，即这个产生式的右部不构成一对父子节点

## 5.3 二义性文法

如果一个文法可以为某个句子生成__多棵分析树__，则称这个文法是__二义性__的

例如
> 给定文法$G$，满足$$S \to \textbf{if}\;\;E\;\;\textbf{then}\;\;S\;\;|\;\;\textbf{if}\;\;E\;\;\textbf{then}\;\;S\;\;\textbf{else}\;\;S\;\;|\;\;other$$
> 给定句型：$$\textbf{if}\;\;E_1\;\;\textbf{then}\;\;\textbf{if}\;\;E_2\;\;\textbf{then}\;\;S_1\;\;\textbf{else}\;\;S_2$$

> ![fig2](/images/编译原理-程序设计语言及其文法/fig2.jpg)

> __消除歧义：每个else和最近的尚未匹配的if匹配__

二义性文法的判定：对于任意一个__上下文无关文法__，不存在一个算法，判定它是无二义性的。但能给出一个充分条件，满足这组充分条件的文法一定是无二义性的

* 满足，肯定无二义性
* 不满足，未必有二义性

# 6 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《MOOC-编译原理-陈鄞》
* [Latex所有常用数学符号整理](http://blog.csdn.net/ying_xu/article/details/51240291)
