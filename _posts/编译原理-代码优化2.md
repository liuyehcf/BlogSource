---
title: 编译原理-代码优化2
date: 2017-11-23 13:24:38
mathjax: true
tags: 
- 摘录
categories: 
- 编译
---

__目录__

<!-- toc -->
<!--more-->

# 1 数据流分析

数据流分析：一组用来获取程序执行路径上的数据流信息的技术

数据流分析应用

1. 到达-定值分析(Reaching-Definition Analysis)
1. 活跃变量分析(Live-Variable Analysis)
1. 可用表达式分析(Available-Expression Analysis)
* 在每一种数据流分析应用中，都会把每个__程序点__和一个__数据流值__关联起来

## 1.1 语句的数据流模式

$IN[s]$：语句$s$之前的数据流值

$OUT[s]$：语句$s$之后的数据流值

$f_s$：语句$s$的__传递函数__(transfer function)

* 一个赋值语句$s$之前和之后的数据流值的关系
* 传递函数的两种风格
    * 信息沿执行路径前向传播(前向数据流问题)$$OUT[s] = f_s (IN[s])$$
    * 信息沿执行路径逆向传播(逆向数据流问题)$$IN[s] = f_s (OUT[s])$$

基本块中相邻两个语句之间的数据流值的关系

* 设基本块B由语句$s_1, s_2, ..., s_n$顺序组成，则$$IN[s_{i+1}]= OUT[s_i], i=1, 2, ..., n-1$$

## 1.2 基本块上的数据流模式

$IN[B]$：紧靠基本块B__之前__的数据流值

$OUT[B]$：紧随基本块B__之后__的数据流值

设基本块B由语句$s_1, s_2, ..., s_n$顺序组成，则

* $IN[B] = IN[s_1]$
* $OUT[B] = OUT[s_n]$

$f_B$：基本块B的传递函数

* 前向数据流问题：$$OUT[B] = f_B(IN[B]), f_B = f_{s_n} \cdot ... \cdot f_{s_2} \cdot f_{s_1}$$
* 逆向数据流问题：$$IN[B] = f_B(OUT[B]), f_B = f_{s_1} \cdot f_{s_2} \cdot ... \cdot f_{s_n}$$

# 2 到达定值分析

## 2.1 概念

__定值(Definition)__

* 变量$x$的__定值__是(可能)将一个值赋给$x$的__语句__

__到达定值(Reaching Definition)__

* 如果__存在一条__从紧跟在定值$d$后面的点到达某一程序点$p$的路径，而且在此路径上$d$没有被“杀死”（如果在此路径上有对变量$x$的其它定值$d^{\\'}$，则称变量$x$被这个定值$d^{\\'}$__“杀死”__了），则称__定值__$d$__到达__程序点$p$
* 直观地讲，如果某个变量$x$的一个定值$d$到达点$p$，在点$p$处使用的$x$的值__可能__就是由$d$__最后赋予__的

## 2.2 例子

![fig1](/images/编译原理-代码优化2/fig1.jpg)

对于基本块$B_2$

* $d_1$是$i$的定值，__可达__
* $d_2$是$j$的定值，__可达__
* $d_3$是$a$的定值，__可达__
* $d_4$是$i$的定值，在经过循环重新到达$B_2$时，已被$d_7$杀死，__不可达__
* $d_5$是$j$的定值，在经过循环重新到达$B_2$时，未被杀死，__可达__
* $d_6$是$a$的定值，在经过循环重新到达$B_2$时，未被杀死，__可达__
* $d_7$是$i$的定值，在经过循环重新到达$B_2$时，未被杀死，__可达__

对于基本块$B_3$

* $d_1$是$i$的定值，在经过基本块$B_2$时，被$d_4$杀死，__不可达__
* $d_2$是$j$的定值，在经过基本块$B_2$时，被$d_5$杀死，__不可达__
* $d_3$是$a$的定值，在经过基本块$B_2$时，未被杀死，__可达__
* $d_4$是$i$的定值，__可达__
* $d_5$是$j$的定值，__可达__
* $d_6$是$a$的定值，在经过循环重新到达$B_3$时，未被杀死，__可达__
* $d_7$是$i$的定值，在经过循环重新到达$B_3$时，已被$d_4$杀死，__不可达__

对于基本块$B_4$

* $d_1$是$i$的定值，在经过基本块$B_2$时，被$d_4$杀死，__不可达__
* $d_2$是$j$的定值，在经过基本块$B_2$时，被$d_5$杀死，__不可达__
* $d_3$是$a$的定值，经过基本块$B_2$直接到达$B_4$后（不经过$B_3$），没有被杀死，__可达__（存在一条即可，虽然经过$B_3$会被$d_6$杀死，但是不经过$B_3$就不会被杀死）
* $d_4$是$i$的定值，__可达__
* $d_5$是$j$的定值，__可达__
* $d_6$是$a$的定值，__可达__
* $d_7$是$i$的定值，在经过循环重新到达$B_4$时，已被$d_4$杀死，__不可达__

## 2.3 到达定值分析的主要用途

1. __循环不变计算的检测__
    * 如果循环中含有赋值$x=y+z$，而$y$和$z$所有可能的定值都在循环外面(包括$y$或$z$是常数的特殊情况)，那么$y+z$就是循环不变计算
1. __常量合并__
    * 如果对变量$x$的某次使用只有一个定值可以到达，并且该定值把一个常量赋给$x$，那么可以简单地把$x$替换为该常量
1. 判定变量$x$在$p$点上是否__未经定值__就__被引用__

## 2.4 “生成”与“杀死”定值

定值$d: u = v + w$

* 该语句__“生成”__了一个对变量$u$的定值$d$，并__“杀死”__了程序中其它对$u$的定值

## 2.5 到达定值的传递函数

$f_d$：定值$d: u = v + w$的传递函数

* $f_d(x) = gen_d \cup (x-kill_d)$，即__生成-杀死形式__
* $gen_d$：由语句$d$生成的定值的集合$gen_d =\{ d \}$
* $killd$：由语句$d$杀死的定值的集合（程序中__所有__其它对$u$的定值）

$f_B$：基本块B的传递函数

* $f_B(x) = gen_B \cup (x-kill_B)$
* $kill_B = kill_1 \cup kill_2 \cup ... \cup kill_n$：被基本块B中各个语句杀死的定值的集合
* $gen_B = gen_n \cup ( gen_{n-1} – kill_n ) \cup ( gen_{n-2} – kill_{n-1} – kill_n ) \cup ... \cup ( gen_1 –kill_2 –kill_3 – ... – kill_n )$：基本块中没有被块中各语句“杀死”的定值的集合

![fig2](/images/编译原理-代码优化2/fig2.jpg)

## 2.6 到达定值的数据流方程

$IN[B]$：到达流图中基本块B的入口处的定值的集合

$OUT[B]$：到达流图中基本块B的出口处的定值的集合

方程

* $OUT[ENRTY]=\Phi$
* $OUT[B]=f_B(IN[B]), B \ne ENTRY$
    * $f_B(x) = gen_B \cup (x-kill_B)$
* $IN[B] = \cup_{P是B的一个前驱}\;\;\;\;\;\;\;OUT[P], B \ne ENTRY$

# 3 到达定值方程的计算

## 3.1 计算到达定值的迭代算法

输入：流图G，其中每个基本块B的$gen_B$和$kill_B$都已计算出来

输出：$IN[B]和OUT[B]$

方法：

* ![fig3](/images/编译原理-代码优化2/fig3.jpg)

## 3.2 示例

![fig4](/images/编译原理-代码优化2/fig4.jpg)

## 3.3 引用-定值链(Use-Definition Chains)

__引用-定值链__(简称$ud$链)是一个列表，对于变量的每一次引用，到达该引用的所有定值都在该列表中

* 如果块B中变量$a$的__引用之前有__$a$的__定值__，那么只有$a$的__最后一次定值__会在该引用的$ud$链中
* 如果块B中变量$a$的__引用之前没有__$a$的__定值__，那么$a$的这次引用的$ud$链就是$IN[B]$中$a$的定值的集合

# 4 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《MOOC-编译原理-陈鄞》
