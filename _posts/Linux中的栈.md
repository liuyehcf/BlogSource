---
title: Linux中的栈
date: 2017-08-20 19:52:42
tags: 
- 摘录
categories: 
- 操作系统
- Linux
---

__目录__

<!-- toc -->
<!--more-->

# 1 进程栈

进程栈是属于用户态栈，和进程虚拟地址空间(Virtual Address Space)密切相关。那我们先了解下什么是虚拟地址空间：在32位机器下，虚拟地址空间大小为4G。这些虚拟地址通过页表(Page Table)映射到物理内存，页表由操作系统维护，并被处理器的内存管理单元(MMU)硬件引用。每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间

Linux内核将这4G字节的空间分为两部分，将最高的1G字节（0xC0000000-0xFFFFFFFF）供内核使用，称为内核空间。而将较低的3G字节（0x00000000-0xBFFFFFFF）供各个进程使用，称为用户空间。每个进程可以通过系统调用陷入内核态，因此内核空间是由所有进程共享的。虽然说内核和用户态进程占用了这么大地址空间，但是并不意味它们使用了这么多物理内存，仅表示它可以支配这么大的地址空间。它们是根据需要，将物理内存映射到虚拟地址空间中使用

Linux对进程地址空间有个标准布局，地址空间中由各个不同的内存段组成(Memory Segment)，主要的内存段如下：

1. __程序段(Text Segment)__：可执行文件代码的内存映射
1. __数据段 (Data Segment)__：可执行文件的已初始化全局变量的内存映射
1. __BSS段 (BSS Segment)__：未初始化的全局变量或者静态变量（用零页初始化）
1. __堆区 (Heap)__：存储动态内存分配，匿名的内存映射
1. __栈区 (Stack)__：进程用户空间栈，由编译器自动分配释放，存放函数的参数值、局部变量的值等
1. __映射段(Memory Mapping Segment)__：任何内存映射文件

而上面进程虚拟地址空间中的栈区，正指的是我们所说的进程栈。进程栈的初始化大小是由编译器和链接器计算出来的，但是栈的实时大小并不是固定的，Linux内核会根据入栈情况对栈区进行动态增长（其实也就是添加新的页表）。但是并不是说栈区可以无限增长，它也有最大限制`RLIMIT_STACK`(一般为8M)，我们可以通过`ulimit`来查看或更改 `RLIMIT_STACK` 的值

# 2 线程栈

从Linux内核的角度来说，其实它并没有线程的概念。Linux把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了`task_struct`中。__线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和Linux中所谓线程的唯一区别__。线程创建的时候，加上了CLONE_VM标记，__这样线程的内存描述符将直接指向父进程的内存描述符__

虽然线程的地址空间和进程一样，但是对待其地址空间的stack还是有些区别的。__对于Linux进程或者说主线程，其stack是在fork的时候生成的，实际上就是复制了父亲的stack空间地址，然后写时拷贝(cow)以及动态增长__。然而对于主线程生成的子线程而言，其stack将不再是这样的了，而是事先固定下来的，使用mmap系统调用，它不带有`VM_STACK_FLAGS`标记

线程栈不能动态增长，一旦用尽就没了，这是和生成进程的fork不同的地方

# 3 进程内核栈

在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作进程内核栈。进程内核栈在进程创建的时候，通过slab分配器从`thread_info_cache`缓存池中分配出来，其大小为`THREAD_SIZE`，一般来说是一个页大小4K

在陷入内核后，系统调用中也是存在函数调用和自动变量，这些都需要栈支持。用户空间的栈显然不安全，需要内核栈的支持。此外，内核栈同时用于保存一些系统调用前的应用层信息（如用户空间栈指针、系统调用参数）

# 4 中断栈

进程陷入内核态的时候，需要内核栈来支持内核函数调用。中断也是如此，当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的。但是具体是否共享，这和具体处理架构密切相关

# 5 Linux为什么需要区分这些栈

## 5.1 为什么需要单独的进程内核栈

所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程A陷入内核态执行的时候，需要等待读取网卡的数据，主动调用schedule()让出CPU；此时调度器唤醒了另一个进程B，碰巧进程B也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程B进入内核态的时候产生的压栈操作，必然会破坏掉进程A已有的内核栈数据；一但进程A的内核栈数据被破坏，很可能导致进程A的内核态无法正确返回到对应的用户态了

## 5.2 为什么需要单独的线程栈

Linux调度程序中并没有区分线程和进程，当调度程序需要唤醒"进程"的时候，必然需要恢复进程的上下文环境，也就是进程栈；但是线程和父进程完全共享一份地址空间，如果栈也用同一个那就会遇到以下问题。假如进程的栈指针初始值为`0x7ffc80000000`；父进程A先执行，调用了一些函数后栈指针esp为`0x7ffc8000FF00`，此时父进程主动休眠了；接着调度器唤醒子线程A1：

* 此时A1的栈指针esp如果为初始值`0x7ffc80000000`，则线程A1一但出现函数调用，必然会破坏父进程A已入栈的数据
* 如果此时线程A1的栈指针和父进程最后更新的值一致，esp为`0x7ffc8000FF00`，那线程A1进行一些函数调用后，栈指针esp增加到`0x7ffc8000FFFF`，然后线程A1休眠；调度器再次换成父进程A执行，那这个时候父进程的栈指针是应该为`0x7ffc8000FF00`还是`0x7ffc8000FFFF`呢？无论栈指针被设置到哪个值，都会有问题不是吗？

## 5.3 进程和线程是否共享一个内核栈

No，线程和进程创建的时候都调用`dup_task_struct`来创建task相关结构体，而内核栈也是在此函数中`alloc_thread_info_node`出来的。因此虽然线程和进程共享一个地址空间`mm_struct`，但是并不共享一个内核栈

# 6 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf#163.com，#替换成@)，博主将在第一时间删除__

* [Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈](http://blog.csdn.net/yangkuanqaz85988/article/details/52403726)
