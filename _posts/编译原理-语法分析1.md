---
title: 编译原理-语法分析1
date: 2017-10-16 09:46:25
mathjax: true
tags: 
- 摘录
categories: 
- 编译
---

__目录__

<!-- toc -->
<!--more-->

# 1 自顶向下分析概述

自定向下分析的定义如下

* 从分析树的顶部（根节点）向底部（叶节点）方向构造分析树
* 可以看成是从文法开始符号S__推导__出词串$w$的过程
    * ![fig1](/images/编译原理-语法分析1/fig1.jpg)
* 每一步推导中，都需要做__两个选择__
    * 替换当前句型中的__哪个非终结符__
    * 用该非终结符的__哪个候选式__进行替换

## 1.1 最左推导(Left-most Derivation)

__最左推导定义__：总是选择每个句型的__最左非终结符__进行替换

* ![fig2](/images/编译原理-语法分析1/fig2.jpg)
* 如果$S \Rightarrow ^*_{lm} \alpha$，则称$\alpha$是当前文法的__最左句型(left-sentential form)__

## 1.2 最右推导(Right-most Derivation)

__最右推导定义__：总是选择每个句型的__最右非终结符__进行替换

* ![fig3](/images/编译原理-语法分析1/fig3.jpg)
* __在自底向上__的分析中，总是采用最左归约的方式，因此把最左归约称为规范归约，而最右推导相应地称为规范推导

## 1.3 最左推导和最右推导的唯一性

__最左推导和最右推导都是唯一的__

## 1.4 自顶向下的语法分析采用最左推导方式

即

* 总是选择每个句型的__最左非终结符__进行替换
* 根据输入流中的__下一个终结符__，选择最左非终结符的一个候选式

## 1.5 自顶向下语法分析的通用形式

__递归下降分析(Recursive-Descent Parsing)__

* 由一组__过程__组成，每个过程对应一个__非终结符__
* 从文法开始符号S对应的过程开始，其中递归调用文法中其它非终结符对应的过程。如果S对应的过程体恰好扫描了整个输入串，则成功完成语法分析
* __缺点：可能需要回溯(backtracking)，导致效率较低__

```C
void A() {
    选择一个A产生式，A → X1X2...Xk；
    for( i = 1 to k ) {
        if ( Xi是一个非终结符号)
            调用过程Xi();
        else if(Xi等于当前的输入符号a)
            读入下一个输入符号;
        else /*发生了一个错误*/;
    }
}
```

__预测分析(Predictive Parsing)__

* __预测分析__是__递归下降分析技术__的一个特例，通过在输入中向前看__固定个数__（通常是一个）符号来选择正确的$A-$产生式。
    * 可以对某些文法构造出向前看$k$个输入符号的预测分析器，该类文法有时也称为$LL(k)$文法类
* 预测分析__不需要回溯__，是一种__确定的__自顶向下分析方法

# 2 文法转换

## 2.1 问题1

同一非终结符的多个候选式存在__共同前缀__，将导致__回溯现象__

例如，给定文法$G$
$$
S \to aAd | aBe \\
A \to c \\
B \to b
$$

* 输入$abc$

## 2.2 问题2

__左递归文法__会使递归下降分析器__陷入无限循环__

* 如果一个文法中有一个非终结符$A$使得对某个串$\alpha$存在一个推导$A \Rightarrow ^+ A \alpha$ ，那么这个文法就是__左递归__（一步或多步）
* 含有$A \to A \alpha$形式产生式的文法称为是__直接左递归__(immediate left recursive)
* 经过两步或两步以上推导产生的左递归称为是__间接左递归__

例如，给定文法$G$
$$
E \to E+T | E-T | T \\
T \to T*F | T/F | F \\
F \to (E) | id
$$

* $id+id*id$

## 2.3 消除直接左递归

首先，以一个例子来进行说明，有如下产生式
$$A \to A \alpha | \beta (\alpha \ne \varepsilon, \beta 不以A开头)$$
在进行递归下降分析时，会产生如下循环
$$
A \Rightarrow A \alpha \\
\Rightarrow A \alpha \alpha \\
\Rightarrow A \alpha \alpha \alpha \\
... \\
\Rightarrow A \alpha ... \alpha \\
\Rightarrow \beta \alpha ... \alpha
$$
因此，与该产生式等价的正则表达式为：$r = \beta \alpha ^*$，从而可以将该产生式进行改写
$$
A \to \beta A^{\\'} \\
A^{\\'} \to \alpha A^{\\'} | \varepsilon
$$

事实上，这种消除过程就是把__左递归__转换成了__右递归__

### 2.3.1 消除直接左递归的一般形式

__一般形式如下：__

$$
A \to A \alpha_1 | A \alpha_2 | ... | A \alpha_n | \beta_1 | \beta_2 | ... | \beta_m \\
(\alpha_i \ne \varepsilon, \beta_j 不以A开头) \\
\Downarrow \\
A \to \beta_1 A^{\\'} | \beta_2 A^{\\'} | ... | \beta_m A^{\\'} \\
A^{\\'} \to \alpha_1 A^{\\'} | \alpha_2 A^{\\'} | ... | \alpha_n A^{\\'} | \varepsilon
$$

消除左递归是要付出代价的——引进了一些__非终结符__和$\varepsilon -$产生式

## 2.4 消除间接左递归

首先，以一个例子来进行说明，有如下产生式
$$
S \to Aa | b \\
A \to Ac | Sd | \varepsilon
$$
在进行递归下降分析时，会产生如下循环
$$
S \Rightarrow Aa \\
\Rightarrow Sda \\
\Rightarrow Aada \\
\Rightarrow Sdada \\
...
$$
为了消除这种间接左递归，我们将$S$的定义代入$A-$产生式，得到
$$A \to Ac | Aad | bd | \varepsilon$$
这便是$A-$的__直接左递归__，因此根据上一小节的方法进行消除，得到
$$
A \to bdA^{\\'} | A^{\\'} \\
A^{\\'} \to c A^{\\'} | ad A^{\\'} | \varepsilon
$$

## 2.5 消除左递归算法

__输入__：不含循环推导（即形如$A \Rightarrow ^+ A$的推导）和$\varepsilon -$产生式的文法$G$
__输出__：等价的无左递归文法
__方法__：

* ![fig4](/images/编译原理-语法分析1/fig4.jpg)

## 2.6 提取左公因子(Left Factoring)

通过改写产生式来__推迟决定__，等读入了足够多的输入，获得足够信息后再做出正确的选择

$$
S \to aAd | aBe \\
A \to c \\
B \to b \\
\Downarrow \\
S \to aS^{\\'} \\
S^{\\'} \to Ad | Be \\
A \to c \\
B \to b \\
$$

### 2.6.1 提取左公因子算法

__输入__：文法$G$
__输出__：等价的提取了左公因子的文法
__方法__：

* ![fig5](/images/编译原理-语法分析1/fig5.jpg)

# 3 $LL(1)$文法

## 3.1 $S\\_$文法

预测分析法的工作过程

* 从文法开始符号出发，在每一步推导过程中根据当前句型的最左非终结符$A$和当前输入符号$a$，选择正确的$A-$产生式。为保证分析的确定性，选出的候选式必须是唯一的。

__$S\\_$文法__（简单的确定性文法，Korenjak & Hopcroft，1966）

* 每个产生式的右部都以__终结符__开始
* 同一非终结符的各个候选式的__首终结符__都不同
* $S\\_$文法__不含$\varepsilon$产生式__

__什么时候可以使用$\varepsilon$产生式呢？__

* 如果当前某__非终结符__$A$与__当前输入符__$a$不匹配时，若__存在__$A \to \varepsilon$，可以通过检查$a$是否可以出现在$A$__的后面__，来决定__是否使用产生式__$A \to \varepsilon$（若文法中无$A \to \varepsilon$ ，则应报错）

## 3.2 非终结符的后继符号集

非终结符$A$的后继符号集定义：可能在某个句型中紧跟在$A$后边的__终结符__$a$的集合，记为$FOLLOW(A)$，
$$FOLLOW(A) = \{ a | S \Rightarrow^\* \alpha A a \beta, a \in V_T,\; \alpha, \beta \in (V_T \cup V_N)^\* \}$$

* 如果A是某个句型的的最右符号，则将结束符`$`添加到$FOLLOW(A)$中

例如，给定以下产生式
$$
S \to aBC \\
B \to bC \\
B \to dB \\
B \to \varepsilon \\
C \to c \\
C \to a
$$

可以推导出$FOLLOW(B)=\{ a,c \}$

因此，假设当前匹配到B

* 输入符号为$b$：选择$B \to bC$产生式
* 输入符号为$d$：选择$B \to dB$产生式
* 输入符号为$a$或$c$：选择$B \to \varepsilon$产生式

## 3.3 生产式的可选集

产生式$A \to \beta$的可选集是指可以选用该产生式进行推导时对应的输入符号的集合，记为：$$SELECT(A \to \beta)$$

* $SELECT(A \to a \beta) = \{ a \}$
* $SELECT(A \to \varepsilon) = FOLLOW(A)$

__$q\\_$文法__

* 每个产生式的右部或为$\varepsilon$，或__以终结符开始__
* 具有相同左部的产生式有__不相交的可选集__
* $q\\_$文法不含右部以__非终结符__打头的产生式

## 3.4 串首终结符集

__串首终结符__：串首第一个符号，并且是终结符。简称首终结符

给定一个文法符号串$\alpha$，$\alpha$的__串首终结符集__$FIRST(\alpha)$被定义为：可以从$\alpha$推导出的所有__串首终结符__构成的__集合__。如果$\alpha \Rightarrow^* \varepsilon$，那么$\varepsilon$也在$FIRST(\alpha)$中

* 对于$\forall \alpha \in (V_T \cup V_N)^+, FIRST(\alpha) = \{ a | \alpha \Rightarrow^\* a \beta, a \in V_T, \beta \in (V_T \cup V_N)^*   \}$
* 如果$\alpha \Rightarrow^* \varepsilon$，那么$\varepsilon \in FIRST(\alpha)$

__产生式$A \to \alpha$的可选集$SELECT$__

* 如果$\varepsilon \notin FIRST(\alpha)$，那么$SELECT(A \to \alpha) = FIRST(\alpha)$
* 如果$\varepsilon \in FIRST(\alpha)$，那么$SELECT(A \to \alpha) = ( FIRST(\alpha) - \{ \varepsilon \} ) \cup FOLLOW(A)$

## 3.5 $LL(1)$文法

文法$G$是$LL(1)$的，当且仅当$G$的任意两个具有相同左部的产生式$A \to \alpha | \beta$满足下面的条件

* 如果$\alpha$和$\beta$均不能推导出$\varepsilon$，则$FIRST(\alpha) \cap FIRST(\beta) = \Phi$
* $\alpha$和$\beta$至多有一个能推导出$\varepsilon$
    * 如果$\beta \Rightarrow^* \varepsilon$，则$FIRST(\alpha) \cap FIRST(A) = \Phi$
    * 如果$\alpha \Rightarrow^* \varepsilon$，则$FIRST(\beta) \cap FIRST(A) = \Phi$

上述规则简言之：__同一非终结符的各个产生式的可选集互不相交__

$LL(1)$含义解释

* 第一个“L”表示__从左__向右扫描输入
* 第二个“L”表示产生__最左__推导
* “1”表示在每一步中只需要向前看__一个__输入符号来决定语法分析动作

# 4 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《MOOC-编译原理-陈鄞》

