---
title: Maven-基本概念
date: 2017-11-26 22:32:21
tags: 
- 摘录
categories: 
- Java
- 包管理器
---

__目录__

<!-- toc -->
<!--more-->

# 1 坐标和依赖

## 1.1 坐标详解

Maven坐标为各种构件引入秩序，任何一个构件都必须明确定义自己的坐标，而一组Maven坐标是通过一些元素定义的，详细解释如下：

1. `groupId`：定义当前Maven项目隶属的__实际项目__
    * Maven项目和实际项目不一定是一对一的关系，例如SpringFramework这一实际项目，其对应的Maven项目会有很多，例如spring-core、spring-context等。这是由于Maven中模块的概念，因此一个实际项目往往会被划分成很多模块
    * groupId__不应该__对应项目隶属的组织或公司。因为一个组织下会有很多实际项目，如果groupId只定义到组织级别，那么artifactId将很难定义
    * groupId表示方式与Java包名的表示方式类似，通常与域名反向一一对应
1. `artifactId`：该元素定义实际项目中的一个__Maven项目（模块）__
    * 推荐的做法是使用实际项目名称作为artifactId的前缀，便于构件的寻找
1. `version`：该元素定义Maven项目__当前所处的版本__
1. `packaging`：该元素定义Maven项目的__打包方式__
    * 可选的打包方式有：`jar`、`war`、`maven-plugin`等等
    * 默认打包方式为`jar`
1. `classifier`：该元素用来帮助定义构建输出的一些附属构件
    * 不能直接定义项目的classifier，因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成的

项目构件的文件名是与坐标相对应的，一般的规则为`artifactId-version[-classifier].packaging`

## 1.2 依赖的配置

根元素`<project>`下的`<dependencies>`元素可以包含一个或多个`<dependency>`元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素详细解释如下：

1. `groupId、artifactId、version`：依赖的基本坐标，__对于任何一个依赖来说，基本坐标是最重要的__
1. `type`：依赖类型，对应于项目坐标定义的`packaging`。大部分情况下，该元素不必声明，其默认值为`jar`
1. `scope`：依赖的范围
1. `optional`：标记依赖是否可选
1. `exclusions`：用来排除传递性依赖

## 1.3 依赖范围

Maven在__编译项目主代码__的时候需要用一套classpath，在__编译和执行测试__的时候会使用另外一套classpath，在实际__运行Maven项目__的时候，又会使用一套classpath

__依赖范围就是用来控制依赖与这三种classpath（编译classpath、测试classpath、运行classpath）的关系__

1. `compile`：编译依赖范围
    * __如果没有指定，就会使用该依赖范围__
    * 使用此依赖范围的Maven依赖，对于__编译、测试、运行__三种classpath都有效
    * 典型的例子是spring-core，在编译、测试和运行的时候都需要使用该依赖
1. `test`：测试依赖范围
    * 使用此依赖范围的Maven依赖，只对于__测试__classpath有效，在编译主代码或者运行项目时将无法使用此类依赖
    * 典型的例子是JUnit，它只有在编译测试代码及运行测试的时候才需要
1. `provided`：已提供依赖范围
    * 使用此依赖范围的Maven依赖，对于__编译和测试__classpath有效，但在运行时无效
    * 典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入
1. `runtime`：运行时依赖范围
    * 使用此依赖范围的Maven依赖，对于__测试和运行__classpath有效，但在编译主代码时无效
    * 典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在实际执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动
1. `system`：系统依赖范围
    * 该依赖与三种classpath的关系，和provided依赖范围完全一致
    * 使用system范围的依赖时必须通过systemPath元素显式指定依赖文件路径
    * 由于此依赖不是通过Maven仓库解析，且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用
1. `import`：导入依赖范围
    * 该依赖范围不会对三种classpath产生实际影响

| 依赖范围（Scope） | 对于编译classpath有效 | 对于测试classpath有效  | 对于运行classpath有效  | 例子  |
|:--|:--|:--|:--|:--|
| compile | Y | Y | Y | spring-core |
| test | N | Y | N | Junit |
| provided | Y | Y | N | servlet-api |
| runtime | N | Y | Y | JDBC驱动实现 |
| system | Y | Y | N | 本地的，Maven仓库之外的类库文件 |

## 1.4 传递性依赖

Maven会解析各个直接依赖的POM，将哪些必要的间接依赖，以传递性依赖的形式引入到当前项目中

| 传递性依赖范围 | compile | test  | provided  | runtime  |
|:--|:--|:--|:--|:--|
| compile | compile | \ | \ | runtime |
| test | test | \ | \ | test |
| provided | provided | \ | provided | provided |
| runtime | runtime | \ | \ | runtime |

## 1.5 依赖调解

Maven引入的传递性依赖机制，一方面大大简化和方便了依赖声明，另一方面，大部分情况下我们只需要关心项目的直接依赖时什么，而不同考虑这些依赖会引入什么传递性依赖

但有时候，当传递性依赖造成问题的时候，我们就需要清楚地知道该传递性依赖是从哪条依赖路径引入的。例如，`A->B->C->X(1.0)`、`A->D->X(2.0)`，X是A的传递性依赖，但是两条路径上有两个版本的X，那么哪个X会被Maven解析使用呢

* Maven依赖调解的第一原则是：路径最近者优先，在上述例子中，X(1.0)的路径长度为3，而X(2.0)的路径长度为2，因此X(2.0)会被解析使用
* Maven定义了依赖调解的第二原则：第一声明者优先，即在POM中依赖声明的顺序决定了谁会被解析使用，顺序最靠前的那个依赖优胜

## 1.6 可选依赖

假设有这样一个依赖关系，项目A依赖项目B，项目B依赖项目X和Y，B对于X和Y的依赖都是可选依赖，__于是X和Y不会对A有任何影响__

* A->B
* B->X(可选)
* B->Y(可选)

为什么有这样的需求呢？可能项目B实现了两个特性，其中的特性一依赖于X，特性二依赖于Y，且这两个特性是互斥的，用户不可能同时使用两个特性。

由于可选依赖不会被传递，__因此A必须显式声明依赖X或依赖Y__

在理想情况下，是__不应该__使用可选依赖的，在面向对象设计中，有一个__单一职责性原则__，意味着一个类应该只有一项职责，而不是糅合太多的功能。__而使用可选依赖的原因是某一个项目实现了多个特性__，违背了单一职责性原则。因此应该将这个项目拆分成多个职责单一的项目，这样一来就不需要使用可选依赖了

# 2 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《代码大全》

