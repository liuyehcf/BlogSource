---
title: 操作系统内存管理详解
date: 2017-08-12 20:53:02
tags: 
- 摘录
categories: 
- 操作系统
- 内存
---

__目录__

<!-- toc -->
<!--more-->

# 1 前言

内存管理方法主要有

1. 单一式管理
1. 分区式管理
1. 页式管理
1. 段式管理
1. 段页式管理

# 2 连续分配存储管理

连续分配是指为一个用户程序分配连续的内存空间。连续分配有__单一式管理__和__分区式管理__两种方式。

## 2.1 单一式管理

在这种管理方式中，内存被分为两个区域：__系统区和用户区__。应用程序装入到用户区，可使用用户区全部空间。

其特点是，最简单，适用于单用户、单任务的操作系统。CP／M和 DOS 2．0以下就是采用此种方式。

这种方式的__最大优点就是易于管理__。但也存在着一些问题和不足之处，例如对要求内存空间少的程序，造成内存浪费

## 2.2 分区式管理

 为了支持多个程序并发执行，引入了分区式管理。__分区式管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区__。分区式管理虽然可以支持并发，但难以进行内存分区的共享。

分区式管理引人了两个新的问题：__内碎片__和__外碎片__。

1. __内碎片__是占用分区内未被利用的空间
1. __外碎片__是占用分区之间难以利用的空闲分区(通常是小空闲分区)。

为实现分区式管理，操作系统应维护的数据结构为分区表或分区链表。__表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)__。

分区式管理常采用的一项技术就是内存紧缩(compaction)。

分区式管理按照分区的大小策略又可细分为__固定分区__和__动态分区__两种

### 2.2.1 固定分区

固定式分区的特点是把内存划分为若干个固定大小的连续分区。

* 分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。
* 分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。

__优点__：易于实现，开销小。
      
__缺点__：

1. 内碎片造成浪费
1. 分区总数固定，限制了并发执行的程序数目。

### 2.2.2 动态分区

动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。

__与固定分区相比较其优点是：没有内碎片。但它却引入了另一种碎片——外碎片__。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为"占用"，而另一个分区为余下部分并标记为"空闲"。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。

下面列出了几种常用的分区分配算法：

1. __最先适配法(nrst-fit)__：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。
1. __下次适配法(循环首次适应算法 next fit)__：按分区在内存的先后次序，从上次分配的分区起查找(到最后，再从头开始)，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。
1. __最佳适配法(best-fit)__：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。
1. __最坏适配法(worst- fit)__：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。

## 2.3 伙伴系统

固定分区和动态分区方式都有不足之处。固定分区方式限制了活动进程的数目，当进程大小与空闲分区大小不匹配时，内存空间利用率很低。动态分区方式算法复杂，回收空闲分区时需要进行分区合并等，系统开销较大。伙伴系统方式是对以上两种内存方式的一种折衷方案。

伙伴系统规定，无论已分配分区或空闲分区，其大小均为2的k次幂，k为整数，`l≤k≤m`，其中：

* `2^l`表示分配的最小分区的大小
* `2^m`表示分配的最大分区的大小，通常`2^m`是整个可分配内存的大小。

假设系统的可利用空间容量为`2^m`，则系统开始运行时，整个内存区是一个大小为`2^m`的空闲分区。在系统运行过中，由于不断的划分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了数个`(m-l+1)`空闲分区链表。

__当需要为进程分配一个长度为n的存储空间时，分配步骤如下__：

1. 首先计算一个i值，使`2^(i－1) <n ≤ 2^i`
1. 然后在空闲分区大小为2^i的空闲分区链表中查找。若找到，即把该空闲分区分配给进程。
1. 否则，表明长度为`2^i`的空闲分区已经耗尽，则在分区大小为`2^(i＋1)`的空闲分区链表中寻找。若存在`2^(i＋1)`的一个空闲分区，则把该空闲分区分为相等的两个分区，__这两个分区称为一对伙伴__，其中的一个分区用于配，而把另一个加入分区大小为`2^i`的空闲分区链表中。
1. 否则，表明大小为`2^(i＋1)`的空闲分区也不存在，则需要查找大小为`2^(i＋2)`的空闲分区，若找到则对其进行两次分割：
    * 第一次，将其分割为大小为`2^(i＋1)`的两个分区，一个用于分配，一个加入到大小为`2^(i＋1)`的空闲分区链表中；
    * 第二次，将第一次用于分配的空闲区分割为`2^i`的两个分区，一个用于分配，一个加入到大小为`2^i`的空闲分区链表中。
1. 否则，表明大小为`2^(i＋2)`的空闲分区也不存在，则继续查找大小为2^(i＋3)的空闲分区，以此类推。

由此可见，在最坏的情况下，可能需要对`2^k`的空闲分区进行`k`次分割才能得到所需分区。

与一次分配可能要进行多次分割一样，一次回收也可能要进行多次合并，如回收大小为`2^i`的空闲分区时，若事先已存在`2^i`的空闲分区时，则应将其与伙伴分区合并为大小为`2^(i＋1)`的空闲分区，若事先已存在`2^(i＋1)`的空闲分区时，又应继续与其伙伴分区合并为大小为`2^(i＋2)`的空闲分区，依此类推。

__在伙伴系统中，其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间__。与前面所述的多种方法相比较，由于该算法在回收空闲分区时，需要对空闲分区进行合并，所以其时间性能比前面所述的分类搜索算法差，但比顺序搜索算法好，而其空间性能则远优于前面所述的分类搜索法，比顺序搜索法略差。需要指出的是，在当前的操作系统中，普遍采用的是下面将要讲述的基于分页和分段机制的虚拟内存机制，该机制较伙伴算法更为合理和高效，但在多处理机系统中，伙伴系统仍不失为一种有效的内存分配和释放的方法，得到了大量的应用。

## 2.4 内存紧缩

内存紧缩：将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区。

这种技术在提供了某种程度上的灵活性的同时，也存在着一些弊端，例如：对占用分区进行内存数据搬移占用CPU时间；如果对占用分区中的程序进行"浮动"，则其重定位需要硬件支持。

__紧缩时机__：每个分区释放后，或内存分配找不到满足条件的空闲分区时。

### 2.4.1 堆结构的存储管理的分配算法

在动态存储过程中，不管哪个时刻，可利用空间都是__一个地址连续的存储区__，在编译程序中称之为"堆"，每次分配都是从这个可利用空间中划出一块。其实现办法是：设立一个指针，称之为堆指针，始终指向堆的最低地址。当用户申请N个单位的存储块时，堆指针向高地址移动N个存储单位，而移动之前的堆指针的值就是分配给用户的占用块的初始地址。例如，某个串处理系统中有A、B、C、D这4个串，其串值长度分别為12，6，10和8。假设堆指针free的初值为零，则分配给这4个串值的存储空间的初始地址分别为0，12，18和28，分配后的堆指针的值为36。因此，这种堆结构的存储管理的分配算法非常简单

### 2.4.2 释放内存空间执行内存紧缩

## 2.5 覆盖和交换技术

# 3 页式管理

# 4 段式管理

# 5 段页式管理

# 6 参考

* [操作系统内存管理——分区、页式、段式管理](http://blog.csdn.net/hguisu/article/details/5713164)
* [内存管理页式管理和段式管理、段页式管理的区别](https://zhidao.baidu.com/question/80156407.html)
