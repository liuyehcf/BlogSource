---
title: 分布式事务
date: 2017-07-14 21:20:24
tags: 
- 摘录
categories: 
- 分布式
- 基本概念
---

__目录__

<!-- toc -->
<!--more-->

# 1 基于事务消息的分布式事务

## 1.1 场景

说到分布式事务，就会谈到那个经典的”账号转账”问题：2个账号，分布处于2个不同的DB，或者说2个不同的子系统里面，A要扣钱，B要加钱，如何保证原子性？

一般的思路都是__通过消息中间件来实现“最终一致性”：__A系统扣钱，然后发条消息给中间件，B系统接收此消息，进行加钱

但这里面有个问题：A是先update DB，后发送消息呢？还是先发送消息，后update DB？

假设先update DB成功，发送消息网络失败，重发又失败，怎么办？
假设先发送消息成功，update DB失败。消息已经发出去了，又不能撤回，怎么办？

所以，这里下个结论：只要发送消息和update DB这2个操作不是原子的，无论谁先谁后，都是有问题的

那这个问题怎么解决呢？？

## 1.2 错误的方案0

有人可能想到了，我可以把“发送消息”这个网络调用和update DB放在同1个事务里面，如果发送消息失败，update DB自动回滚。这样不就保证2个操作的原子性了吗？

这个方案看似正确，其实是错误的，原因有2：

1. 网络的2将军问题：发送消息失败，发送方并不知道是消息中间件真的没有收到消息呢？还是消息已经收到了，只是返回response的时候失败了？
    * 如果是已经收到消息了，而发送端认为没有收到，执行update db的回滚操作。则会导致A账号的钱没有扣，B账号的钱却加了
1. 把网络调用放在DB事务里面，可能会因为网络的延时，导致DB长事务。严重的，会block整个DB。这个风险很大

基于以上分析，我们知道，这个方案其实是错误的！

## 1.3 方案1–业务方自己实现

假设消息中间件没有提供“事务消息”功能，比如你用的是Kafka。那如何解决这个问题呢？

解决方案如下：

1. Producer端准备1张消息表，把update DB和insert message这2个操作，放在一个DB事务里面
1. 准备一个后台程序，源源不断的把消息表中的message传送给消息中间件。失败了，不断重试重传。允许消息重复，但消息不会丢，顺序也不会打乱
1. Consumer端准备一个判重表。处理过的消息，记在判重表里面。实现业务的幂等。但这里又涉及一个原子性问题：如果保证消息消费 + insert message到判重表这2个操作的原子性？

消费成功，但insert判重表失败，怎么办？关于这个，在Kafka的源码分析系列，第1篇， exactly once问题的时候，有过讨论

通过上面3步，我们基本就解决了这里update db和发送网络消息这2个操作的原子性问题

但这个方案的一个缺点就是：需要设计DB消息表，同时还需要一个后台任务，不断扫描本地消息。导致消息的处理和业务逻辑耦合额外增加业务方的负担

## 1.4 方案2 – RocketMQ 事务消息

为了能解决该问题，同时又不和业务耦合，RocketMQ提出了“事务消息”的概念

具体来说，就是把消息的发送分成了2个阶段：Prepare阶段和确认阶段

具体来说，上面的2个步骤，被分解成3个步骤：

1. 发送Prepared消息
1. update DB 
1. 根据update DB结果成功或失败，Confirm或者取消Prepared消息

可能有人会问了，前2步执行成功了，最后1步失败了怎么办？这里就涉及到了RocketMQ的关键点：RocketMQ会定期（默认是1分钟）扫描所有的Prepared消息，询问发送方，到底是要确认这条消息发出去？还是取消此条消息？

具体代码实现如下：

也就是定义了一个checkListener，RocketMQ会回调此Listener，从而实现上面所说的方案

```Java
// 也就是上文所说的，当RocketMQ发现`Prepared消息`时，会根据这个Listener实现的策略来决断事务
TransactionCheckListener transactionCheckListener = new TransactionCheckListenerImpl();
// 构造事务消息的生产者
TransactionMQProducer producer = new TransactionMQProducer("groupName");
// 设置事务决断处理类
producer.setTransactionCheckListener(transactionCheckListener);
// 本地事务的处理逻辑，相当于示例中检查Bob账户并扣钱的逻辑
TransactionExecuterImpl tranExecuter = new TransactionExecuterImpl();
producer.start()
// 构造MSG，省略构造参数
Message msg = new Message(......);
// 发送消息
SendResult sendResult = producer.sendMessageInTransaction(msg, tranExecuter, null);
producer.shutdown();
```

```Java
public TransactionSendResult sendMessageInTransaction(.....)  {
    // 逻辑代码，非实际代码
    // 1.发送消息
    sendResult = this.send(msg);
    // sendResult.getSendStatus() == SEND_OK
    // 2.如果消息发送成功，处理与消息关联的本地事务单元
    LocalTransactionState localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);
    // 3.结束事务
    this.endTransaction(sendResult, localTransactionState, localException);
}
```

总结：对比方案2和方案1，RocketMQ最大的改变，其实就是把“扫描消息表”这个事情，不让业务方做，而是消息中间件帮着做了

至于消息表，其实还是没有省掉。因为消息中间件要询问发送方，事物是否执行成功，还是需要一个“变相的本地消息表”，记录事物执行状态

## 1.5 人工介入

可能有人又要说了，无论方案1，还是方案2，发送端把消息成功放入了队列，但消费端消费失败怎么办？

消费失败了，重试，还一直失败怎么办？是不是要自动回滚整个流程？

答案是人工介入。从工程实践角度讲，这种整个流程自动回滚的代价是非常巨大的，不但实现复杂，还会引入新的问题。比如自动回滚失败，又怎么处理？

对应这种极低概率的case，采取人工处理，会比实现一个高复杂的自动化回滚系统，更加可靠，也更加简单

# 2 分布式事务杂谈

事务就是一个会话过程中，对上下文的影响是一致的，要么所有的更改都做了，要么所有的更变都撤销掉。要么生，要么死。没有半死不死的中间不可预期状态

__事务是为了保障业务数据的完整性和准确性的。__

__分布式事务，常见的两个处理办法就是两段式提交和补偿。__

* 两段式提交典型的就是XA，有个事务协调器，告诉大家，来都准备好提交，大家回复，都准备好了，然后协调器告诉大家，一起提交，大家都提交了
* 补偿比较好理解，先处理业务，然后定时或者在回调方法里，检查状态是不是一致的。如果不一致就采用某个策略，强制状态到某个结束状态（一般是失败状态），然后就世界太平了。典型的就是冲正操作

__问题 1：比如 一个业务要调用很多的服务都是写操作，如果有其中一个写的服务失败了，怎么办？假设有4个写操作吧，其中有2个写失败了。__

> 淘宝之类的网站一般的做法是：如果4个都成功才算成功，那么这次提交时4个写都设置成一个中间状态，先容许不一致。然后4个写操作执行完成了以后，执行回调方法或是定时任务里检查这4个数据是不是一致的，如果一致就全部置为成功状态，如果不一致就全部置为失败

> 复杂的业务交互过程中，不建议使用强一致性的分布式事务。__解决分布式事务的最好办法就是不考虑分布式事务。__就像刚说的问题一样，把分布式的事务过程拆解成多个中间状态，中间状态的东西不允许用户直接操作，等状态都一致成功，或者检测到不一致的时候全部失败掉。就解耦了这个强一致性的过程

> 一般情况下准实时就成了。涉及到钱，有时候也可以这么搞。淘宝几秒内完成一个订单处理，不是什么问题吧。银行也不一定满足强一致性。也会扎差，也会冲正。特别是涉及到多个系统的时候，比如买机票，支付完成以后，只是支付完成状态，然后返回给用户了，我们过几分钟再刷新页面，才会看到变成已出票，订单完成状态。这个时候，如果我们要求所有处理，都是强一致性的，那么就完蛋了。页面要死在那儿几分钟，才把这个事务处理完成，返回给用户

> 这样就肯定涉及一个问题：支付了，但是最终没有出票。那就没办法，商量换票或退款。淘宝的订单改成出票失败，给支付发消息通知退款。慢的时候，有可能是手工出票，这时出一张票半小时都可能，如果要求都必须强一致性的话，所有处理线程都挂在哪儿，系统早就完蛋了

> __解决分布式事务的最好办法就是不考虑分布式事务。__拆分大的业务流程，转化成几个小的业务流程，然后考虑最终一致性

__问题2：分布式事务是你们自己开发的，还是数据库自带的？__

> 1. 只要一个处理逻辑能保证要么成功，要么跟什么也没做一样，都算是事务。数据库事务，MQ也有事务。你自己甚至可以写个程序生成两个文件，要么都生成了，要么都删掉不留痕迹，这也算是事务
> 1. 分布式事务这一块有个XA规范，实现XA接口的事务，都可以加入到一个分布式事务中，被XA容器管理起来
> 1. 补偿的办法，需要具体情况具体分析，没有一个各种场合都适用的框架

# 3 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf#163.com，#替换成@)，博主将在第一时间删除__

* [分布式系统事务一致性解决方案](http://www.cnblogs.com/dinglang/p/5679542.html)
* [分布式消息队列RocketMQ--事务消息--解决分布式事务的最佳实践](http://blog.csdn.net/chunlongyu/article/details/53844393)
* [聊聊分布式事务](http://blog.csdn.net/kimmking/article/details/43197665)
