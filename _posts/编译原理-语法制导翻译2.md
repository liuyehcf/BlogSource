---
title: 编译原理-语法制导翻译2
date: 2017-11-07 10:02:00
mathjax: true
tags: 
- 摘录
categories: 
- Compile Principle
---

**阅读更多**

<!--more-->

# 1 语法制导翻译方案SDT

**语法制导翻译方案(SDT)**是在**产生式右部**中嵌入了**程序片段**(称为**语义动作**)的CFG

![fig1](/images/编译原理-语法制导翻译2/fig1.jpg)

SDT可以看作是SDD的具体实施方案

本节主要关注如何使用SDT来实现两类重要的SDD，因为在这两种情况下，SDT可在语法分析过程中实现

* 基本文法可以使用LR分析技术，且SDD是S属性的
* 基本文法可以使用LL分析技术，且SDD是L属性的

## 1.1 将S-SDD转换为SDT

将一个S-SDD转换为SDT的方法：将每个语义动作都放在产生式的最后

![fig2](/images/编译原理-语法制导翻译2/fig2.jpg)

## 1.2 S-属性定义的SDT实现

**如果一个S-SDD的基本文法可以使用LR分析技术，那么它的SDT可以在LR语法分析过程中实现**

* **当归约发生时执行相应的语义动作**

![fig3](/images/编译原理-语法制导翻译2/fig3.jpg)

## 1.3 扩展的LR语法分析栈

在分析栈中使用一个附加的域来存放**综合属性值**。若支持多个属性，那么可以在栈中存放指针

此时，分析栈可以看成一个栈，栈元素包含`状态`、`文法符号`、`综合属性`三个域；分析栈也可以看成三个栈，分别是`状态栈`、`文法符号栈`、`综合属性栈`，分开看的理由是，入栈出栈并不完全同步

## 1.4 将语义动作中的抽象定义式改写成具体可执行的栈操作

即将语义翻译成相应的栈操作

![fig4](/images/编译原理-语法制导翻译2/fig4.jpg)

## 1.5 例：在自底向上语法分析栈中实现桌面计算器

桌面计算器的SDD定义如下：

![fig5](/images/编译原理-语法制导翻译2/fig5.jpg)

对应的SLR自动机如下：

![fig6](/images/编译原理-语法制导翻译2/fig6.jpg)

**语法制导过程如下：**

{% raw %}$$
状态栈：0 \\
符号栈：\$ \\
属性栈：\_ \\
剩余输入符号：3\ast 5+4\$ \\
\Downarrow \\
输入符号d，其属性值为3 \\
状态栈：0 \\
符号栈：\$,d \\
属性栈：\_,3 \\
剩余输入符号：\ast 5+4\$ \\
\Downarrow \\
查表[0, d] = 5，状态5进状态栈 \\
状态栈：0,5 \\
符号栈：\$,d \\
属性栈：\_,3 \\
剩余输入符号：\ast 5+4\$ \\
\Downarrow \\
状态5遇到输入符号\ast时，根据第7个产生式进行归约，状态栈和符号栈出栈，属性栈不变，并压入归约后的符号F \\
状态栈：0 \\
符号栈：\$,F \\
属性栈：\_,3 \\
剩余输入符号：\ast 5+4\$ \\
\Downarrow \\
查表[0, F] = 3，状态3进栈 \\
状态栈：0,3 \\
符号栈：\$,F \\
属性栈：\_,3 \\
剩余输入符号：\ast 5+4\$ \\
\Downarrow \\
状态3遇到输入符号\ast时，根据第5个产生式进行归约，状态栈和符号栈出栈，属性栈不变，并压入归约后的符号T \\
状态栈：0 \\
符号栈：\$,T \\
属性栈：\_,3 \\
剩余输入符号：\ast 5+4\$ \\
\Downarrow \\
查表[0, T] = 2，状态2进栈 \\
状态栈：0,2 \\
符号栈：\$,T \\
属性栈：\_,3 \\
剩余输入符号：\ast 5+4\$ \\
\Downarrow \\
输入符号\ast，没有属性值 \\
状态栈：0,2 \\
符号栈：\$,T,\ast \\
属性栈：\_,3,\_ \\
剩余输入符号：5+4\$ \\
\Downarrow \\
查表[2, \ast] = 7，状态7进栈 \\
状态栈：0,2,7 \\
符号栈：\$,T,\ast \\
属性栈：\_,3,\_ \\
剩余输入符号：5+4\$ \\
\Downarrow \\
输入符号d，其属性值为5
状态栈：0,2,7 \\
符号栈：\$,T,\ast,d \\
属性栈：\_,3,\_,5 \\
剩余输入符号：+4\$ \\
\Downarrow \\
查表[7, d] = 5，状态5进栈 \\
状态栈：0,2,7,5 \\
符号栈：\$,T,\ast,d \\
属性栈：\_,3,\_,5 \\
剩余输入符号：+4\$ \\
\Downarrow \\
状态5遇到输入符号+时，根据第7个产生式进行归约，状态栈和符号栈出栈，属性栈不变，并压入归约后的符号F \\
状态栈：0,2,7 \\
符号栈：\$,T,\ast,F \\
属性栈：\_,3,\_,5 \\
剩余输入符号：+4\$ \\
\Downarrow \\
查表[7, F] = 10，状态10进栈 \\
状态栈：0,2,7,10 \\
符号栈：\$,T,\ast,F \\
属性栈：\_,3,\_,5 \\
剩余输入符号：+4\$ \\
\Downarrow \\
状态10遇到输入符号+时，根据第4个产生式进行归约，状态栈和符号栈出栈，属性栈根据该产生式进行相应操作，并压入归约后的符号T \\
状态栈：0 \\
符号栈：\$,T \\
属性栈：\_,15 \\
剩余输入符号：+4\$ \\
\Downarrow \\
查表[0, T] = 2，状态2进栈 \\
状态栈：0,2 \\
符号栈：\$,T \\
属性栈：\_,15 \\
剩余输入符号：+4\$ \\
\Downarrow \\
状态2遇到输入符号+时，根据第3个产生式进行归约，状态栈和符号栈出栈，属性栈不变，并压入归约后的符号E \\
状态栈：0 \\
符号栈：\$,E \\
属性栈：\_,15 \\
剩余输入符号：+4\$ \\
\Downarrow \\
查表[0, E] = 1，状态1进栈 \\
状态栈：0,1 \\
符号栈：\$,E \\
属性栈：\_,15 \\
剩余输入符号：+4\$ \\
\Downarrow \\
输入符号+，没有属性值 \\
状态栈：0,1 \\
符号栈：\$,E,+ \\
属性栈：\_,15,\_ \\
剩余输入符号：4\$ \\
\Downarrow \\
查表[1, +] = 6，状态6进栈 \\
状态栈：0,1,6 \\
符号栈：\$,E,+ \\
属性栈：\_,15,\_ \\
剩余输入符号：4\$ \\
\Downarrow \\
输入符号d，其属性值为4 \\
状态栈：0,1,6 \\
符号栈：\$,E,+,d \\
属性栈：\_,15,\_,4 \\
剩余输入符号：\$ \\
\Downarrow \\
查表[6, d] = 5，状态5进栈 \\
状态栈：0,1,6,5 \\
符号栈：\$,E,+,d \\
属性栈：\_,15,\_,4 \\
剩余输入符号：\$ \\
\Downarrow \\
状态5遇到输入符号\$时，根据第7个产生式进行归约，状态栈和符号栈出栈，属性栈不变，并压入归约后的符号F \\
状态栈：0,1,6 \\
符号栈：\$,E,+,F \\
属性栈：\_,15,\_,4 \\
剩余输入符号：\$ \\
\Downarrow \\
查表[6, F] = 4，状态3进栈 \\
状态栈：0,1,6,3 \\
符号栈：\$,E,+,F \\
属性栈：\_,15,\_,4 \\
剩余输入符号：\$ \\
\Downarrow \\
状态3遇到输入符号\$时，根据第5个产生式进行归约，状态栈和符号栈出栈，属性栈不变，并压入归约后的符号T \\
状态栈：0,1,6 \\
符号栈：\$,E,+,T \\
属性栈：\_,15,\_,4 \\
剩余输入符号：\$ \\
\Downarrow \\
查表[6, T] = 9，状态9进栈 \\
状态栈：0,1,6,9 \\
符号栈：\$,E,+,T \\
属性栈：\_,15,\_,4 \\
剩余输入符号：\$ \\
\Downarrow \\
状态9遇到输入符号\$时，根据第2个产生式进行归约，状态栈和符号栈出栈，属性栈根据该产生式进行相应操作，并压入归约后的符号E \\
状态栈：0 \\
符号栈：\$,E \\
属性栈：\_,19 \\
剩余输入符号：\$ \\
查表[0, E] = 1，状态1进栈 \\
状态栈：0,1 \\
符号栈：\$,E \\
属性栈：\_,19 \\
剩余输入符号：\$ \\
状态1遇到\$时，成功接收
$${% endraw %}

## 1.6 将L-SDD转换为SDT

将L-SDD转换为SDT的规则

* 将计算某个非终结符号A的**继承属性**的动作插入到产生式右部中**紧靠在A的本次出现之前**的位置上
* 将计算一个产生式左部符号的**综合属性**的动作放置在这个产生式右部的**最右端**

![fig7](/images/编译原理-语法制导翻译2/fig7.jpg)

## 1.7 L-属性定义的SDT实现

如果一个L-SDD的基本文法可以使用LL分析技术，那么它的SDT可以在LL或LR语法分析过程中实现

* 在非递归的预测分析过程中进行语义翻译
* 在递归的预测分析过程中进行语义翻译
* 在LR分析过程中进行语义翻译

# 2 在非递归的预测分析过程中进行翻译

## 2.1 扩展语法分析栈

此时语法分析栈中包含三种类型的元素

1. {% raw %}$action${% endraw %}：用于放置指向将被执行的语义动作代码的指针
1. {% raw %}$A${% endraw %}：用于放置{% raw %}$A${% endraw %}的继承属性（继承属性与非终结符放在一起）
1. {% raw %}$Asyn${% endraw %}：用于放置{% raw %}$A${% endraw %}的综合属性（综合属性与非终结符分开存放）

## 2.2 分析过程详解

SDD定义如下

![fig8](/images/编译原理-语法制导翻译2/fig8.jpg)

**输入符号：`3 * 5`**

* 初始时，仅有非终结符{% raw %}$T${% endraw %}，且带有综合属性

![fig9](/images/编译原理-语法制导翻译2/fig9.jpg)

* 输入指针指向输入符号3，根据产生式1替换栈顶元素{% raw %}$T${% endraw %}
    * 弹出栈顶元素{% raw %}$T${% endraw %}
    * 其中{% raw %}$F${% endraw %}和{% raw %}$T^{\prime}${% endraw %}分别带有综合属性，因此总共入栈元素共有6项

![fig10](/images/编译原理-语法制导翻译2/fig10.jpg)

* 输入指针指向输入符号3，根据产生式4替换栈顶元素{% raw %}$F${% endraw %}

![fig11](/images/编译原理-语法制导翻译2/fig11.jpg)

* 输入指针指向输入符号3，与栈顶元素{% raw %}$digit${% endraw %}匹配成功，输入指针向前移动一位
* {% raw %}$digit${% endraw %}元素出栈，在{% raw %}$digit${% endraw %}元素出栈之前，需要将结果保存在{% raw %}$\{ a_6 \}${% endraw %}中（因为{% raw %}$a_6${% endraw %}定义的操作需要用到该{% raw %}$digit${% endraw %}元素的值）
* 根据{% raw %}$a_6${% endraw %}定义的操作，计算{% raw %}$F${% endraw %}的综合属性（保存在{% raw %}$Fsyn${% endraw %}中），然后动作属性{% raw %}$\{ a_6 \}${% endraw %}出栈
* {% raw %}$Fsyn${% endraw %}元素出栈，在{% raw %}$Fsyn${% endraw %}元素出栈之前，需要将结果保存在{% raw %}$\{ a_1 \}${% endraw %}中（因为{% raw %}$a_1${% endraw %}定义的操作需要用到{% raw %}$Fsyn${% endraw %}的值）
* 根据{% raw %}$a_1${% endraw %}定义的操作，计算{% raw %}$T^{\prime}${% endraw %}的继承属性（保存在{% raw %}$T^{\prime}${% endraw %}中），然后动作属性{% raw %}$\{ a_1 \}${% endraw %}出栈

![fig12](/images/编译原理-语法制导翻译2/fig12.jpg)

* 输入指针指向输入符号*，根据产生式2替换栈顶元素{% raw %}$T^{\prime}${% endraw %}，由于{% raw %}$T_1^{\prime}${% endraw %}的继承属性依赖{% raw %}$T^{\prime}${% endraw %}的继承属性，因此在{% raw %}$T^{\prime}${% endraw %}元素出栈之前，要将{% raw %}$T^{\prime}${% endraw %}的继承属性保存到{% raw %}$\{ a_3 \}${% endraw %}中

![fig13](/images/编译原理-语法制导翻译2/fig13.jpg)

* 输入指针指向输入符号\*，与栈顶元素\*匹配成功，输入指针先前移动一位，栈顶元素出栈
* 输入指针指向输入符号5，根据产生式4替换栈顶元素{% raw %}$F${% endraw %}
* 输入指针指向输入符号5，与栈顶元素{% raw %}$digit${% endraw %}匹配成功，输入指针向前移动一位
* {% raw %}$digit${% endraw %}元素出栈，在{% raw %}$digit${% endraw %}元素出栈之前，需要将结果保存在{% raw %}$\{ a_6 \}${% endraw %}中（因为{% raw %}$a_6${% endraw %}定义的操作需要用到该{% raw %}$digit${% endraw %}元素的值）
* 根据{% raw %}$a_6${% endraw %}定义的操作，计算{% raw %}$F${% endraw %}的综合属性（保存在{% raw %}$Fsyn${% endraw %}中），然后动作属性{% raw %}$\{ a_6 \}${% endraw %}出栈

![fig14](/images/编译原理-语法制导翻译2/fig14.jpg)

* {% raw %}$Fsyn${% endraw %}元素出栈，在{% raw %}$Fsyn${% endraw %}元素出栈之前，需要将结果保存在{% raw %}$\{ a_3 \}${% endraw %}（因为{% raw %}$a_3${% endraw %}定义的操作需要用到该{% raw %}$Fsyn${% endraw %}元素的值）
* 执行{% raw %}$a_3${% endraw %}定义的操作，计算{% raw %}$T_1^{\prime}${% endraw %}的继承属性（保存在{% raw %}$T_1^{\prime}${% endraw %}中），然后动作属性{% raw %}$\{ a_3 \}${% endraw %}出栈
* 输入指针指向输入符号{% raw %}$\$${% endraw %}，根据产生式3替换栈顶元素{% raw %}$T_1^{\prime}${% endraw %}，且将{% raw %}$T_1^{\prime}${% endraw %}的值保存在{% raw %}$\{ a_5 \}${% endraw %}中（因为{% raw %}$a_5${% endraw %}定义的操作需要用到该{% raw %}$T_1^{\prime}${% endraw %}元素的值）

![fig15](/images/编译原理-语法制导翻译2/fig15.jpg)

* 执行{% raw %}$a_5${% endraw %}定义的操作，计算{% raw %}$T_1^{\prime}${% endraw %}的综合属性（保存在{% raw %}$T_1^{\prime}syn${% endraw %}中），然后动作属性{% raw %}$\{ a_5 \}${% endraw %}出栈
* {% raw %}$T_1^{\prime}syn${% endraw %}元素出栈，在{% raw %}$T_1^{\prime}syn${% endraw %}元素出栈之前，将其保存在{% raw %}$\{ a_4 \}${% endraw %}中（因为{% raw %}$a_4${% endraw %}定义的操作需要用到该{% raw %}$T_1^{\prime}syn${% endraw %}元素的值）

![fig16](/images/编译原理-语法制导翻译2/fig16.jpg)

* 执行{% raw %}$a_4${% endraw %}定义的操作，计算{% raw %}$T^{\prime}${% endraw %}的综合属性（保存在{% raw %}$T^{\prime}syn${% endraw %}中），然后动作属性{% raw %}$\{ a_4 \}${% endraw %}出栈
* {% raw %}$T^{\prime}syn${% endraw %}元素出栈，在{% raw %}$T^{\prime}syn${% endraw %}元素出栈之前，将其保存在{% raw %}$\{ a_2 \}${% endraw %}中（因为{% raw %}$a_2${% endraw %}定义的操作需要用到该{% raw %}$T^{\prime}syn${% endraw %}元素的值）

![fig17](/images/编译原理-语法制导翻译2/fig17.jpg)

* 执行{% raw %}$a_2${% endraw %}定义的操作，计算文法开始符号{% raw %}$T${% endraw %}的综合属性值（保存在{% raw %}$Tsyn${% endraw %}中），然后动作属性{% raw %}$\{ a_2 \}${% endraw %}出栈

![fig18](/images/编译原理-语法制导翻译2/fig18.jpg)

## 2.3 分析栈中的每一个记录都对应着一段执行代码

**综合记录出栈时，要将综合属性值复制给后面特定的语义动作**

**变量展开时（即变量本身的记录出栈时），如果其含有继承属性，则要将继承属性值复制给后面特定的语义动作**

![fig19](/images/编译原理-语法制导翻译2/fig19.jpg)

![fig20](/images/编译原理-语法制导翻译2/fig20.jpg)

![fig21](/images/编译原理-语法制导翻译2/fig21.jpg)

![fig22](/images/编译原理-语法制导翻译2/fig22.jpg)

# 3 参考

* 《MOOC-编译原理-陈鄞》
