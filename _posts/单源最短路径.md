---
title: 单源最短路径
date: 2017-08-04 22:16:36
tags: 
- 原创
categories: 
- 算法
- 图算法
---

__目录__

<!-- toc -->
<!--more-->

# 1 Dijkstra

Dijkstra 算法（中文名：迪杰斯特拉算法）是由荷兰计算机科学家 Edsger Wybe Dijkstra 提出。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。

__注意该算法要求图中不存在负权边。__

## 1.1 算法描述

设`G=(V,E)`是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径，就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了）；第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。

此外，每个顶点i对应一个距离D(i)

* S中的顶点的距离就是从v到此顶点的最短路径长度
* U中的顶点的距离，__是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度__。即迭代过程中的当前时刻的最短路径，之后可能会被更新

## 1.2 流程

为了方便理解，给出以下流程图

```flow
st=>start: 开始
op1=>operation: 将源节点v加入S集合，
并初始化D
op2=>operation: 从集合U中找到D(i∈U)
最小的顶点i，将其从集
合U中删除，并添加到集
合S中
op3=>operation: 更新集合U中顶点j的距离，
D(j)=min(D(j),D(i)+path(i,j))
cond1=>condition: 集合U为空?
en=>end: 结束

st->op1
op1->op2
op2->op3
op3->cond1
cond1(yes)->en
cond1(no)->op2
```

## 1.3 Java源码

对应[HihoCode第1081题](https://hihocoder.com/problemset/problem/1081)。可自行验证正确性

```Java
package org.liuyehcf.graph;

import java.util.Arrays;
import java.util.Scanner;

/**
 * Created by t-chehe on 8/5/2017.
 */
public class Dijkstra {
    private static final int CANNOT_REACH = Integer.MAX_VALUE;

    public static void main(String[] args) {
        int N, M, S, T;

        Scanner scanner = new Scanner(System.in);

        N = scanner.nextInt();
        M = scanner.nextInt();
        S = scanner.nextInt();
        T = scanner.nextInt();

        int[][] path = new int[N + 1][N + 1];

        for (int i = 1; i <= N; i++) {
            Arrays.fill(path[i], CANNOT_REACH);
        }

        while (--M >= 0) {
            int source = scanner.nextInt();
            int dest = scanner.nextInt();
            int length = scanner.nextInt();

            if (length < path[source][dest]) {
                path[source][dest] = length;
                path[dest][source] = length;
            }
        }

        System.out.println(minPath(path, N, S, T));
    }

    public static int minPath(int[][] path, int num, int source, int dest) {
        // visited将节点集合分为两部分，true代表已访问（记为集合S），false代表未访问(记为集合U)
        boolean[] visited = new boolean[num + 1];

        int[] distance = new int[num + 1];

        for (int i = 1; i <= num; i++) {
            distance[i] = path[source][i];
        }

        distance[source] = 0;

        for (int i = 2; i <= num; i++) {
            int minLength = CANNOT_REACH;
            int nextNode = -1;

            // 在所有未访问的节点中找到距离source最近的节点
            for (int j = 1; j <= num; j++) {
                if (!visited[j]
                        && distance[j] < minLength) {
                    nextNode = j;
                    minLength = distance[j];
                }
            }

            visited[nextNode] = true;

            // 如果source与j(j在集合U中)可以通过节点nextNode相连，那么更新source与j的距离
            for (int j = 1; j <= num; j++) {
                if (!visited[j]
                        && isConnected(path, nextNode, j)
                        && distance[nextNode] + path[nextNode][j] < distance[j]) {
                    distance[j] = distance[nextNode] + path[nextNode][j];
                }
            }
        }

        return distance[dest];
    }

    private static boolean isConnected(int[][] path, int source, int dest) {
        return path[source][dest] != CANNOT_REACH;
    }
}
```

# 2 Floyd-Warshall

Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。

## 2.1 算法描述

Floyd-Warshall算法本质上来说就是动态规划，我们首先从子问题的设计入手。令`F[k][i][j]`代表仅包含前k个节点作为中间节点的情况下，节点i到节点j的最短距离。

于是我们可以给出递推表达式：`F[k][i][j] = min(F[k-1][i][j], F[k-1][i][k] + F[k-1][k][j])`。其中`F[k-1][i][j]`代表当__不选取第k个节点作为中间节点__时的最短距离；`F[k-1][i][k] + F[k-1][k][j]`代表__选取第k个节点作为中间节点__时的最短距离。

### 2.1.1 空间降维

__可以看出F[k][i][j]仅仅与F[k-1][?][?]有关，于是空间复杂度可以从O(N3)降低为O(N2)__，此时递推表达式变为`F[i][j] = min(F[i][j], F[i][k] + F[k][j])`

__注意，最好对i和j降序遍历，否则可能得到错误的结果__(对于Floyd算法，升序遍历可能得到正确的结果，但是对于其他DP问题，例如0-1背包问题就可能得到错误的结果)。因为`F[i][j]`依赖于`F[i][k]`和`F[k][j]`，因此必须保证在计算过程k的`F[i][j]`时，使用的是过程k-1的`F[i][k]`和`F[k][j]`。如果升序遍历，那么得到的`F[i][j]`可能经过了两次顶点k，因为`F[i][k]`和`F[k][j]`已经是过程k的最优解，因此可能经过顶点k，幸运的是，`F[k][k] = 0`，即`F[i][k]`和`F[k][j]`在过程k-1和过程k中的值必然是一样的，因此不会对结果造成影响。

### 2.1.2 0-1背包的空间降维

类似地，0-1背包问题的空间复杂度也可以进行降维处理。0-1背包的子问题设计如下，令`M[k][i]`代表前k个物品在给定容量i时的最大收益。`P[i]`代表第i个物品的收益，`V[i]`代表第i个物品的容量

于是我们可以给出递推表达式：`M[k][i] = min(M[k-1][i], V[i] + M[k-1][i - V[i]])`。其中`M[k-1][i]`代表当__不选取第k个物品__时的最大收益；`V[i] + M[k-1][i - V[i]]`代表不__选取第k个物品__时的最大收益。

可以看出M[k][i]仅仅与M[k-1][?]有关，于是空间复杂度可以从O(MN)降低为O(N)。此时递推表达式变为`M[i] = min(M[i], V[i] + M[i - V[i]])`。

__注意，必须对容量i降序遍历，否则将得到错误结__。因为`M[i]`依赖于`M[i - V[i]]`，因此必须保证在计算过程k的`M[i]`时，使用的是过程k-1的`M[i - V[i]]`。如果升序遍历，那么得到的`M[i]`可能包含两个物品k的受益，因为`M[i - V[i]]`已经是过程k的最优值，因此可能就包含了物品k。

```Java
package org.liuyehcf.dp.backpack;

import java.util.Random;

/**
 * Created by liuye on 2017/4/10 0010.
 */
public class TestBaseBackPack {
    public static void main(String[] args) {
        Random random = new Random(0);
        for (int time = 0; time < 100; time++) {

            int N = random.nextInt(100) + 1, V = random.nextInt(1000) + 1;
            int W = random.nextInt(50) + 1, C = random.nextInt(50) + 1;
            int[] weights = new int[N];
            int[] values = new int[N];
            for (int i = 0; i < N; i++) {
                weights[i] = random.nextInt(W) + 1;
                values[i] = random.nextInt(C) + 1;
            }

            int res1, res2;
            if ((res1 = maxValue1(weights, values, V)) != (res2 = maxValue2(weights, values, V))) {
                System.err.println(time + ": error { res1: " + res1 + ", res2: " + res2);
            }
        }

    }

    private static int maxValue1(int[] weights, int[] values, int capacity) {
        int[][] dp = new int[weights.length + 1][capacity + 1];
        for (int i = 1; i <= weights.length; i++) {
            for (int v = 1; v <= capacity; v++) {
                if (v < weights[i - 1]) {
                    dp[i][v] = dp[i - 1][v];
                } else {
                    dp[i][v] = Math.max(dp[i - 1][v], dp[i - 1][v - weights[i - 1]] + values[i - 1]);
                }
            }
        }

        return dp[weights.length][capacity];
    }

    private static int maxValue2(int[] weights, int[] values, int capacity) {
        int[] dp = new int[capacity + 1];

        for (int i = 1; i <= weights.length; i++) {
            // 这里必须降序遍历，否则将得到错误结果
            for (int v = capacity; v >= 1; v--) {
                if (v < weights[i - 1]) break;
                dp[v] = Math.max(dp[v], dp[v - weights[i - 1]] + values[i - 1]);
            }
        }
        return dp[capacity];
    }
}
```

## 2.2 Java源码

对应[HihoCode第1081题](https://hihocoder.com/problemset/problem/1081)。可自行验证正确性

```Java
package org.liuyehcf.graph;

import java.util.Arrays;
import java.util.Scanner;

/**
 * Created by t-chehe on 8/5/2017.
 */
public class FloydWarshall {
    private static final int CANNOT_REACH = Integer.MAX_VALUE >> 2;

    public static void main(String[] args) {
        int N, M, S, T;

        Scanner scanner = new Scanner(System.in);

        N = scanner.nextInt();
        M = scanner.nextInt();
        S = scanner.nextInt();
        T = scanner.nextInt();

        int[][] path = new int[N + 1][N + 1];

        for (int i = 1; i <= N; i++) {
            Arrays.fill(path[i], CANNOT_REACH);
            path[i][i] = 0;
        }

        while (M-- > 0) {
            int source = scanner.nextInt();
            int dest = scanner.nextInt();
            int length = scanner.nextInt();

            if (length < path[source][dest]) {
                path[source][dest] = length;
                path[dest][source] = length;
            }
        }

        System.out.println(minPath2(path, N, S, T));
    }

    public static int minPath1(int[][] path, int num, int source, int dest) {
        int dp[][][] = new int[num + 1][num + 1][num + 1];

        for (int i = 1; i <= num; i++) {
            dp[0][i] = path[i].clone();
        }

        for (int k = 1; k <= num; k++) {
            for (int i = 1; i <= num; i++) {
                for (int j = 1; j <= num; j++) {

                    dp[k][i][j] = Math.min(dp[k - 1][i][j], dp[k - 1][i][k] + dp[k - 1][k][j]);
                }
            }
        }

        return dp[num][source][dest];
    }

    public static int minPath2(int[][] path, int num, int source, int dest) {
        int dp[][] = new int[num + 1][num + 1];

        for (int i = 1; i <= num; i++) {
            dp[i] = path[i].clone();
        }

        // 表示DP过程的迭代k必须置于最外层
        for (int k = 1; k <= num; k++) {
            // 必须逆序
            for (int i = num; i >= 1; i--) {
                for (int j = num; j >= 1; j--) {

                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);

                }
            }
        }

        return dp[source][dest];
    }
}
```

# 3 参考

* [最短路径—Dijkstra算法和Floyd算法](http://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html#3750339)
* [单源最短路径（1）：Dijkstra 算法
](http://www.61mon.com/index.php/archives/194/)

* [Floyd算法为什么把k放在最外层？](https://www.zhihu.com/question/30955032)
* 百度百科


