---
title: TCP-IP详解-读书笔记
date: 2019-10-28 17:46:22
mathjax: true
tags: 
- 摘录
categories: 
- Network
---

__阅读更多__

<!--more-->

# 1 概述

1. __网桥__是在__链路层__对网络进行互连，而__路由器__则是在__网络层__上对网络进行互连
1. `ICMP`是`IP`的附属协议，`IP`层用它来与其他主机或路由器交换错误报文和其他重要信息
1. 为`ICMP`、`IGMP`、`ARP`、`RARP`协议定位是比较棘手的，在不同的场景下可以位于不同的网络层级

# 2 链路层

1. 在`TCP/IP`协议簇中，链路层主要有三个目的
    * 为`IP`模块发送和接收`IP`数据报
    * 为`ARP`模块发送`ARP`请求和接收`ARP`应答
    * 为`RARP`发送`RARP`请求和接收`RARP`应答
1. 几个不同的标准集
    * `802.3`：整个`CSMA/CD`网络（Carrier Sense, Multiple Access with Collision Detection）
    * `802.4`：针对令牌总线网络
    * `802.5`：针对令牌环网络
1. `802.3`标准定义的帧和以太网的帧都有最小长度要求。`802.3`规定__数据部分__必须至少为38字节，而对于以太网，则要求最少要有46字节（这是为什么？）。为了保证这一点，必须在不足的空间插入填充字节
1. 大多数的产品都支持环回接口（Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信
1. 以太网和`802.3`对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称为`MTU`，最大传输单元。如果`IP`层有一个数据报要传，且数据报的长度比链路层的`MTU`还大，那么`IP`层就需要进行分片
1. 两台主机之间的通信如果经过多个网络，那么每个网络的链路层可能有不同的`MTU`，在这多个网络中，具有的最小`MTU`称作路径`MTU`
1. 两台主机之间的`MTU`不一定是个常数，它取决于当时所选择的路由，而选路不一定是对称的，因此路径`MTU`在两个方向上不一定是一致的
1. 网络地址划分
    * A类地址：0.0.0.0 -> 127.255.255.255
    * B类地址：128.0.0.0 -> 191.255.255.255
    * C类地址：192.0.0.0 -> 223.255.255.255
    * D类地址：224.0.0.0 -> 239.255.255.255
    * E类地址：240.0.0.0 -> 255.255.255.255

# 3 网际协议

1. `IP`提供不可靠、无连接的数据报传送服务
    * 不可靠：不保证`IP`数据报能成功到达目的地。`IP`仅能提供尽力而为的传输服务
    * 无连接：`IP`并不维护任何关于后续数据报的状态信息，每个数据报的处理是独立的，也就是说，`IP`数据报可以不按发送顺序接收（每个数据报的选路是独立的）
1. `IP`协议格式
    * 4位版本、4位首部长度、8位服务类型（TOS）、16位总长度（字节数）
    * 16位标志、3位标志、13位片偏移
    * 8位生存时间、8位协议、16位首部校验和
    * 32位源IP地址
    * 32位目的IP地址
    * 选项
    * 数据
1. 目前协议版本号是4，因此`IP`有时也称为`IPv4`
1. 首部长度指的是首部占`32bit字`的数目（32bit记为一份），由于这是一个4bit字段（0-15），因此首部最长为 `15*32bit=480bit=60Byte`
1. `TOS`字段包括一个3bit的优先权子字段（现已被忽略）、4bit的`TOS`子字段、1bit的未用字段（必须置0）。其中，4bit的`TOS`子字段分别代表
    * 最小时延（0x10）
    * 最大吞吐量（0x08）
    * 最高可靠性（0x04）
    * 最小费用（0x02）
    * 一般服务（0x00）
1. 总长度字段是指整个`IP`数据报的长度，以字节为单位（区别于首部长度，首部长度的单位是32bit，也就是4字节），由于该字段长度为16bit，所以`IP`数据报最长可达65535字节
1. `TTL`（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数，`TTL`的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，他的值就会减去1。当该字段的值为0时，数据报就被丢弃，并发送`ICMP`报文通知源主机
1. 首部检验和字段是根据IP首部计算的检验和码，他不对首部后面的数据进行计算。`ICMP`、`IGMP`、`UDP`和`TCP`在它们各自的首部中均含有同时覆盖首部和数据的检验和码
1. 最后一个字段是任选项，是数据报中的一个可变长的可选信息，这些选项定义如下（这些选项很少使用，并非所有主机和路由器都支持，且选项都是以32bit作为界限，在必要时需要插入0填充，这样就保证了`IP`首部始终是32bit的整数倍）
    * 安全和处理限制
    * 记录路径
    * 时间戳
    * 宽松的源站选路
    * 严格的源站选路
1. `IP`层既可以配置成路由器的功能，也可以配置成主机的功能。本质的区别在于主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据报
1. 路由表包含如下信息
    * 目的`IP`地址，既可以是一个完整的主机地址，也可以是一个网络地址
    * 下一站路由器的`IP`地址，指一个在直接相连网络上的路由器
    * 标志，其中一个标志标明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器还是一个直接相连的接口
    * 为数据报传输指定一个网络接口
1. `IP`路由器主要完成如下功能
    * 搜索路由表，寻找能与目的`IP`地址完全匹配的表目
    * 搜索路由表，寻找能与目的网络号相匹配的表目
    * 搜索路由表，寻找标为默认（default）的路由表
1. 现在所有的主机都要求支持子网编址，不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。这样做的原因是A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数太多了
1. 通常把B类地址留给主机的16bit中的前8bit作为子网地址，后8bit作为主机号
1. 子网对外部路由器来说隐藏了内部网络组织，但是对子网内部的路由器来说是不透明的（与30个C类地址相比，用一个包含30个子网的B类地址的好处是可以减小路由表的规模）
1. 子网掩码用来确定多少bit用于子网号，多少bit用于主机号（网络号的划分是明确的，而子网的划分是不明确的），其中值为1的bit表示网络号和子网号，为0的bit用于主机号
1. 给定IP和子网掩码后，主机就可以确定IP数据报的目的地，根据IP可以确定网络号和子网号的分界线，根据子网掩码可以确定子网号和主机号的分界线
    * 本子网上的主机
    * 本网络中其他子网中的主机
    * 其他网络上的主机

# 4 ARP: 地址解析协议

1. 链路层如以太网或令牌环网都有自己的寻址机制（通常为48bit），这是使用链路层的任何网络都必须遵从的
    * 例如，一组使用`TCP/IP`协议的主机和另一组使用某种PC网络软件的主机可以共享相同的电缆
1. 当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48bit的以太网地址来确定目的接口的。设备驱动程序从不检查`IP`数据报中的目的`IP`地址
1. 地址解析为这两种不同的地址形式提供映射：32bit的`IP`地址和数据链路层使用的任何类型的地址
    * ARP为IP地址到对应的硬件地址之间提供动态映射，动态是指这个过程是自动完成的，一般用户和管理员无需关心
1. __ARP背后有一个基本概念，那就是网络接口有一个硬件地址（一个48bit的值，标识不同的以太网或令牌环网接口）。在硬件层次上进行的数据帧交换必须有正确的接口地址。知道主机的IP并不能让内核发送一帧数据给主机。内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据。ARP的功能是在32bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射__
1. ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟
    * `arp -a`可以查看高速缓存中的内容
1. 对于一个`IP`数据报，如果目的主机在本网络上（如以太网、令牌环网或点对点链接的另一端），那么`IP`数据报可以直接发送到目的主机上。如果目的主机在一个远程网络上，那么就通过`IP`选路函数来确定位于本地网络上的下一站路由器地址，并让它转发`IP`数据报。这两种情况下，`IP`数据报都是被送到本地网络上的一台主机或路由器（假定是以太网）
    * `ARP`发送一份称为`ARP`请求的以太网数据帧给以太网上的每个主机。这个过程称作广播。`ARP`请求中包含目的主机的IP地址。该请求的意思是：如果你是这个IP地址的拥有者，请回答你的硬件地址
    * 目的主机的`ARP`层收到这份广播报文后，识别出这是发送端在询问它的IP地址，于是发送一个`ARP`应答，这个`ARP`应答包含IP地址及对应的硬件地址
    * 收到`ARP`应答后，使`ARP`进行请求-应答交换的IP数据报现在就可以传送了
    * 发送IP数据报道目的主机
1. 直到`ARP`应答返回时，`TCP`报文才会被发送，因此对不存在的主机发送`TCP`报文，在链路上是看不到任何`TCP`数据的，但是会触发`TCP`的重传机制
1. `ARP`代理：如果`ARP`请求是从一个网络的主机发往另一个网络的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称为`ARP`代理（`Proxy ARP`）
1. 免费ARP：是指主机发送ARP查找自己的IP地址，通常它发生在系统引导期间进行接口配置的时候
    * 一个主机可以通过它来确定另一个主机是否设置了相同的IP地址
    * 使其他主机高速缓存中旧的硬件地址进行相应的更新（当某个主机更换了网卡接口的时候）。当某个主机收到了某个IP地址的ARP请求，而且它已经在接受者的高速缓存中，那么就要用ARP请求中的发送端硬件地址对高速缓存中相应的内容进行更新

# 5 RARP: 逆地址解析协议

1. 具有本地磁盘的系统引导时，一般从磁盘上的配置文件中读取`IP`地址。但是无盘机，需要采用其他方法来获得`IP`地址，这种方式就是`RARP`
1. 网络上的每个系统都有唯一的硬件地址，然后发送一份`RARP`请求，请求某个主机响应该误判系统的`IP`地址

# 6 ICMP: Internet控制报文协议

# 7 防火墙和网络地址转换

## 7.1 防火墙

1. 最常用的两种防火墙是`代理防火墙（proxy firewall）和包过滤防火墙（packet-filter）`。他们之间的主要区别是所操作的协议栈的层次以及由此决定IP地址和端口号的使用

### 7.1.1 包过滤防火墙

1. 包过滤防火墙能够过滤（filter）（丢弃）一些网络流量。他们一般都可以配置为丢弃或转发数据包头中符合（或不符合）特定标准的数据报，这些标准称为过滤器（filter）
1. 包过滤防火墙可以看做一个互联网路由器

### 7.1.2 代理防火墙

1. 代理防火墙，并不是真正意义上的互联网路由器。相反，它们本质上是运行一个或多个应用层网关（Application-Layer Gateways, ALG）的主机。该主机拥有多个网络接口，能够在应用层中继两个连接（或关联）之间的特定类型的流量

# 8 TCP: 传输控制协议（初步）

__ARP和重传__

1. Automatic Repeat Request, ARQ: 自从重复请求，是差错处理的一种非常重要的方法
1. 一个直接处理分组丢失（和比特差错）的方法是重发分组直到它被正确接收。这需要一个方法来判断，如下：
    * 接收方是否已收到分组
    * 接收方收到的分组是否与之前发送方发送的一样
    * 接收方给发送方发信号以确认自己已经接收到一个分组，这种方法称为确认（acknowledgment），或ACK。当发送方接收到这个ACK，它再发送另一个分组，这个过程就这样继续，但是会出现一些有意思的问题
        1. 发送方对一个ACK应该等待多长时间？
        1. 如果ACK丢失了怎么办？
        1. 如果分组被接收到了，但是里面有错怎么办？
1. 接收方可能受到被传送分组的重复副本，这个问题要使用序列号（sequence number）来处理

__分组窗口和滑动窗口__

1. 分组窗口（window）：已被发送方注入但还没完成确认的分组的集合。这个窗口中的分组数量称为窗口大小（window size）
    * 术语窗口来自这样的想法：如果你把在一个通信对话中发送的所有分组排成长长的一行，但只能通过一个小孔来观察它们，你就只能看到它们的一个自己---通过一个窗口观看一样
1. 当分组窗口中最左边的分组已收到ACK之后，窗口左侧的边界便可向右移动一格；窗口原右侧边界之外的第一个分组可以进入发送状态，随机进入分组窗口中，于是窗口的右侧边界便可向右移动一格，这便形成了分组窗口的滑动

__变量窗口：流量控制和拥塞控制__

1. 流量控制：用于解决当接收方相对发送方处理速度太慢时产生的问题，具体手段就是强迫发送方慢下来
1. 基于速率（rate-based）流量控制：给发送方指定某个速率，同时确保数据永远不能超过这个速率发送。这种类型的流量控制最适合流应用程序，可被用于广播和组播发现
1. 基于窗口（window-based）流量控制：窗口大小是不固定的，而且允许随时间而变动
    * 必须有一种方法可以通知发送方使用多大的窗口，一般称为窗口通告（window advertisement）或者窗口更新（window update）
1. 拥塞控制：发送方减低速度以不至于压垮其与接收方之间的网络

__设置重传超时__

1. 发送方在重发一个分组之前应等待的时间量大概是下面时间的总和
    1. 发送分组所用的时间
    1. 接收方处理它和发送一个ACK所用的时间
    1. ACK返回到发送方所用的时间
    1. 以及发送方处理ACK所用的时间
    * 遗憾的是，上述这些时间没有一个是固定不变的，都是随着环境的变化而变化的
1. 一个更好的策略是让协议实现尝试去估计这个重传超时时间，这称为往返时间估计（round-trip-time estimation, RTT），这是一个统计过程。总的来说，选择一组RTT样本的样本均值作为真实的RTT是最有可能的，这个平均值很自然地会随着时间而改变，因为通信穿过的网络路径可能会改变
1. 把重传超时时间设置为RTT均值是不合理的，因为很有可能许多实际的RTT将会比较大，从而会导致不必要的重传

__TCP服务模型__

1. TCP和UDP使用相同的网络层（IPv4或IPv6），但是TCP给应用程序提供了一种与UDP完全不同的服务。__TCP提供了一种面向连接的（connection-oriented）、可靠的字节流服务__。
1. 面向连接的：是指使用TCP的两个应用程序必须在它们可能交换数据之前，通过相互联系来建立一个TCP连接、就好像拨打一个电话号码，等待另一方接听电话并说“喂”，然后再说“找谁”。__因此，TCP中不存在广播、组播这种概念__，这两个概念与连接是矛盾的
1. 字节流服务：__TCP不会自动插入记录标志或消息边界__。例如，发送方可能分两次先后写入10字节、20字节，但是接收方可能一次性读入30字节，也有可能分3次每次读入10字节

__TCP中的可靠性__

1. TCP提供一个字节流接口，TCP必须把一个发送应用程序的字节流转换成一组IP可以携带的分组。这被称为组包

# 9 TCP连接管理

TCP服务模型是一个字节流。TCP必须检测并修补所有在IP层产生的数据传输问题，比如丢包、重复以及错误

## 9.1 TCP连接的建立与终止

1. 一个TCP连接由一个4元组构成，他们分别是两个IP地址和两个端口号
1. 一个TCP连接通常分为3个阶段：启动、数据传输和退出
    * ![fig](/images/TCP-IP详解-读书笔记/13-2-1.jpg)
1. TCP建连步骤如下：
    1. 主动开启者（通常称为客户端）发送一个SYN报文段，并指明自己想要连接的端口号和它的客户端初始序列号（`ISN(c)`）
    1. 服务器也发送自己的SYN报文段作为响应，并包含了它的初始序列号（`ISN(s)`）。此外，为了确认客户端的SYN，服务器将其包含的`ISN(c)`数值加1后作为返回的ACK数值。因此，每发送一个SYN，序列号就会自动加1。这样如果出现丢失的情况，该SYN段将会重传
    1. 为了确认服务器的SYN，客户端将`ISN(s)`的数值加1后作为返回的ACK值
    * 三次握手的目的不仅在于让通信双方了解一个连接正在建立，还在于利用数据包的选项来承载特殊的信息，交换初始序列号（Initial Sequence Number, ISN）
1. TCP关闭步骤如下：
    1. 连接的主动关闭者发送一个FIN报文段，指明接受者希望看到的自己当前的序列号（图中的`K`），FIN段还包含了一个ACK段用于确认对方最近一次发来的数据（图中的`L`）
    1. 连接的被动关闭者将`K`的数值加1作为响应的ACK值，以表明它已经成功接收到主动关闭者发送的`FIN`。此时，上层的应用程序会被告知连接的另一端已经提出了关闭的请求。通常，这将导致应用程序发起自己的关闭操作。接着，被动关闭者将身份转变为主动关闭者，并发送自己的FIN。该报文段的序列号为`L`
    1. 为了完成连接的关闭，最后发送的报文段还包含一个ACK用于确认上一个FIN。值得注意的是，如果出现FIN丢失的情况，那么发送方将重新传输直到接收到一个ACK确认为止
1. 通常情况下，建立一个TCP连接需要3个报文段，而关闭一个TCP连接需要4个报文段。此外，TCP的通信模型是双向的，因此还支持半开启/半关闭（很少见）
    * 半开启：只有一个方向正在进行数据传输
    * 半关闭：仅关闭数据流的一个方向
    * 这两个概念描述的可能是同一个状态，只不过角度不同
1. 伯克利套接字的API提供了半关闭操作，用`shutdown()`来代替`close()`
    * 首次发送的两个报文段，与TCP正常关闭时完全相同：主动关闭者发送FIN，被动关闭者回应该FIN的ACK
    * 被动关闭者可以发送任意数量的数据段
    * 当被动关闭者完成数据发送后，他将会发送一个FIN来关闭本方连接，同时向发起半关闭的应用程序发出一个文件尾提示
    * 当第二个FIN被确认后，整个连接完全关闭
    * ![fig](/images/TCP-IP详解-读书笔记/13-2-2.jpg)
1. 同时打开：通信双方在接收到来自对方的SYN之前必须先发送一个SYN（这种情况其实非常少见，但是对于TCP协议的实现来说，必须要考虑这种情况）。
    * 同时打开过程需要交换4个报文段，比普通的三次握手增加了一个
    * ![fig](/images/TCP-IP详解-读书笔记/13-2-3.jpg)
1. 同时关闭：与普通关闭并无太大区别，因为通信双方都需要主动提出关闭请求
    * ![fig](/images/TCP-IP详解-读书笔记/13-2-4.jpg)
1. 初始序列号：TCP报文段在经过网络路由后可能会存在延迟抵达与排序混乱的情况，初始序列号就是为了解决这个问题
    * 在发送用于建立连接的SYN之前通信双方都会选择一个初始序列号。初始序列号会随着时间递增，它被设计成一个32位的计数器，该计数器每4微妙增加1
    * TCP连接由四元组确定，因此即便是同一个连接也会出现不同的实例（同样的四元组建连关闭，再建连再关闭，就是2个不同的实例）
    * 一个TCP报文段只有同时具备连接的四元组与当前活动窗口的序列号，才会在通信过程中被对方认为是正确的的。这也侧面反映了TCP的脆弱性。如果不加以限制，任何人只要知道四元组，就能伪造TCP报文段，从而干扰正常连接
    * 现代系统通常采用半随机的方法选择初始序列号
1. 连接建立超时
    * `net.ipv4.tcp_syn_retries(/proc/sys/net/ipv4/tcp_syn_retries)`：一次主动打开申请中尝试重新发送SYN报文段的最大次数
    * `net.ipv4.tcp_synack_retries(/proc/sys/net/ipv4/tcp_synack_retries)`：表示响应对方的一个主动打开请求时尝试重新发送SYNC+ACK报文段的最大次数

## 9.2 TCP选项

| 种类 | 长度 | 名称 | 参考 | 目的与描述 |
|:--|:--|:--|:--|:--|
| 0 | 1 | EOL | [RFC0793] | 选项列表结束 |
| 1 | 1 | NOP | [RFC0793] | 无操作（用于填补） |
| 2 | 4 | MSS | [RFC0793] | 最大段大小 |
| 3 | 3 | __WSOPT__ | [RFC01323] | __窗口放缩因子__ |
| 4 | 2 | SACK-Permitted | [RFC02018] | 发送者支持SACK选项 |
| 5 | 可变 | SACK | [RFC02018] | SACK阻塞（接收到乱序数据） |
| 8 | 10 | TSOPT | [RFC01323] | 时间戳选项 |
| 28 | 4 | UTO | [RFC05482] | 用户超时（一段空闲时间后的终止） |
| 29 | 可变 | TCP-AO | [RFC05925] | 认证选项（使用多种算法) |
| 253 | 可变 | Experimental | [RFC04727] | 保留供实验室所用 |
| 254 | 可变 | Experimental | [RFC04727] | 保留供实验室所用 |

1. TCP支持的选项如上表，种类指明了该选项的类型，不能被理解的选项会被直接忽略

### 9.2.1 最大段大小选项

1. 最大段大小是指TCP协议锁允许的从对方接收到的最大报文段，且只记录TCP数据的字节数（不包括其他相关的TCP与IP头部）。默认为536字节。__经典设置值是1460（1460字节的TCP数据+20字节的TCP协议头+20字节的IP协议头=1500，这是MTU的经典设置值）__

### 9.2.2 选择确认选项

1. TCP的选择确认选项（SACK）能够让发送方了解到接收方的窗口信息，从而能够更好地进行重传
1. SACK选项包含了一组SACK块，每个SACK块包含了接收方已经成功接收的数据块的序列号范围，由一对32位的序列号表示。因此，一个SACK选项包含了n个SACK块，长度为(8n+2)
1. 同时，由于TCP头部选项空间是有限的。因此，一个报文段中发送的最大SACK块的数量为3

### 9.2.3 窗口缩放因子

1. 根据[RFC1323]，窗口缩放选项（表示为`WSCALE`或`WSOPT`）能够有效地将TCP窗口字段的范围从16位增加至30位。TCP头部不需要改变窗口字段的大小，仍然维持16位的数值。同时，使用另一个选项作为这16位数值的比例因子。该比例因子能够使窗口字段有效地左移
1. 比例因子最小是0，最大是14，当比例因子是14时，能提供一个最大为{% raw %}$(65536\ *\ 2^{14})${% endraw %}的窗口，该数据接近1GB。因此TCP使用一个32位的值来维护这个"真实"的窗口大小
1. 该选项只能出现于一个SYN报文段中。因此当连接建立之后，比例因子也是与方向有关的。为了保证窗口的调整，通信双方都需要在SYN报文段中包含该选项
1. 默认的比例因子是0

### 9.2.4 时间戳选项与防回绕序列号

1. 时间戳选项（TSOPT）要求发送方在每个报文段中添加2个4字节的时间戳数值。接收方会在确认中反映这些数值，允许发送方针对每一个接收到的ACK估算TCP连接的往返时间（由于TCP协议经常利用一个ACK来确认多个报文段，此处必须指出“是每个接收到的ACK”而不是“每个报文段”）。关于这部分细节，在`TCP数据流与窗口管理`一章中会详细讨论，这里不展开
1. 该选项并不要求在两台主机之间进行任何形式的时钟同步（比如一端用的是北京时间，一端用的是纽约时间），只要每一端保证单调递增即可
1. TCP的序列号是32位的，是个有限的数值，因此它是会循环的。而时间戳选项可以帮助`接收者`有效区分新旧报文，这被称为`防回绕序列号（Protection Against Wrapped Sequence numbers, PAWS）`
    * 如果报文段的时间戳与当前时间戳的间隔超过`MSL（一个报文段在网络中存在的最大时间）`时，根据防回绕序列号算法，会将其丢弃
    * 由于接收方和发送方时钟不同步，接收方只能得知下一个发送方发送的报文段的最小时间戳（记为`MIN_NEXT_TIMESTAMP`)，一定比上一次收到的报文段的时间戳要大（发送方必须确保时间戳单调递增）。因此，当报文段到达的时候，如果`MIN_NEXT_TIMESTAMP - TIME_STAMP > MSL`，那么报文将被丢弃 

### 9.2.5 用户超时选项

1. `用户超时（UTO）`选项的数值`USER_TIMEOUT`指明了TCP发送者在确认对方未能成功接收数据之前愿意等待该数据ACK确认的时间
1. 用户超时选项的数值是建议性的，另一端并不一定要遵从
1. 一般建议值如下
    * 规则1：当TCP连接打到3次重传阈值时应该通知应用程序
    * 规则2：当超时大于100秒时应该关闭连接

### 9.2.6 认证选项

1. TCP设置了一个选项用于增强连接的安全性。通信双方必须采用一种方法在TCP认证选项运行之前建立出一套共享秘钥
1. 发送数据时，TCP会根据共享秘钥生成一个通信秘钥。接收者装配有相同的秘钥，同样也能够生成通信秘钥
1. 由于需要创建并分发一个共享秘钥，该选项并未得到广泛使用

## 9.3 TCP的路径最大传输单元发现

1. 路径最大传输单元（MTU）是指经过两台主机之间路径的所有网络报文段中最大传输单元的最小值。知道路径最大传输单元后能够有助于一些协议（比如TCP）避免分片
1. `分组层路径最大传输单元发现（Packetization Layer Path MTU Discovery, PLPMTUD）`，该算法可以为TCP以及其他协议计算路径最大传输单元，__同时避免使对ICMP的使用（为什么要避免使用ICMP？）__
    * 在该算法中，利用`IPv6`协议中的”数据包太大“`（PTB，Packet Too Big）`来代表ICMPv4地址不可达（需要分片）或ICMPv6数据包太大的消息
1. TCP常规的路径最大传输单元发现过程如下：
    1. 在一个连接建立时，TCP使用对外接口的最大传输单元的最小值，或者根据通信对方声明的最大段大小来选择发送方的最大段大小（SMSS）。`路径最大传输单元发现`不允许TCP发送方有超过另一方声明的最大段大小的行为。如果对方没有指明最大段大小的数值，发送方将假设采用默认的536字节
    1. 一旦为发送方的最大段大小选定了初始值，TCP通过这条连接发送的所有IPv4数据报都会对DF位字段进行设置。__TCP/IP没有DF位字段，因此只需要假设所有的数据报都已经设置了该字段而不必进行实际操作__
    1. 如果接收到了PTB消息，TCP就会减少段的大小，然后用修改过的段进行重传。如果在PTB消息中已经包含了下一跳推荐的最大传输单元，数据段大小的数值可以设置为下一跳最大传输单元的数值减去IPv4（或IPv6）与TCP头部的大小；如果下一跳最大传输单元的数值不存在，发现者可能需要尝试多个数值（例如二分法）
    1. 由于路由是动态变化的，在减少段大小的数值一段时间后需要尝试一个更大的数值（接近初始的发送方最大段大小），该时间间隔大约为10分钟
1. 在互联网环境中，由于防火墙阻塞PTB消息，路径最大传输单元发现过程会存在一些问题
    1. 如果TCP的实现依靠ICMP消息来调整它的段大小的情况下，如果TCP从未接收到任何ICMP消息，那么在路径最大传输单元发现过程中就会造成黑洞问题。其原因可能是防火墙或NAT配置禁止转发ICMP消息
    1. 一些TCP的实现具有“黑洞探测”功能，当一个报文在反复重传数次后，将会尝试发送一个较小的报文段

## 9.4 TCP状态转换

![fig](/images/TCP-IP详解-读书笔记/13-5-1.jpg)

1. 状态图解释
    * 椭圆表示状态
    * 箭头表示状态转换
1. __只有一部分状态转移被认为是“典型的”__
    * 客户端典型的状态转移用深黑色的实线箭头表示
    * 服务端典型的转台转移用虚线箭头表示

![fig](/images/TCP-IP详解-读书笔记/13-5-2.jpg)

1. `SYN_SENT`：主动发起者发出SYN(K)后，进入到该状态，等待对方回复ACK(K+1)
1. `SYN_RCVD`：被动发起者收到SYN(K)，且回复ACK(K+1)以及SYN(L)之后，进入到该状态，等待对方回复ACK(L+1)
1. `ESTABLISHED`：有两种情况
    * 主动发起者收到ACK(K+1)以及SYN(L)，并回复ACK(L+1)之后，进入到该状态
    * 被动发起者收到ACK(L+1)之后，进入到该状态
1. `FIN_WAIT_1`：主动关闭者发送FIN(M)之后，进入到该状态
1. `CLOSE_WAIT`：被动关闭者收到FIN(M)之后，并回复ACK(M+1)之后，进入到该状态。此时，连接的一个方向已关闭，等待另一个方向的数据传输完毕并发送FIN
1. `FIN_WAIT_2`：主动关闭者收到对方发送的ACK(M+1)之后，进入到该状态。此时，连接的一个方向已关闭，等待另一个方向的数据传输完毕并发送FIN
1. `LAST_ACK`：被动关闭者传输完毕所有数据，发送FIN(N)之后，进入到该状态
1. `TIME_WAIT`：主动关闭者收到FIN(N)，且回复ACK(N+1)之后，进入到该状态
1. `CLOSED`：有两种情况
    * 当被动关闭者收到ACK(N+1)之后，进入到该状态
    * 当主动关闭者等待`2MSL`之后，将会从`TIME_WAIT`进入到该状态

### 9.4.1 TIME_WAIT状态

1. `TIME_WAIT`状态也称为`2MSL`等待状态。在该状态中，TCP将会等待两倍于最大段生存期（Maximum Segment Lifetime，MSL）的时间，有时也被称作加倍等待。它代表任何报文段在被丢弃前在网络中被允许存在的最长时间。这个时间是有限的，因为TCP报文段是以IP数据报的形式传输的，IP数据报拥有TTL字段和条数限制字段。这两个字段限制了IP数据报的有效生存时间
1. [RFC0793]将最大段生存期设置为2分钟。在常见的实现中，最大段生存期的数值可以为30秒、1分钟或2分钟。在linux系统中，`net.ipv4.tcp_fin_timeout（/proc/sys/net/ipv4/tcp_fin_timeout）`记录了`2MSL`状态需要等待的超时时间
1. 当TCP执行一个主动关闭并发送最终的ACK时，连接必须处于`TIME_WAIT`状态并持续两倍于最大生存期的时间。这样就能够让TCP重新发送最终的ACK以避免出现丢失的情况。重新发送最终的ACK并不是因为TCP重传了ACK（ACK不消耗序列号，也不会被TCP重传），而是因为通信另一方重传了它的FIN（它消耗一个序列号）。事实上，TCP总是重传FIN，直到它收到一个最终的ACK
1. __当TCP处于`2MSL`等待状态时，该连接（四元组）不可重新使用（一些实现施加了更加严格的约束，在这些系统中，如果一个端口号处于`2MSL`等待状态，那么该端口号将不能再次被使用）。许多实现和API都提供了绕开这一约束的方法，在伯克利套接字API中`SO_REUSEADDR`套接字选项就支持绕开该操作__
1. 对于交互式的应用程序而言，客户端通常执行主动关闭操作并进入`TIME_WAIT`状态，服务器通常执行被动关闭操作并且不会直接进入`TIME_WAIT`状态

# 10 TCP数据流与窗口管理

