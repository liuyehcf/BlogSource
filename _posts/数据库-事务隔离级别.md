---
title: 数据库-事务隔离级别
date: 2017-09-02 14:13:31
tags: 
- 摘录
categories: 
- Data Base
- Basic Concepts
---

__阅读更多__

<!--more-->

# 1 前言

本篇文章针对`MySQL`的`InnoDB数据库引擎`

# 2 ACID

__A：事务的原子性(Atomicity)__：指一个事务要么全部执行，要么不执行。也就是说一个事务不可能只执行了一半就停止了。比如你从取款机取钱，这个事务可以分成两个步骤：1划卡，2出钱。不可能划了卡，而钱却没出来。这两步必须同时完成，要么就不完成
__C：事务的一致性(Consistency)__：指事务的运行并不改变数据库中数据的一致性。例如，完整性约束了a+b=10，一个事务改变了a，那么b也应该随之改变
__I：独立性(Isolation)__：事务的独立性也有称作隔离性，是指两个以上的事务不会出现交错执行的状态。因为这样可能会导致数据不一致
__D：持久性(Durability)__：事务的持久性是指事务执行成功以后，该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚

# 3 名词解释

## 3.1 第一类丢失更新

A事务撤销时，把已经提交的B事务的更新数据覆盖了

| 时间 | 取款事务A | 转账事务B |
|:--|:--|:--|
| T1 | __开始事务__ | / |
| T2 | / | __开始事务__ |
| T3 | 查询账户余额为1000元 | / |
| T4 | / | 查询账户余额为1000元 |
| T5 | / | 汇入100元，把余额改为1100元 |
| T6 | / | __提交事务__ |
| T7 | 取出100元，把余额改为900元 | / |
| T8 | __撤销事务__ | / |
| T9 | __余额恢复为1000元(丢失更新)__ | / |

__第一类丢失更新的本质是：写操作所依赖的原数据是无效的，因此串行化写操作即可解决第一类丢失更新问题，即Read uncommitted可以解决第一类丢失更新的问题__

## 3.2 第二类丢失更新

A事务覆盖B事务已经提交的数据，造成B事务所作的操作丢失

| 时间 | 取款事务A | 转账事务B |
|:--|:--|:--|
| T1 | / | __开始事务__ |
| T2 | __开始事务__ | / |
| T3 | / | 查询账户余额为1000元 |
| T4 | 查询账户余额为1000元 | / |
| T5 | / | 取出100元，把余额改为900元 |
| T6 | / | __提交事务__ |
| T7 | 汇入100元 | / |
| T8 | __提交事务__ | / |
| T9 | __把余额改为1100元(丢失更新)__ | / |

__第二类丢失更新的本质是：取款事务A一开始查询的1000元是无效数据，如果在B事务提交后再查询一次账户余额，将会得到不同的结果。我们只要保证读取的一定是有效数据即可，即可重复读。因此Repeatable read可以解决第二类丢失更新问题__

## 3.3 脏读

脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据

## 3.4 不可重复读

是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读

## 3.5 幻读

是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象
发生了幻觉一样

# 4 事务隔离级别以及实现方式

## 4.1 Read uncommitted(读未提交)

__实现方式__：

* 事务读数据时__不加锁__
* 事务写数据的时候(写操作时才加锁而不是事务一开始就加锁)加__行级独占锁__，__事务结束释放__

行级别的共享锁可以防止两个同时的写操作，但是不会对读产生影响。因此可以避免第一类丢失更新，但是会产生脏读的问题

### 4.1.1 验证

__测试工具__

1. mysql-5.7.16
1. bash

__准备工作__

```sql
CREATE TABLE test(
id INT NOT NULL AUTO_INCREMENT,
name VARCHAR(20) NOT NULL DEFAULT "",
PRIMARY KEY(id)
)Engine=InnoDB;

INSERT INTO test(name)
VALUES("张三");
```

__客户端1__
执行如下操作

```sql
SET autocommit = 0; -- 取消事务的自动提交

SELECT @@session.tx_isolation; -- 查看隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; -- 修改隔离级别
SELECT @@session.tx_isolation; -- 查看隔离级别

BEGIN; -- 开启事务
SELECT name FROM test WHERE id = 1;
```

输出如下

```sql
mysql> SELECT name FROM test WHERE id = 1;
+--------+
| name   |
+--------+
| 张三   |
+--------+
1 row in set (0.00 sec)
```

__客户端2__
执行如下操作

```sql
SET autocommit = 0; -- 取消事务的自动提交

SELECT @@session.tx_isolation; -- 查看隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; -- 修改隔离级别
SELECT @@session.tx_isolation; -- 查看隔离级别

UPDATE test SET name = '张八' WHERE id = 1;
```

输出如下

```sql
mysql> UPDATE test SET name = '张八' WHERE id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```

__客户端1__
执行如下操作

```sql
SELECT name FROM test WHERE id = 1;
```

输出如下

```sql
mysql> SELECT name FROM test WHERE id = 1;
+--------+
| name   |
+--------+
| 张八   |
+--------+
1 row in set (0.00 sec)
```

此时我们发现，客户端1读取到了客户端2未提交的数据'张八'

__客户端2__
执行如下操作

```sql
rollback;
```

__客户端1__
执行如下操作

```sql
SELECT name FROM test WHERE id = 1;
```

输出如下

```sql
mysql> SELECT name FROM test WHERE id = 1;
+--------+
| name   |
+--------+
| 张三   |
+--------+
1 row in set (0.00 sec)
```

__接下来我们分析一下加锁情况(接着上面操作继续)__

__客户端1__
执行如下操作

```sql
UPDATE test SET name = '李四' WHERE id =1;
```

输出如下

```sql
mysql> UPDATE test SET name = '李四' WHERE id =1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```

__客户端2__
执行如下操作

```sql
UPDATE test SET name = '李四' WHERE id =1;
```

此时我们发现，操作并没有进行，而是被阻塞了

__客户端3__
执行如下操作

```sql
SELECT * FROM information_schema.INNODB_LOCKS; -- 查看锁状态
SELECT * FROM information_schema.INNODB_LOCKS\G; -- 将得到列状的输出
```

输出如下

```sql
mysql> SELECT * FROM information_schema.INNODB_LOCKS;
+---------------+-------------+-----------+-----------+------------------+------------+------------+-----------+----------+-----------+
| lock_id       | lock_trx_id | lock_mode | lock_type | lock_table       | lock_index | lock_space | lock_page | lock_rec | lock_data |
+---------------+-------------+-----------+-----------+------------------+------------+------------+-----------+----------+-----------+
| 14435:148:3:2 | 14435       | X         | RECORD    | `mybatis`.`test` | PRIMARY    |        148 |         3 |        2 | 1         |
| 14434:148:3:2 | 14434       | X         | RECORD    | `mybatis`.`test` | PRIMARY    |        148 |         3 |        2 | 1         |
+---------------+-------------+-----------+-----------+------------------+------------+------------+-----------+----------+-----------+
2 rows in set, 1 warning (0.00 sec)
```

可以看到写操作是有锁的，而且是X锁(排他锁)

__客户端3__
执行如下操作

```sql
SELECT * FROM information_schema.INNODB_TRX; -- 查看事务状态
SELECT * FROM information_schema.INNODB_TRX\G; -- 将得到列状的输出
```

输出如下

```sql
mysql> mysql> SELECT * FROM information_schema.INNODB_TRX\G; -- 查看事务状态
*************************** 1. row ***************************
                    trx_id: 14435
                 trx_state: LOCK WAIT
               trx_started: 2017-09-03 14:08:41
     trx_requested_lock_id: 14435:148:3:2
          trx_wait_started: 2017-09-03 14:13:40
                trx_weight: 2
       trx_mysql_thread_id: 17
                 trx_query: UPDATE test SET name = '李四' WHERE id =1
       trx_operation_state: starting index read
         trx_tables_in_use: 1
         trx_tables_locked: 1
          trx_lock_structs: 2
     trx_lock_memory_bytes: 1136
           trx_rows_locked: 3
         trx_rows_modified: 0
   trx_concurrency_tickets: 0
       trx_isolation_level: READ UNCOMMITTED
         trx_unique_checks: 1
    trx_foreign_key_checks: 1
trx_last_foreign_key_error: NULL
 trx_adaptive_hash_latched: 0
 trx_adaptive_hash_timeout: 0
          trx_is_read_only: 0
trx_autocommit_non_locking: 0
*************************** 2. row ***************************
                    trx_id: 14434
                 trx_state: RUNNING
               trx_started: 2017-09-03 14:00:24
     trx_requested_lock_id: NULL
          trx_wait_started: NULL
                trx_weight: 3
       trx_mysql_thread_id: 16
                 trx_query: NULL
       trx_operation_state: NULL
         trx_tables_in_use: 0
         trx_tables_locked: 1
          trx_lock_structs: 2
     trx_lock_memory_bytes: 1136
           trx_rows_locked: 1
         trx_rows_modified: 1
   trx_concurrency_tickets: 0
       trx_isolation_level: READ UNCOMMITTED
         trx_unique_checks: 1
    trx_foreign_key_checks: 1
trx_last_foreign_key_error: NULL
 trx_adaptive_hash_latched: 0
 trx_adaptive_hash_timeout: 0
          trx_is_read_only: 0
trx_autocommit_non_locking: 0
2 rows in set (0.00 sec)
```

可以看出，一个事务(Client1)处于RUNNING状态，另一个事务(Client2)处于锁定状态。且独占锁在写操作后并未释放，而是等到事务结束后才释放

## 4.2 Read committed(读已提交)

__实现方式__：

* 事务读数据的时候(读操作时才加锁而不是事务一开始就加锁)加__行级共享锁__，__读完释放__
* 事务写数据的时候(写操作时才加锁而不是事务一开始就加锁)加__行级独占锁__，__事务结束释放__

由于事务写操作加上独占锁，因此事务写操作时，读操作不能进行，因此，不能读到事务的未提交数据，避免了脏读问题，__但是由于读操作的锁加在读上面，而不是加在事务之上，所以，在同一事务的两次读操作之间可以插入其他事务的写操作，所以可能发生不可重复读的问题__

### 4.2.1 验证

可以很负责人的跟大家说，__MySQL中的READ COMMITTED隔离级别不单单是通过加锁实现的，实际上还有REPEATABLE READ隔离级别，其实这两个隔离级别效果的实现还需要一个辅助，这个辅助就是MVCC-多版本并发控制__，但其实它又不是严格意义上的多版本并发控制，是不是很懵，没关系，我们一一剖析

__测试工具__

1. mysql-5.7.16
1. bash

__准备工作__

```sql
CREATE TABLE test(
id INT NOT NULL AUTO_INCREMENT,
name VARCHAR(20) NOT NULL DEFAULT "",
PRIMARY KEY(id)
)Engine=InnoDB;

INSERT INTO test(name)
VALUES("张三");
```

__客户端1__
执行如下操作

```sql
SET autocommit = 0; -- 取消事务的自动提交

SELECT @@session.tx_isolation; -- 查看隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; -- 修改隔离级别
SELECT @@session.tx_isolation; -- 查看隔离级别

UPDATE test SET name = '张八' WHERE id =1;
```

输出如下

```sql
mysql> UPDATE test SET name = '张八' WHERE id =1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```

__客户端2__
执行如下操作

```sql
SET autocommit = 0; -- 取消事务的自动提交

SELECT @@session.tx_isolation; -- 查看隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; -- 修改隔离级别
SELECT @@session.tx_isolation; -- 查看隔离级别

BEGIN;
SELECT name FROM test WHERE id = 1;
```

输出如下

```sql
mysql> SELECT name FROM test WHERE id = 1;
+--------+
| name   |
+--------+
| 张三   |
+--------+
1 row in set (0.00 sec)
```

这里的读事务并没有按照预期那样阻塞，而是读到了写事务(Client1)事务开始前的数据。__因为内部使用了MVCC机制，实现了一致性非阻塞读，大大提高了并发读写效率，写不影响读，且读到的是记录的镜像版本__

## 4.3 MVCC机制剖析

在MySQL中`MVCC(Multi-Version Concurrency Control)`是在Innodb存储引擎中得到支持的，Innodb为每行记录都实现了三个隐藏字段：

1. 隐藏的ID
1. 6字节的事务ID（`DB_TRX_ID`）
1. 7字节的回滚指针（`DB_ROLL_PTR`）

MVCC在MySQL中的实现依赖的是`undo log`与`read view`

1. undo log：undo log中记录的是数据表记录行的多个版本，也就是事务执行过程中的回滚段，其实就是MVCC中的一行原始数据的多个版本镜像数据
1. read view：主要用来判断当前版本数据的可见性

undo log是为回滚而用，__具体内容就是copy事务前的数据库内容（行）到undo buffer__，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此

__行的更新过程__

1. 初始数据行
    * ![fig1](/images/数据库-事务隔离级别/fig1.jpeg)
    * F1～F6是某行列的名字，1～6是其对应的数据。后面三个隐含字段分别对应该行的事务号和回滚指针，假如这条数据是刚INSERT的，可以认为ID为1，其他两个字段为空
1. 事务1更改该行的各字段的值
    * ![fig2](/images/数据库-事务隔离级别/fig2.jpeg)
    * 当事务1更改该行的值时，会进行如下操作：
        * 用排他锁锁定该行
        * 记录redo log
        * 把该行修改前的值Copy到undo log，即上图中下面的行
        * 修改当前行的值，填写事务编号，使回滚指针指向undo log中的修改前的行
1. 事务2修改该行的值
    * ![fig3](/images/数据库-事务隔离级别/fig3.jpeg)
    * 与事务1相同，此时undo log，中有有两行记录，并且通过回滚指针连在一起

__read view判断当前版本数据项是否可见__：在innodb中，创建一个新事务（`trx_id_new`）的时候，innodb会将当前系统中的活跃事务列表（`trx_sys->trx_list`）创建一个副本（read view），副本中保存的是系统__当前不应该被本事务看到的其他事务id列表__。当用户在这个事务中要读取该行记录的时候，innodb会将该行当前的版本号与该read view进行比较。具体的算法如下:

* 设该行的当前事务id为`trx_id_0`，read view中最早的事务id为`trx_id_min`，最迟的事务id为`trx_id_max`，本次事务id为`trx_id_new`
1. 如果`trx_id_0 < trx_id_min`的话，那么表明该行记录所在的事务已经在本次新事务创建之前就提交了，所以该行记录的当前值是可见的。跳到步骤5.
1. 如果`trx_id_0 > trx_id_max`的话，那么表明该行记录所在的事务在本次新事务创建之后才开启，所以该行记录的当前值不可见.跳到步骤4
1. 如果`trx_id_min <= trx_id_0 <= trx_id_max`， 那么表明该行记录所在事务在本次新事务创建的时候处于活动状态，从`trx_id_min`到`trx_id_max`进行遍历，如果`trx_id_0`等于他们之中的某个事务id的话，那么不可见，跳到步骤4；否则跳到步骤5
1. 从该行记录的`DB_ROLL_PTR`指针所指向的回滚段中取出最新的undo-log的版本号，将它赋值该`trx_id_0`，然后跳到步骤1
1. 将该可见行的值返回

__事务隔离级别的影响__

1. `tx_isolation='READ-COMMITTED'`的一致性：只要当前语句执行前已经提交的数据都是可见的
1. `tx_isolation='REPEATABLE-READ'`的一致性：只要是当前事务执行前已经提交的数据都是可见的

## 4.4 Repeatable read(可重复读)

__实现方式__：

* 事务读数据的时候(读操作时才加锁而不是事务一开始就加锁)加__行级共享锁__，__事务结束释放__
* 事务写数据的时候(写操作时才加锁而不是事务一开始就加锁)加__行级独占锁__，__事务结束释放__

由于事务读操作在事务结束后才释放共享锁，因此可以避免在同一读事务中读取到不同的数据，另外可以避免第二类丢失更新的问题

### 4.4.1 验证

真实情况是：读不影响写，写不影响读

1. 读不影响写：事务以排他锁的形式修改原始数据，读时不加锁，因为MySQL在事务隔离级别Read committed 、Repeatable Read下，__InnoDB存储引擎采用非锁定性一致读__--即读取不占用和等待表上的锁。即采用的是MVCC中一致性非锁定读模式。因读时不加锁，所以不会阻塞其他事务在相同记录上加X锁来更改这行记录
1. 写不影响读：事务以排他锁的形式修改原始数据，当读取的行正在执行delete或者update 操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎会去读取行的一个快照数据

__测试工具__

1. mysql-5.7.16
1. bash

__准备工作__

```sql
CREATE TABLE test(
id INT NOT NULL AUTO_INCREMENT,
name VARCHAR(20) NOT NULL DEFAULT "",
PRIMARY KEY(id)
)Engine=InnoDB;

INSERT INTO test(name)
VALUES("张三");
```

__客户端1__
执行如下操作

```sql
SET autocommit = 0; -- 取消事务的自动提交

SELECT @@session.tx_isolation; -- 查看隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- 修改隔离级别
SELECT @@session.tx_isolation; -- 查看隔离级别

UPDATE test SET name = '张八' WHERE id =1;
```

输出如下

```sql
mysql> UPDATE test SET name = '张八' WHERE id =1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```

__客户端2__
执行如下操作

```sql
SET autocommit = 0; -- 取消事务的自动提交

SELECT @@session.tx_isolation; -- 查看隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- 修改隔离级别
SELECT @@session.tx_isolation; -- 查看隔离级别

BEGIN;
SELECT name FROM test WHERE id = 1;
```

输出如下

```sql
mysql> SELECT name FROM test WHERE id = 1;
+--------+
| name   |
+--------+
| 张三   |
+--------+
1 row in set (0.00 sec)
```

这里的读事务并没有按照预期那样阻塞，而是读到了写事务(Client1)事务开始前的数据。__因为内部使用了MVCC机制，实现了一致性非阻塞读，大大提高了并发读写效率，写不影响读，且读到的是记录的镜像版本__

## 4.5 Serializable(串行化)

__实现方式__：

* 事务读数据的时候(读操作时才加锁而不是事务一开始就加锁)加__表级共享锁__，__事务结束释放__
* 事务写数据的时候(写操作时才加锁而不是事务一开始就加锁)加__表级独占锁__，__事务结束释放__

### 4.5.1 验证

__测试工具__

1. mysql-5.7.16
1. bash

__准备工作__

```sql
CREATE TABLE test(
id INT NOT NULL AUTO_INCREMENT,
name VARCHAR(20) NOT NULL DEFAULT "",
PRIMARY KEY(id)
)Engine=InnoDB;

INSERT INTO test(name)
VALUES("张三");
```

__客户端1__
执行如下操作

```sql
SET autocommit = 0; -- 取消事务的自动提交

SELECT @@session.tx_isolation; -- 查看隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE; -- 修改隔离级别
SELECT @@session.tx_isolation; -- 查看隔离级别

UPDATE test SET name = '张八' WHERE id =1;
```

输出如下

```sql
mysql> UPDATE test SET name = '张八' WHERE id =1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```

__客户端2__
执行如下操作

```sql
SET autocommit = 0; -- 取消事务的自动提交

SELECT @@session.tx_isolation; -- 查看隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE; -- 修改隔离级别
SELECT @@session.tx_isolation; -- 查看隔离级别

BEGIN;
SELECT name FROM test WHERE id = 1;
```

此时Client2阻塞了，与预期一致

# 5 总结

| 隔离级别 | 是否出现脏读 | 是否出现不可重复读 | 是否出现幻读 | 是否出现第一类丢失更新 | 是否出现第二类丢失更新 |
|:--|:--|:--|:--|:--|:--|
| Serializable | 否 | 否 | 否 | 否 | 否 |
| Repeatable read | 否 | 否 | 是 | 否 | 否 |
| Read committed | 否 | 是 | 是 | 否 | 是 |
| Read uncommitted | 是 | 是 | 是 | 否 | 是 |

# 6 如何查看/修改隔离级别

__修改隔离级别__

```sql
SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}
```

* 默认的行为（不带session和global）是为下一个（未开始）事务设置隔离级别
* 如果你使用GLOBAL关键字，语句在全局对从那点开始创建的所有新连接（除了不存在的连接）设置默认事务级别。你需要SUPER权限来做这个
* 使用SESSION关键字为将来在当前连接上执行的事务设置默认事务级别。任何客户端都能自由改变会话隔离级别（甚至在事务的中间），或者为下一个事务设置隔离级别

__查询隔离级别__

```sql
SELECT @@global.tx_isolation;
SELECT @@session.tx_isolation;
SELECT @@tx_isolation;
```

# 7 死锁问题分析

__准备工作__

```sql
-- 将隔离级别设置为 RR
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ; 

CREATE TABLE test(
id INT NOT NULL AUTO_INCREMENT,
name VARCHAR(20) NOT NULL DEFAULT "",
PRIMARY KEY(id),
UNIQUE KEY `uk_name` (`name`)
)Engine=InnoDB;

INSERT INTO test(name)
VALUES("member1");
INSERT INTO test(name)
VALUES("member2");
INSERT INTO test(name)
VALUES("member3");
```

```sql
mysql> SELECT * FROM test;
+----+---------+
| id | name    |
+----+---------+
|  1 | member1 |
|  2 | member2 |
|  3 | member3 |
+----+---------+
3 rows in set (0.00 sec)
```

下面构造死锁场景

```plantuml
skinparam backgroundColor #EEEBDC
skinparam handwritten true

skinparam sequence {
	ArrowColor DeepSkyBlue
	ActorBorderColor DeepSkyBlue
	LifeLineBorderColor blue
	LifeLineBackgroundColor #A9DCDF
	
	ParticipantBorderColor DeepSkyBlue
	ParticipantBackgroundColor DodgerBlue
	ParticipantFontName Impact
	ParticipantFontSize 17
	ParticipantFontColor #A9DCDF
	
	ActorBackgroundColor aqua
	ActorFontColor DeepSkyBlue
	ActorFontSize 17
	ActorFontName Aapex
}

participant "事务1" as tx1
participant "事务2" as tx2

tx2->tx2: BEGIN;
tx2->tx2: DELETE FROM test WHERE name = 'member2';
tx1->tx1: BEGIN;
tx1->tx1: DELETE FROM test WHERE name = 'member2';\n这里会阻塞住
tx2->tx2: INSERT INTO test (id, name) VALUES (5, 'member2');
tx1->tx1: 提示出现死锁：\nERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

__接下来使用`SHOW ENGINE INNODB STATUS;`命令可以查看死锁日志__

```sql
SHOW ENGINE INNODB STATUS;

-- ... 省略无关部分

------------------------
LATEST DETECTED DEADLOCK
------------------------
2020-02-29 20:00:36 0x70000839a000
*** (1) TRANSACTION:
TRANSACTION 15917, ACTIVE 9 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 2, OS thread handle 123145440026624, query id 45 localhost root updating
-- 此时事务1正执行下面的语句
DELETE FROM test WHERE name = 'member2'
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
-- 事务1排队获取索引uk_name的排它锁（lock_mode X）
RECORD LOCKS space id 156 page no 4 n bits 72 index uk_name of table `deadlock`.`test` trx id 15917 lock_mode X waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 32
 0: len 7; hex 6d656d62657232; asc member2;;
 1: len 4; hex 80000002; asc     ;;

*** (2) TRANSACTION:
TRANSACTION 15912, ACTIVE 22 sec inserting
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1136, 3 row lock(s), undo log entries 2
MySQL thread id 3, OS thread handle 123145440305152, query id 46 localhost root update
-- 此时事务2正执行下面的语句
INSERT INTO test (id, name) VALUES (5, 'member2')
*** (2) HOLDS THE LOCK(S):
-- 此刻，事务2已经获取了索引uk_name的排它锁（lock_mode X），该排他锁是事务2在执行delete语句时获取的
RECORD LOCKS space id 156 page no 4 n bits 72 index uk_name of table `deadlock`.`test` trx id 15912 lock_mode X locks rec but not gap
Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 32
 0: len 7; hex 6d656d62657232; asc member2;;
 1: len 4; hex 80000002; asc     ;;

-- 同时，事务2排队获取索引uk_name的共享锁（lock mode S），insert语句在普通情况下会申请所有索引的排它锁，但是这里出现了共享锁，因为uk_name索引是一个唯一索引，所以insert语句会在插入前进行一次duplicate key的检查，为了使这次检查成功，需要申请uk_name索引的共享锁，防止其他事务对name字段的修改。
-- 但是对uk_name索引的锁的申请是需要排队的，而事务1在此之前已经申请uk_name索引的排它锁，所以本次申请必须等待，因此形成了循环，死锁出现了
*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 156 page no 4 n bits 72 index uk_name of table `deadlock`.`test` trx id 15912 lock mode S waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 32
 0: len 7; hex 6d656d62657232; asc member2;;
 1: len 4; hex 80000002; asc     ;;

*** WE ROLL BACK TRANSACTION (1)

-- ... 省略无关部分
```

# 8 参考

* [数据库事务隔离级别和锁的实现方式](http://blog.csdn.net/yangtianyu1218/article/details/51543634)
* [第一类第二类丢失更新](http://blog.csdn.net/lqglqglqg/article/details/48582905)
* [数据库事务隔离级别-- 脏读、幻读、不可重复读（清晰解释）](http://blog.csdn.net/jiesa/article/details/51317164)
* [数据库事务特征、数据库隔离级别，以及各级别数据库加锁情况(含实操)--read uncommitted篇](http://www.jianshu.com/p/d75fcdeb07a3)
* [数据库事务特征、数据库隔离级别，各级别数据库加锁情况(含实操)--read committed && MVCC](http://www.jianshu.com/p/fd51cb8dc03b)
* [数据库事务特征、数据库隔离级别，各级别数据库加锁情况(含实操)--Repeatable Read && MVCC](http://www.jianshu.com/p/814cf518f88d)
* [MVCC原理探究及MySQL源码实现分析](https://blog.csdn.net/joy0921/article/details/80128857)
* [Mysql加锁过程详解](http://www.cnblogs.com/metoy/p/5545580.html)
* [Innodb中的事务隔离级别实现原理](http://blog.csdn.net/matt8/article/details/53096405)
* [MySQL数据库事务各隔离级别加锁情况--read committed && MVCC](http://www.imooc.com/article/17290)
* [记录一次Mysql死锁排查过程](https://blog.51cto.com/14257804/2390505?cid=732583)
* [一分钟理清Mysql的锁类型——《深究Mysql锁》](https://blog.csdn.net/zcl_love_wx/article/details/82052479)
* [InnoDB locking](https://github.com/octachrome/innodb-locks)