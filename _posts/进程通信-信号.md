---
title: 进程通信-信号
date: 2017-08-08 21:15:01
tags: 
- 摘录
categories: 
- Operating System
- Process
---

__阅读更多__

<!--more-->

# 1 信号(sinal)

## 1.1 什么是信号

用过Windows的我们都知道，当我们无法正常结束一个程序时，可以用任务管理器强制结束这个进程，但这其实是怎么实现的呢？同样的功能在Linux上是通过生成信号和捕获信号来实现的，运行中的进程捕获到这个信号然后作出一定的操作并最终被终止

信号是UNIX和Linux系统响应某些条件而产生的一个事件，接收到该信号的进程会相应地采取一些行动。通常信号是由一个错误产生的。__但它们还可以作为进程间通信或修改行为的一种方式，明确地由一个进程发送给另一个进程。一个信号的产生叫生成，接收到一个信号叫捕获。__

__软中断信号（signal，又简称为信号）__用来通知进程发生了异步事件。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。__注意，信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据。__

收到信号的进程对各种信号有不同的处理方法。处理方法可以分为三类：

1. 第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理
1. 第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样
1. 第三种方法是，对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为

在进程表的表项中有一个软中断信号域，该域中每一位对应一个信号，当有信号发送给进程时，对应位置位。由此可以看出，进程对不同的信号可以同时保留，但对于同一个信号，进程并不知道在处理之前来过多少个。 

## 1.2 信号的种类

信号的名称是在头文件signal.h中定义的，信号都以SIG开头，常用的信号并不多，常用的信号如下：

1. `SIGALRM`：由alarm函数设置的定时器产生
1. `SIGHUP`：由一个处于非连接状态的终端发送给控制进程，或者由控制进程在自身结束时发送给每个前台进程
1. `SIGINT`：一般由从终端敲入Ctrl+C组合键或预先设置好的中断字符产生
1. `SIGKILL`：因为这个信号不能被捕获或忽略，所以一般在shell中用它来强制终止异常进程
1. `SIGPIPE`：如果在向管道写数据时没有与之对应的读进程，就会产生这个信号
1. `SIGTERM`：作为一个请求被发送，要求进程结束运行。UNIX在关机时用这个信号要求系统服务停止运行。它是kill命令默认发送的信号
1. `SIGUSR1,SIGUSR2`：进程之间可以用这个信号进行通信，例如让进程报告状态信息等

## 1.3 信号产生条件

1. 用户在终端按下某些键时，终端驱动程序会发送信号给前台进程，例如Ctrl-C产生SIGINT信号，Ctrl-/产生SIGQUIT信号，Ctrl-Z产生SIGTSTP信号
1. 硬件异常产生信号，__这些条件由硬件检测到并通知内核，然后内核向当前进程发送适当的信号__。例如当前进程执行了除以0的指令，CPU的运算单元会产生异常，内核将这个异常解释为SIGFPE信号发送给进程。再比如当前进程访问了非法内存地址，MMU会产生异常，内核将这个异常解释为SIGSEGV信号发送给进程
1. 一个进程调用kill(2)函数可以发送信号给另一个进程
1. 可以用kill(1)命令发送信号给某个进程，kill(1)命令也是调用kill(2)函数实现的，如果不明确指定信号则发送SIGTERM信号，该信号的默认处理动作是终止进程
1. 当内核检测到某种软件条件发生时也可以通过信号通知进程，例如闹钟超时产生SIGALRM信号，向读端已关闭的管道写数据时产生SIGPIPE信号

## 1.4 信号与中断的区别

中断可以理解为CPU和OS kernel之间的通信。信号可以理解为OS kernel与进程之间的通信

中断如何产生

1. __异常__：例如缺页异常、除零异常等
1. __硬件中断__
1. __系统调用__

这些中断由CPU来处理，CPU会中断当前任务，并且通过OS kernel提供的相应处理程序来进行处理

信号如何产生

1. 由OS kernel产生，例如SIGFPE，SIGSEGV，SIGIO等
1. 由用户进程产生，例如kill()

这些信号最终由OS kernel处理，会将这些信号传递给目标线程/进程，调用响应的信号处理方法来进行处理

# 2 信号的实现机制

接下来我们将介绍内核如何实现信号机制。即内核如何向一个进程发送信号、进程如何接收一个信号、进程怎样控制自己对信号的反应、内核在什么时机处理和怎样处理进程收到的信号。还要介绍一下setjmp和longjmp在信号中起到的作用

## 2.1 内核对信号的基本处理方法

__内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。__这里要补充的是，如果信号发送给一个正在睡眠的进程，那么要看该进程进入睡眠的优先级，如果进程睡眠在可被中断的优先级上，则唤醒进程；否则仅设置进程表中信号域相应的位，而不唤醒进程。__这一点比较重要，因为进程检查是否收到信号的时机是：一个进程在即将从内核态返回到用户态时；或者，在一个进程要进入或离开一个适当的低调度优先级睡眠状态时。__

__内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。__所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号

内核处理一个进程收到的软中断信号是在该进程的上下文中，因此，进程必须处于运行状态。前面介绍概念的时候讲过，处理信号有三种类型：进程接收到信号后退出；进程忽略该信号；进程收到信号后执行用户设定用系统调用signal的函数。当进程接收到一个它忽略的信号时，进程丢弃该信号，就象没有收到该信号似的继续运行。如果进程收到一个要捕捉的信号，那么进程从内核态返回用户态时执行用户定义的函数。__而且执行用户定义的函数的方法很巧妙，内核是在用户栈上创建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回弹出栈顶时就返回到用户定义的函数处，从函数返回再弹出栈顶时，才返回原先进入内核的地方。__这样做的原因是用户定义的处理函数不能且不允许在内核态下执行（如果用户定义的函数在内核态下运行的话，用户就可以获得任何权限）

__在信号的处理方法中有几点特别要引起注意__

1. 第一，在一些系统中，当一个进程处理完中断信号返回用户态之前，内核清除用户区中设定的对该信号的处理例程的地址，即下一次进程对该信号的处理方法又改为默认值，除非在下一次信号到来之前再次使用signal系统调用。这可能会使得进程在调用signal之前又得到该信号而导致退出。在BSD中，内核不再清除该地址。但不清除该地址可能使得进程因为过多过快的得到某个信号而导致堆栈溢出。为了避免出现上述情况。在BSD系统中，内核模拟了对硬件中断的处理方法，即在处理某个中断时，阻止接收新的该类中断
1. 第二个要引起注意的是，__如果要捕捉的信号发生于进程正在一个系统调用中时，并且该进程睡眠在可中断的优先级上，这时该信号引起进程作一次longjmp，跳出睡眠状态，返回用户态并执行信号处理例程。__当从信号处理例程返回时，进程就象从系统调用返回一样，但返回了一个错误代码，指出该次系统调用曾经被中断。这要注意的是，BSD系统中内核可以自动地重新开始系统调用
1. 第三个要注意的地方：__若进程睡眠在可中断的优先级上，则当它收到一个要忽略的信号时，该进程被唤醒，但不做longjmp，一般是继续睡眠。__但用户感觉不到进程曾经被唤醒，而是象没有发生过该信号一样
1. 第四个要注意的地方：内核对子进程终止（SIGCLD）信号的处理方法与其他信号有所区别。当进程检查出收到了一个子进程终止的信号时，缺省情况下，该进程就象没有收到该信号似的，如果父进程执行了系统调用wait，进程将从系统调用wait中醒来并返回wait调用，执行一系列wait调用的后续操作（找出僵死的子进程，释放子进程的进程表项），然后从wait中返回。SIGCLD信号的作用是唤醒一个睡眠在可被中断优先级上的进程。如果该进程捕捉了这个信号，就象普通信号处理一样转到处理例程。如果进程忽略该信号，那么系统调用wait的动作就有所不同，因为SIGCLD的作用仅仅是唤醒一个睡眠在可被中断优先级上的进程，那么执行wait调用的父进程被唤醒继续执行wait调用的后续操作，然后等待其他的子进程

如果一个进程调用signal系统调用，并设置了SIGCLD的处理方法，并且该进程有子进程处于僵死状态，则内核将向该进程发一个SIGCLD信号

## 2.2 setjmp和longjmp的作用

前面在介绍信号处理机制时，多次提到了setjmp和longjmp，但没有仔细说明它们的作用和实现方法。这里就此作一个简单的介绍

在介绍信号的时候，我们看到多个地方要求进程在检查收到信号后，从原来的系统调用中直接返回，而不是等到该调用完成。这种进程突然改变其上下文的情况，就是使用setjmp和longjmp的结果。setjmp将保存的上下文存入用户区，并继续在旧的上下文中执行。这就是说，进程执行一个系统调用，当因为资源或其他原因要去睡眠时，内核为进程作了一次setjmp，如果在睡眠中被信号唤醒，进程不能再进入睡眠时，内核为进程调用longjmp，该操作是内核为进程将原先setjmp调用保存在进程用户区的上下文恢复成现在的上下文，这样就使得进程可以恢复等待资源前的状态，而且内核为setjmp返回1，使得进程知道该次系统调用失败。这就是它们的作用

# 3 信号的使用

## 3.1 信号的处理--signal函数

首先看一下signal函数的声明

```c
#include <signal.h>  
void (*signal(int sig, void (*func)(int)))(int);  
```

signal是一个带有sig和func两个参数的函数，其中func是一个类型为void (*)(int)的函数指针。该函数返回一个与func相同类型的指针，指向先前指定信号处理函数的函数指针。准备捕获的信号的参数由sig给出，接收到的指定信号后要调用的函数由参数func给出。其实这个函数的使用是相当简单的，通过下面的例子就可以知道。注意信号处理函数的原型必须为void func（int），或者是下面的特殊值：

1. `SIG_IGN`：忽略信号
1. `SIG_DFL`：恢复信号的默认行为

__小例子__：

```c
#include <signal.h>  
#include <stdio.h>  
#include <unistd.h>  
  
void ouch(int sig)  
{  
    printf("\nOUCH! - I got signal %d\n", sig);  
    //恢复终端中断信号SIGINT的默认行为  
    (void) signal(SIGINT, SIG_DFL);  
}  
  
int main()  
{  
    //改变终端中断信号SIGINT的默认行为，使之执行ouch函数  
    //而不是终止程序的执行  
    (void) signal(SIGINT, ouch);  
    while(1)  
    {  
        printf("Hello World!\n");  
        sleep(1);  
    }  
    return 0;  
}  
```

输出结果

```
Hello World!
Hello World!
Hello World!
^C
OUCH! - I got signal 2
Hello World!
Hello World!
^C
```

# 4 参考

* [Linux进程间通信——使用信号](http://blog.csdn.net/ljianhui/article/details/10128731)
* [Signals and interrupts a comparison](https://stackoverflow.com/questions/13341870/signals-and-interrupts-a-comparison)
* [信号和中断的比较 + 中断和异常的比较](http://www.cnblogs.com/charlesblc/p/6277810.html)
* [linux signal信号处理过程与机制--完全实例讲解](http://blog.csdn.net/lee244868149/article/details/38708943)
