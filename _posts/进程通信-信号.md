---
title: 进程通信-信号
date: 2017-08-08 21:15:01
tags: 
- 摘录
categories: 
- 操作系统
- 进程
---

__目录__

<!-- toc -->
<!--more-->

# 1 信号(sinal)

## 1.1 什么是信号

用过Windows的我们都知道，当我们无法正常结束一个程序时，可以用任务管理器强制结束这个进程，但这其实是怎么实现的呢？同样的功能在Linux上是通过生成信号和捕获信号来实现的，运行中的进程捕获到这个信号然后作出一定的操作并最终被终止。

信号是UNIX和Linux系统响应某些条件而产生的一个事件，接收到该信号的进程会相应地采取一些行动。通常信号是由一个错误产生的。__但它们还可以作为进程间通信或修改行为的一种方式，明确地由一个进程发送给另一个进程。一个信号的产生叫生成，接收到一个信号叫捕获。__

## 1.2 信号的种类

信号的名称是在头文件signal.h中定义的，信号都以SIG开头，常用的信号并不多，常用的信号如下：

1. `SIGALRM`：由alarm函数设置的定时器产生
1. `SIGHUP`：由一个处于非连接状态的终端发送给控制进程，或者由控制进程在自身结束时发送给每个前台进程
1. `SIGINT`：一般由从终端敲入Ctrl+C组合键或预先设置好的中断字符产生
1. `SIGKILL`：因为这个信号不能被捕获或忽略，所以一般在shell中用它来强制终止异常进程
1. `SIGPIPE`：如果在向管道写数据时没有与之对应的读进程，就会产生这个信号
1. `SIGTERM`：作为一个请求被发送，要求进程结束运行。UNIX在关机时用这个信号要求系统服务停止运行。它是kill命令默认发送的信号
1. `SIGUSR1,SIGUSR2`：进程之间可以用这个信号进行通信，例如让进程报告状态信息等

# 2 信号的使用

## 2.1 信号的处理--signal函数

首先看一下signal函数的声明

```C
#include <signal.h>  
void (*signal(int sig, void (*func)(int)))(int);  
```

signal是一个带有sig和func两个参数的函数，其中func是一个类型为void (*)(int)的函数指针。该函数返回一个与func相同类型的指针，指向先前指定信号处理函数的函数指针。准备捕获的信号的参数由sig给出，接收到的指定信号后要调用的函数由参数func给出。其实这个函数的使用是相当简单的，通过下面的例子就可以知道。注意信号处理函数的原型必须为void func（int），或者是下面的特殊值：

1. `SIG_IGN`：忽略信号
1. `SIG_DFL`：恢复信号的默认行为

__小例子__：

```C
#include <signal.h>  
#include <stdio.h>  
#include <unistd.h>  
  
void ouch(int sig)  
{  
    printf("\nOUCH! - I got signal %d\n", sig);  
    // 恢复终端中断信号SIGINT的默认行为  
    (void) signal(SIGINT, SIG_DFL);  
}  
  
int main()  
{  
    // 改变终端中断信号SIGINT的默认行为，使之执行ouch函数  
    // 而不是终止程序的执行  
    (void) signal(SIGINT, ouch);  
    while(1)  
    {  
        printf("Hello World!\n");  
        sleep(1);  
    }  
    return 0;  
}  
```

输出结果

```
Hello World!
Hello World!
Hello World!
^C
OUCH! - I got signal 2
Hello World!
Hello World!
^C
```

# 3 信号产生条件

1. 用户在终端按下某些键时，终端驱动程序会发送信号给前台进程，例如Ctrl-C产生SIGINT信号，Ctrl-/产生SIGQUIT信号，Ctrl-Z产生SIGTSTP信号。
1. 硬件异常产生信号，__这些条件由硬件检测到并通知内核，然后内核向当前进程发送适当的信号__。例如当前进程执行了除以0的指令，CPU的运算单元会产生异常，内核将这个异常解释为SIGFPE信号发送给进程。再比如当前进程访问了非法内存地址，MMU会产生异常，内核将这个异常解释为SIGSEGV信号发送给进程。
1. 一个进程调用kill(2)函数可以发送信号给另一个进程。
1. 可以用kill(1)命令发送信号给某个进程，kill(1)命令也是调用kill(2)函数实现的，如果不明确指定信号则发送SIGTERM信号，该信号的默认处理动作是终止进程。
1. 当内核检测到某种软件条件发生时也可以通过信号通知进程，例如闹钟超时产生SIGALRM信号，向读端已关闭的管道写数据时产生SIGPIPE信号。

# 4 信号与中断的区别

中断可以理解为CPU和OS kernel之间的通信。信号可以理解为OS kernel与进程之间的通信。

中断如何产生

1. __异常__：例如缺页异常、除零异常等
1. __硬件中断__
1. __系统调用__

这些中断由CPU来处理，CPU会中断当前任务，并且通过OS kernel提供的相应处理程序来进行处理

信号如何产生

1. 由OS kernel产生，例如SIGFPE，SIGSEGV，SIGIO等
1. 由用户进程产生，例如kill()

这些信号最终由OS kernel处理，会将这些信号传递给目标线程/进程，调用响应的信号处理方法来进行处理

# 5 参考

* [Linux进程间通信——使用信号](http://blog.csdn.net/ljianhui/article/details/10128731)
* [Signals and interrupts a comparison](https://stackoverflow.com/questions/13341870/signals-and-interrupts-a-comparison)
* [信号和中断的比较 + 中断和异常的比较](http://www.cnblogs.com/charlesblc/p/6277810.html)
