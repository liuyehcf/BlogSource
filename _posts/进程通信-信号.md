---
title: 进程通信-信号
date: 2017-08-08 21:15:01
tags: 
- 摘录
categories: 
- 操作系统
- 进程
---

__目录__

<!-- toc -->
<!--more-->

# 1 信号(sinal)

## 1.1 什么是信号

用过Windows的我们都知道，当我们无法正常结束一个程序时，可以用任务管理器强制结束这个进程，但这其实是怎么实现的呢？同样的功能在Linux上是通过生成信号和捕获信号来实现的，运行中的进程捕获到这个信号然后作出一定的操作并最终被终止。

信号是UNIX和Linux系统响应某些条件而产生的一个事件，接收到该信号的进程会相应地采取一些行动。通常信号是由一个错误产生的。__但它们还可以作为进程间通信或修改行为的一种方式，明确地由一个进程发送给另一个进程。一个信号的产生叫生成，接收到一个信号叫捕获。__

## 1.2 信号的种类

信号的名称是在头文件signal.h中定义的，信号都以SIG开头，常用的信号并不多，常用的信号如下：

1. `SIGALRM`：由alarm函数设置的定时器产生
1. `SIGHUP`：由一个处于非连接状态的终端发送给控制进程，或者由控制进程在自身结束时发送给每个前台进程
1. `SIGINT`：一般由从终端敲入Ctrl+C组合键或预先设置好的中断字符产生
1. `SIGKILL`：因为这个信号不能被捕获或忽略，所以一般在shell中用它来强制终止异常进程
1. `SIGPIPE`：如果在向管道写数据时没有与之对应的读进程，就会产生这个信号
1. `SIGTERM`：作为一个请求被发送，要求进程结束运行。UNIX在关机时用这个信号要求系统服务停止运行。它是kill命令默认发送的信号
1. `SIGUSR1,SIGUSR2`：进程之间可以用这个信号进行通信，例如让进程报告状态信息等

# 2 信号的使用

## 2.1 信号的处理--signal函数

首先看一下signal函数的声明

```C
#include <signal.h>  
void (*signal(int sig, void (*func)(int)))(int);  
```

signal是一个带有sig和func两个参数的函数，其中func是一个类型为void (*)(int)的函数指针。该函数返回一个与func相同类型的指针，指向先前指定信号处理函数的函数指针。准备捕获的信号的参数由sig给出，接收到的指定信号后要调用的函数由参数func给出。其实这个函数的使用是相当简单的，通过下面的例子就可以知道。注意信号处理函数的原型必须为void func（int），或者是下面的特殊值：

1. `SIG_IGN`：忽略信号
1. `SIG_DFL`：恢复信号的默认行为

__小例子__：

```C
#include <signal.h>  
#include <stdio.h>  
#include <unistd.h>  
  
void ouch(int sig)  
{  
    printf("\nOUCH! - I got signal %d\n", sig);  
    // 恢复终端中断信号SIGINT的默认行为  
    (void) signal(SIGINT, SIG_DFL);  
}  
  
int main()  
{  
    // 改变终端中断信号SIGINT的默认行为，使之执行ouch函数  
    // 而不是终止程序的执行  
    (void) signal(SIGINT, ouch);  
    while(1)  
    {  
        printf("Hello World!\n");  
        sleep(1);  
    }  
    return 0;  
}  
```

输出结果

```
Hello World!
Hello World!
Hello World!
^C
OUCH! - I got signal 2
Hello World!
Hello World!
^C
```

# 3 参考

* [Linux进程间通信——使用信号](http://blog.csdn.net/ljianhui/article/details/10128731)
