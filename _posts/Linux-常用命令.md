---
title: Linux-常用命令
date: 2017-08-15 20:17:57
tags: 
- 摘录
categories: 
- 操作系统
- Linux
---

__阅读更多__

<!--more-->

# 1 字符串处理命令

## 1.1 sed

__格式：__

* `sed [-nefr] [动作] [文件]`
* `STD IN | sed [-nefr] [动作]`

__参数说明：__

* `-n`：使用安静(silent)模式，在一般sed中，所有来自STDIN的数据一般都会被列到屏幕上，加了参数-n后，只有经过sed特殊处理的那一行才会被列出来
* `-e`：直接在命令行模式上进行sed的动作编辑
* `-f`：直接将sed的动作写在一个文件内，`-f filenmae`则可以执行filename内的sed动作
* `-r`：sed的动作支持的是扩展正则表达式的语法
* `-i`：直接修改读取的文件内容，而不是由屏幕输出

__动作说明，格式为`[n1 [,n2]]function`，接的动作必须以两个单引号括住__

* `a`：新增，a的后面可接字符串，而这些字符串会在新的一行出现(目前行的下一行)
* `c`：替换，c的后面可接字符串，这些字符串可以替换n1,n2之间的行
* `d`：删除，后面通常不接任何参数
* `i`：插入，i的后面可接字符串，而这些字符串会在新的一行出现(目前行的上一行)
* `p`：打印，也就是将某个选择的数据打印出来，通常p会与参数sed -n一起运行
* `s`：替换，可以直接进行替换的工作，通常这个s可以搭配正则表达式，例如1,20s/lod/new/g  (跟vim里面的很像！！！)

__示例：__

* `sed '2d' example`  <==删除example文件第二行
* `sed '2,$d' example`  <==删除第二至最后一行(注意这里$是代表最后一行的意思，而vim里面的操作以及正则表达式中$都代表行末)
* `sed '$d' example`  <==删除example文件最后一行
* `sed '/test/d' example`   <==删除example文件包含test的所有行
* `sed 's/test/mytest/g' example`  <==在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest
* `sed -n 's/^test/mytest/p' example`  <==(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它
* `sed 's/^192.168.0.1/&localhost/' example`  <==&符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1localhost
* `sed -n 's/\(love\)able/\1rs/p' example`  <==love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来
    * __sed正则表达式也支持组的概念（支持并列和嵌套），但是没有第0组__
    * __组就是放置在圆括号之内的子模式，组的序号取决于它左侧的括号数（只计算`(`）__
* `sed -n '/test/,/check/p' example`  <==所有在test和check所确定的范围内的行都被打印。逗号作用：选定行的范围
* `sed -n '5,/^test/p' example`  <==打印从第五行开始到第一个包含以test开始的行之间的所有行
* `sed '/test/,/check/s/$/sed test/' example`  <==对于模板test和west之间的行，每行的末尾用字符串sed test替换

__注意：__在macOS中，`-i`参数后面要跟一个扩展符，用于备份源文件。如果扩展符长度是0，那么不进行备份

* `sed -i ".back" "s/a/b/g" example`：备份文件为`example.back`
* `sed -i "" "s/a/b/g" example`：不备份

## 1.2 awk

相比于sed(管道命令)常常作用于一整行的处理，awk(管道命令)则比较倾向于将一行分成数个"字段"来处理，因此awk相当适合处理小型的数据处理

__格式：__

* `awk [-F] '条件类型1{动作1} 条件类型2{动作2}...' [filename]`

__参数说明：__

* `-F`：后接分隔符。例如：`-F ':'`、`-F '[,.;]'`

注意awk后续的所有动作都是以单引号括住的，而且如果以print打印时，非变量的文字部分，包括格式等(例如制表`\t`、换行`\n`等)都需要以双引号的形式定义出来，因为单引号已经是awk的命令固定用法了。例如`last -n 5 | awk '{print $1 "\t" $3}'`

__awk处理流程：__

1. 读入第一行，并将第一行的数据填入$0,$1,...等变量中
1. 依据条件类型的限制，判断是否需要进行后面的动作
1. 做完所有的动作与条件类型
1. 若还有后续的'行'，重复上面的步骤，直到所有数据都读取完为止

__awk内置变量：__

* ARGC：命令行参数个数
* ARGV：命令行参数排列
* ENVIRON：支持队列中系统环境变量的使用
* FILENAME：awk浏览的文件名
* FNR：浏览文件的记录数
* __FS：设置输入域分隔符，默认是空格键，等价于命令行 -F选项__
* __NF：每一行($0)拥有的字段总数__
* __NR：目前awk所处理的是第几行__
* OFS：输出域分隔符
* ORS：输出记录分隔符
* RS：控制记录分隔符
* 在动作内部引用这些变量不需要用$，例如`last -n 5 | awk '{print $1 "\t  lines: " NR "\t columes: " NF}'`
* 此外，$0变量是指整条记录。$1表示当前行的第一个域，$2表示当前行的第二个域，以此类推

__动作说明：__

* 所有awk的动作，即在{}内的动作，如果有需要多个命令辅助时，可以用分号";"间隔，或者直接以[Enter]按键来隔开每个命令

__BEGIN与END__

* 在Unix awk中两个特别的表达式，BEGIN和END，这两者都可用于pattern中（参考前面的awk语法），__提供BEGIN和END的作用是给程序赋予初始状态和在程序结束之后执行一些扫尾的工作。__
* __任何在BEGIN之后列出的操作（在{}内）将在Unix awk开始扫描输入之前执行，而END之后列出的操作将在扫描完全部的输入之后执行。__因此，通常使用BEGIN来显示变量和预置（初始化）变量，使用END来输出最终结果

__print与printf__

* print会打印换行符
* printf不会打印换行符

__示例：__

* `cat /etc/passwd | awk '{FS=":"} $3<10 {print $1 "\t" $3}'`，__注意`{FS=":"}`是作为一个动作存在的，因此从第二行开始分隔符才变为":"，第一行分隔符仍然是空格__
* `cat /etc/passwd | awk 'BEGIN {FS=":"} $3<10 {print $1 "\t" $3}'`。__这样写`{FS=":"}`在处理第一行时也会生效__
* 
```shell
awk 
'BEGIN {FS=":";print "统计销售金额";total=0} 
{print $3;total=total+$3;} 
END {print "销售金额总计：",total}' sx
```

### 1.2.1 如何在awk中引用变量

__方式1__

* 以`'"`和`"'`（即，单引号+双引号+shell变量+双引号+单引号）将shell变量包围起来
* __这种方式只能引用数值变量__

```sh
var=4
awk 'BEGIN{print '"$var"'}'
```

__方式2__

* 以`"'`和`'"`（即，双引号+单引号+shell变量+单引号+双引号）将shell变量包围起来
* __这种方式可以引用字符串型变量，但是字符串不允许包含空格__

```sh
var=4
awk 'BEGIN{print "'$var'"}'
var="abc"
awk 'BEGIN{print "'$var'"}'
```

__方式3__

* 用`"'"`（即，双引号+单引号+双引号+shell变量+双引号+单引号+双引号）将shell变量包裹起来
* __这种方式允许引用任意类型的变量__

```sh
var=4
awk 'BEGIN{print "'"$var"'"}'
var="abc"
awk 'BEGIN{print "'"$var"'"}'
var="this a test"
awk 'BEGIN{print "'"$var"'"}'
```

__方式4__

* 使用`-v`参数，变量不是很多的时候，这种方式也蛮简介清晰的

```sh
var="this a test"
awk -v awkVar="$var" 'BEGIN{print awkVar}'
```

### 1.2.2 在awk中写简单的控制流语句

__以下的示例都在BEGIN中，只执行一次，不需要指定文件或者输入流__

__if语句__
```sh
awk 'BEGIN{ 
test=100;
if(test>90)
{
    print "very good";
}
else if(test>60)
{
    print "good";
}
else
{
    print "no pass";
}
}'
```

__while语句__
```sh
awk 'BEGIN{ 
test=100;
total=0;
while(i<=test)
{
    total+=i;
    i++;
}
print total;
}'
```

__for语句__
```sh
awk 'BEGIN{ 
for(k in ENVIRON)
{
    print k"="ENVIRON[k];
}
}'

awk 'BEGIN{ 
total=0;
for(i=0;i<=100;i++)
{
    total+=i;
}
print total;
}'
```

__do语句__
```sh
awk 'BEGIN{ 
total=0;
i=0;
do
{
    total+=i;
    i++;
}while(i<=100)
print total;
}'
```

## 1.3 grep

grep分析一行信息，若当前有我们所需要的信息，就将该行拿出来

__格式：__

* `grep [-acinvrAB] [--color=auto] '查找的字符串' filename`

__参数说明：__

* `-a`：将binary文件以text文件的方式查找数据
* `-c`：计算找到'查找字符串'的次数
* `-i`：忽略大小写的不同
* `-n`：顺便输出行号
* `-v`：反向选择，即输出没有'查找字符串'内容的哪一行
* `-r`：在指定目录中递归查找
* `--color=auto`：将找到的关键字部分加上颜色
* `-A`：后面可加数字，为after的意思，除了列出该行外，后面的n行也列出来
* `-B`：后面可加数字，为before的意思，除了列出该行外，前面的n行也列出来

__示例：__

* `grep -r [--color=auto] '查找的字符串' [目录名]`

# 2 查找

## 2.1 find

__格式：__

* `find [文件路径] [option] [action]`

__参数说明：__

* `-name`：后接文件名，支持通配符。__注意匹配的是相对路径__
* `-regex`：后接正则表达式，__注意匹配的是完整路径__

__示例：__

* `find . -name "*.c"`
* `find . -regex ".*/.*\.c"`

# 3 文件压缩

## 3.1 tar

__格式：__

* 压缩：`tar -jcv -f [压缩创建的文件(*.tar.bz2)] [被压缩的文件或目录1] [被压缩的文件或目录2]...`
* 查询：`tar -jtv -f [压缩文件(*.tar.bz2)]`
* 解压缩：`tar -jxv -f [压缩文件(*.tar.bz2)] -C [欲解压的目录]`

__参数说明：__

* `-c`：新建打包文件，可以搭配-v查看过程中被打包的文件名
* `-t`：查看打包文件的内容含有那些文件名，终点在查看文件
* `-x`：解打包或解压缩的功能，可搭配-C在特定目录解开
* __注意，c t x是互斥的__
* `-j`：通过bzip2的支持进行压缩/解压，此时文件名最好为*.tar.bz2
* `-z`：通过gzip的支持进行压缩/解压，此时文件名最好是*.tar.gz
* `-v`：在压缩/解压缩过程中，将正在处理的文件名显示出来
* `-f` filename：-f后面接要被处理的文件名，建议-f单独写一个参数
* `-C` [目录名]：用于在解压时指定解压目录
* `-p`：保留备份数据原本权限与属性，常用语备份(-c)重要的配置文件
* `-P`：保留绝对路径，即允许备份数据中含有根目录存在之意

# 4 文件系统

## 4.1 tree

__格式：__

* `tree [option]`

__参数说明：__

* `-N`：显示非ASCII字符，可以显示中文

# 5 进程管理

## 5.1 &

在命令最后加上`&`代表将命令丢到后台执行

* 此时bash会给予这个命令一个工作号码(job number)，后接该命令触发的PID
* 不能被[Ctrl]+C中断
* 在后台中执行的命令，如果有stdout以及stderr时，它的数据依旧是输出到屏幕上面，所以我们会无法看到提示符，命令结束后，必须按下[Enter]才能看到命令提示符，同时也无法用[Ctrl]+C中断。解决方法就是利用数据流重定向

__示例：__

* `tar -zpcv -f /tmp/etc.tar.gz /etc > /tmp/log.txt 2>&1 &`

## 5.2 Ctrl+C

终止当前进程

## 5.3 Ctrl+Z

暂停当前进程

## 5.4 jobs

__格式：__

* `jobs [option]`

__参数说明：__

* `-l`：除了列出job number与命令串之外，同时列出PID号码
* `-r`：仅列出正在后台run的工作
* `-s`：仅列出正在后台中暂停(stop)的工作
* 输出信息中的'+'与'-'号的意义：
    * +：最近被放到后台的工作号码，代表默认的取用工作，即仅输入'fg'时，被拿到前台的工作
    * -：代表最近后第二个被放置到后台的工作号码
    * 超过最后第三个以后，就不会有'+'与'-'号存在了

__示例：__

* `jobs -lr`
* `jobs -ls`

## 5.5 fg

将后台工作拿到前台来处理

__示例：__

* `fg %jobnumber`：取出编号为`jobnumber`的工作。jubnumber为工作号码(数字)，%是可有可无的
* `fg +`：取出标记为+的工作
* `fg -`：取出标记为-的工作`

## 5.6 bg

让工作在后台下的状态变为运行中

__示例：__

* `bg %jobnumber`：取出编号为`jobnumber`的工作。jubnumber为工作号码(数字)，%是可有可无的
* `bg +`：取出标记为+的工作
* `bg -`：取出标记为-的工作
* 不能让类似vim的工作变为运行中，即便使用该命令会，该工作又立即变为暂停状态

## 5.7 kill

管理后台当中的工作

__格式：__

* `kill [-signal] PID`
* `kill [-signal] %jobnumber`
* `kill -l`

__参数说明：__

* `-l`：列出目前kill能够使用的signal有哪些
* `-signal`：
    * `-1`：重新读取一次参数的配置文件，类似reload
    * `-2`：代表与由键盘输入[Ctrl]+C同样的操作
    * `-9`：立刻强制删除一个工作，通常在强制删除一个不正常的工作时使用
    * `-15`：以正常的程序方式终止一项工作，与-9是不同的，-15以正常步骤结束一项工作，这是默认值
* 与bg、fg不同，若要管理工作，kill中的%不可省略，因为kill默认接PID

## 5.8 ps

__格式：__

* `ps aux`：查看系统所有进程数据
* `ps -lA`：查看所有系统的数据
* `ps axjf`：连同部分进程数状态

__参数说明：__

* `-A`：所有的进程均显示出来
* `-a`：不与terminal有关的所有进程
* `-u`：有效用户相关进程
* `x`：通常与a这个参数一起使用，可列出较完整的信息
* `l`：较长、较详细地将该PID的信息列出
* `j`：工作的格式(job format)
* `-f`：做一个更为完整的输出
* `ps -l`：查阅自己的bash中的程序
* `ps aux`：查阅系统所有运行的程序
* `ps aux -Z`：-Z参数可以让我们查阅进程的安全上下文

__`ps -l`打印参数说明__

* `F`：代表这个进程标志(process flags)
    * 若为4：表示此进程的权限为root
    * 若为1：表示此子进程尽可进行复制，而无法实际执行
* `S`：代表这个进程的状态(STAT)
    * R(Running)：该进程正在运行中
    * S(Sleep)：该进程目前正在睡眠状态(idle)，但可以被唤醒(signal)
    * D：不可被唤醒的睡眠状态，通常这个进程可能在等待I/O的情况
    * T：停止状态(stop)
    * Z(Zombie)：僵尸状态，进程已经终止但无法被删除至内存外
* `UIP/PID/PPID`：用户标识号/进程PID号码/父进程的PID号码
* `C`：CPU使用率，单位为百分比
* `PRI/NI`：Prority/Nice的缩写，代表此进程被CPU所执行的优先级，数值越小代表越快被CPU执行
* `ADDR/SZ/WCHAN`：都与内存有关
    * ADDR是kernel function，指出该进程在内存的哪个部分，如果是个running的进程，一般就会显示"-"
    * SZ表示此进程用掉多少内存
    * WCHAN表示目前进程是否运行中，'-'表示正在运行中，'wait'表示等待中
* `TTY`：登陆者的终端机位置，若为远程登录则使用动态终端机接口(pts/n)
* `TIME`：使用掉的CPU时间，是此进程实际花费CPU运行的时间
* `CMD`：造成此程序的出发进程的命令为何

__`ps aux`打印参数说明：__

* `USER`：该进程所属的用户名
* `PID`：该进程的PID
* `%CPU`：该进程使用掉的CPU资源百分比
* `%MEN`：该进程占用的物理内存百分比
* `VSZ`：该进程使用掉的虚拟内存量
* `RSS`：该进程占用的固定内存量
* `TTY`：该进程是所属终端机，tty1~tty6是本地，pts/0是网络连接主机的进程(GNOME上的bash)
* `STAT`：该进程目前的状态，状态显示与ps -l的S标志相同
* `START`：该进程被触发的启动时间
* `TIME`：该进程实际使用CPU的时间
* `COMMAND`：该进程的实际命令
* 一般来说ps aux会按照PID的顺序来排序显示

## 5.9 top

__top显示内容参数：__

* __第一行__：
    * 目前的时间
    * 开机到目前为止所经过的时间
    * 已经登录的人数
    * 系统在1，5，15分钟的平均工作负载
* __第二行__：显示的是目前进程的总量，与各个状态下进程的数量
* __第三行__：显示的CPU整体负载，特别注意wa，这个代表的是I/Owait，通常系统变慢都是I/O产生的问题比较大
* __第四五行__：物理内存与虚拟内存的使用情况，注意swap的使用量越少越好，大量swap被使用说明系统物理内存不足
* __第六行__：top进程中，输入命令时显示的地方
* __第七行以及以后__：每个进程的资源使用情况
    * PID：每个进程的ID
    * USER：进程所属用户名称
    * PR：Priority，优先顺序，越小优先级越高
    * NI：Nice，与Priority有关，越小优先级越高
    * %CPU：CPU使用率
    * %MEN：内存使用率
    * TIME+：CPU使用时间累加
    * COMMAND
* __top默认使用CPU使用率作为排序的终点__

## 5.10 pstree

__格式：__

* `pstree [-A|U] [-up]`

__参数说明：__

* `-A`：各进程树之间的连接以ASCII字符来连接(连接符号是ASCII字符)
* `-U`：各进程树之间的连接以utf8码的字符来连接，在某些终端接口下可能会有错误(连接符号是utf8字符，比较圆滑好看)
* `-p`：同时列出每个进程的PID
* `-u`：同时列出每个进程所属账号名称

# 6 网络管理

## 6.1 netstat

__格式：__

* `netstat -[rn]`
* `netstat -[antulpc]`

__参数说明：__

1. __与路由有关的参数__
    * `-r`：列出路由表(route table)，功能如同route
    * `-n`：不使用主机名与服务名称，使用IP与port number，如同route -n
1. __与网络接口有关的参数__
    * `-a`：列出所有的连接状态，包括tcp/udp/unix socket等
    * `-t`：仅列出TCP数据包的连接
    * `-u`：仅列出UDP数据包的连接
    * `-l`：仅列出已在Listen(监听)的服务的网络状态
    * `-p`：列出PID与Program的文件名
    * `-c`：可以设置几秒种后自动更新一次，例如-c 5为每5s更新一次网络状态的显示

__显示参数说明：__

* `Proto`：该连接的数据包协议，主要为TCP/UDP等数据包
* `Recv-Q`：非用户程序连接所复制而来的总byte数
* `Send-Q`：由远程主机发送而来，但不具有ACK标志的总byte数，亦指主动连接SYN或其他标志的数据包所占的byte数
* `Local Address`：本地端的地址，可以使IP，也可以是完整的主机名，使用的格式是"IP:port"
* `Foreign Address`：远程主机IP与port number
* `stat`：状态栏
    * `ESTABLISED`：已建立连接的状态
    * `SYN_SENT`：发出主动连接(SYN标志)的连接数据包
    * `SYN_RECV`：接收到一个要求连接的主动连接数据包
    * `FIN_WAIT1`：该套接字服务已中断，该连接正在断线当中
    * `FIN_WAIT2`：该连接已挂断，但正在等待对方主机响应断线确认的数据包中
    * `TIME_WAIT`：该连接已挂断，但socket还在网络上等待结束
    * `LISTEN`：通常在服务的监听port，可以使用-l参数查阅

netstat的功能就是查看网络的连接状态，而网络连接状态中，又以__"我目前开了多少port在等待客户端的连接"__以及__"目前我的网络连接状态中，有多少连接已建立或产生问题"__最常见

## 6.2 route

# 7 账号管理

## 7.1 chsh

__格式：__

* `chsh [-ls]`

__参数说明：__

* `-l`：列出目前系统上可用的shell，其实就是`/etc/shells`的内容
* `-s`：设置修改自己的shell

# 8 权限管理

## 8.1 sudo

__配置文件：__

* `/etc/sudoers`

<!--

__格式：__

* `find [文件路径] [option] [action]`

__参数说明：__

* `-name`：后接文件名，支持通配符。__注意匹配的是相对路径__

__示例：__

* `find . -name "*.c"`

-->

# 9 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf#163.com，#替换成@)，博主将在第一时间删除__

* 《鸟哥的Linux私房菜》
* [linux shell awk 流程控制语句（if,for,while,do)详细介绍](https://www.cnblogs.com/chengmo/archive/2010/10/04/1842073.html)
