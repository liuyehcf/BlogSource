---
title: 编译原理-语法分析4
date: 2017-10-20 09:24:43
mathjax: true
tags: 
- 摘录
categories: 
- 编译
---

__目录__

<!-- toc -->
<!--more-->

# 1 $SLR$分析

__$SLR$（Simple）分析法的基本思想如下图所示__

![fig1](/images/编译原理-语法分析4/fig1.jpg)

$SLR$分析表与$LR(0)$分析表的区别

* $LR(0)$分析表归约状态，遇到任何输入符号都采取归约动作
* $SLR$分析表归约状态，遇到位于$FOLLOW$集中的符号才采取归约动作

![fig2](/images/编译原理-语法分析4/fig2.jpg)

## 1.1 $SLR$分析表构造算法

1. 构造$G^{\\'}$的规范$LR(0)$项集族$C = \{ I_0, I_1,... , I_n \}$
1. 令$I_i$对应状态$i$。状态$i$的语法分析动作按照下面的方法决定：
    * $\textbf{if}\; A \to \alpha \cdot a \beta \in I_i \;\textbf{and}\; GOTO(I_i, a) = I_j \;\textbf{then}\; ACTION[i, a] = sj$
    * $\textbf{if}\; A \to \alpha \cdot B \beta \in I_i \;\textbf{and}\; GOTO(I_i, B) = I_j \;\textbf{then}\; GOTO[i, B] = j$
    * $\textbf{if}\; A \to \alpha \cdot \in I_i 且 A \ne S^{\\'} \;\textbf{then}\; \;\textbf{for}\; \forall a \in FOLLOW(A) \;\textbf{do}\; ACTION[i, a] = rj$（$j$是产生式$A \to \alpha$的编号）    __*（与$LR(0)$分析表算法的唯一区别）*__
    * $\textbf{if}\; S^{\\'} \to S \cdot \in I_i \;\textbf{then}\; ACTION [ i,\$] = acc$
1. 没有定义的所有条目都设置为“error”

如果给定文法的$SLR$分析表中不存在有冲突的动作，那么该文法称为$SLR$文法

## 1.2 $SLR$分析中的冲突

__可能产生移进/归约冲突__，如下图所示

![fig3](/images/编译原理-语法分析4/fig3.jpg)

__如上图所示，对于状态$I_2$会产生如下冲突__

* $S \to L \;\cdot = R\;\;$表示当下一个符号是`=`时，采取移入动作
* $R \to L \cdot\;\;$表示当下一个符号是`=`或`$`时，采取归约动作

# 2 $LR(1)$分析法

## 2.1 $LR(1)$分析法的提出

__$SLR$分析存在的问题__

* $SLR$只是简单地考察下一个输入符号$b$是否属于与归约项目$A \to \alpha$相关联的$FOLLOW(A)$，但$b \in FOLLOW(A)$只是归约$\alpha$的一个__必要条件，而非充分条件__
* 对于产生式$A \to \alpha$的归约，在不同使用位置，$A$会要求不同的后继符号
    * ![fig4](/images/编译原理-语法分析4/fig4.jpg)
* 在特定位置，$A$的后继符集合是$FOLLOW(A)$的子集，__一般情况下是真子集__（例如上图中，非终结符$R$的后继符一个是`=`，另一个是`$`，而$FOLLOW(R) = \{ =, \$ \}$）

## 2.2 规范$LR(1)$项目

将一般形式为$[A \to \alpha \cdot \beta, a]$的项称为$LR(1)$项，其中$A \to \alpha \beta$是一个产生式，$a$是一个终结符(这里将`$`视为一个特殊的终结符)。它表示在当前状态下，$A$后面必须紧跟的终结符，__称为该项的展望符(lookahead)__

* $LR(1)$中的1指的是项的第二个分量的长度
* 在形如$[A \to \alpha \cdot \beta, a]$且$\beta \ne \varepsilon$的项中，__展望符$a$没有任何作用（即对于移入项目，展望符是没有作用的）__
* 但是一个形如$[A \to \alpha \cdot, a]$的项在__只有在下一个输入符号等于$a$时__才可以按照$A \to \alpha$进行归约
    * 这样的a的集合总是$FOLLOW(A)$的子集，__而且它通常是一个真子集__

## 2.3 等价$LR(1)$项目

![fig5](/images/编译原理-语法分析4/fig5.jpg)

## 2.4 例子

![fig6](/images/编译原理-语法分析4/fig6.jpg)

可以看出，该文法的$SLR$自动机与$LR(1)$自动机的差别就是多了右边的几个状态，而且以下几对状态是同心的（如果除展望符外，两个$LR(1)$__项目集__是相同的，则称这两个$LR(1)$__项目集__是__同心的__）

* $I_{10}与I_8$
* $I_{11}与I_4$
* $I_{12}与I_5$
* $I_{13}与I_7$

## 2.5 $LR(1)$项目集闭包

$$CLOSURE(I) = I \cup \{ [B \to \cdot \gamma, b] | [A \to \alpha \cdot B \beta, a] ∈ CLOSURE(I), B \to \gamma \in P, b \in FIRST(\beta a) \}$$

![fig7](/images/编译原理-语法分析4/fig7.jpg)

## 2.6 $GOTO$函数

$$GOTO(I, X) = CLOSURE( \{ [A \to \alpha X \cdot \beta, a]|[A \to \alpha \cdot X \beta, a] \in I \} )$$

![fig8](/images/编译原理-语法分析4/fig8.jpg)

## 2.7 为文法$G^{\\'}$构造$LR(1)$项集族

![fig9](/images/编译原理-语法分析4/fig9.jpg)

## 2.8 $LR(1)$自动机的形式化定义

__文法__
$$G = ( V_N, V_T, P, S )$$

__$LR(1)$自动机__
$$M = ( C, V_N \cup V_T, GOTO, I_0, F )$$

* $C = \{I_0 \} \cup \{ I | \exists J \in C, X \in V_N \cup V_T, I = GOTO(J,X) \}$
* $I_0 = CLOSURE(\{ S^{\\'} \to \cdot S, \$ \})$
* $F = \{ CLOSURE(\{ S^{\\'} \to S \cdot, \$ \}) \}$

## 2.9 $LR(1)$分析表构造算法

1. 构造$G^{\\'}$的规范$LR(1)$项集族$C = \{ I_0, I_1,... , I_n \}$
1. 根据$I_i$构造状态$i$。状态$i$的语法分析动作按照下面的方法决定：
    * $\textbf{if}\; [A \to \alpha \cdot a \beta, b] \in I_i \;\textbf{and}\; GOTO(I_i, a) = I_j \;\textbf{then}\; ACTION[i, a] = sj$
    * $\textbf{if}\; [A \to \alpha \cdot B \beta, b] \in I_i \;\textbf{and}\; GOTO(I_i, B) = I_j \;\textbf{then}\; GOTO[i, B] = j$
    * $\textbf{if}\; [A \to \alpha \cdot, a] \in I_i 且 A \ne S^{\\'} \;\textbf{then}\; ACTION[i, a] = rj$（$j$是产生式$A \to \alpha$的编号）  
    * $\textbf{if}\; [S^{\\'} \to S \cdot, \$] \in I_i \;\textbf{then}\; ACTION [ i,\$] = acc$
1. 没有定义的所有条目都设置为“error”

如果$LR(1)$分析表中没有语法分析动作冲突，那么给定的文法就称为$LR(1)$文法

# 3 $LALR$分析法

## 3.1 $LALR$分析法的提出

$LR(1)$分析法会产生许多__同心状态__，如下图中红色标注之处

![fig10](/images/编译原理-语法分析4/fig10.jpg)

## 3.2 $LALR(lookahead-LR)$分析的基本思想

1. 寻找具有__相同核心__的$LR(1)$项集，并将这些项集合并为一个项集。所谓项集的核心就是其第一分量的集合
    * 合并后的展望符集合仍为$FOLLOW$集的子集
1. 然后根据合并后得到的项集族构造语法分析表
1. 如果分析表中没有语法分析动作冲突，给定的文法就称为$LALR(1)$文法，就可以根据该分析表进行语法分析

![fig11](/images/编译原理-语法分析4/fig11.jpg)

![fig12](/images/编译原理-语法分析4/fig12.jpg)

__合并同心项集后，虽然不产生冲突，但可能会推迟错误的发现__

![fig13](/images/编译原理-语法分析4/fig13.jpg)

## 3.3 $LALR(1)$的特点

1. 形式上与$LR(1)$相同
1. 大小上与$LR(0)/SLR$相当
1. 分析能力介于$SLR$和$LR(1)$二者之间

$$SLR \lt LALR(1) \lt LR(1)$$

# 4 二义性文法的$LR$分析

## 4.1 二义性文法的特点

1. __每个二义性文法都不是$LR$的__
1. 某些类型的二义性文法在语言的描述和实现中很有用

## 4.2 例子

![fig14](/images/编译原理-语法分析4/fig14.jpg)

![fig15](/images/编译原理-语法分析4/fig15.jpg)

![fig16](/images/编译原理-语法分析4/fig16.jpg)

## 4.3 二义性文法的使用

应该保守地使用二义性文法，并且必须在严格控制之下使用，因为稍有不慎就会导致语法分析器所识别的语言出现偏差

# 5 LR分析中的错误处理

__语法错误的检测__

* 当$LR$分析器在查询分析表并发现一个报错条目时，就检测到了一个语法错误

__错误恢复策略__

* 恐慌模式错误恢复
* 短语层次错误恢复

## 5.1 恐慌模式错误恢复

![fig17](/images/编译原理-语法分析4/fig17.jpg)

1. 从栈顶向下扫描，直到发现某个状态$s_i$，它有一个对应于某个非终结符$A$的$GOTO$目标（即后继状态），可以认为从这个$A$推导出的串中包含错误（哪里错了？？？）
1. 然后丢弃0个或多个输入符号，直到发现一个可能合法地跟在$A$之后的符号$a$为止。
1. 之后将$s_{i+1} = GOTO(s_i , A)$压入栈中，继续进行正常的语法分析

## 5.2 短语层次错误恢复

检查$LR$分析表中的每一个报错条目，并根据语言的使用方法来决定程序员所犯的何种错误最有可能引起这个语法错误。然后构造出适当的恢复过程

![fig18](/images/编译原理-语法分析4/fig18.jpg)

![fig19](/images/编译原理-语法分析4/fig19.jpg)

# 6 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《MOOC-编译原理-陈鄞》
