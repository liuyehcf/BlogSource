---
title: 进程与线程
date: 2017-07-04 23:33:48
tags: 
- 摘录
categories: 
- 操作系统
---

__目录__

<!-- toc -->
<!--more-->

# 1 进程

像hello这样的程序在现代操作系统上运行时，操作系统会提供一种假象，就像系统上只有这个程序在运行，程序看上去独占使用__处理器、主存和I/O设备__。处理器看上去像不间断地一条接一条地执行程序中的命令，即该程序代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的的概念之一

进程是操作系统对一个正在运行的程序的一种抽象，在一个系统上可以同时运行多个进程，而每个进程都好像独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程是多于可以运行它们的CPU个数的

传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。__操作系统实现这种交错执行的机制称为上下文切换__

操作系统保持跟踪进程运行所需的所有状态信息。__这种状态，就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容__。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复进程的上下文，然后将控制权传递到新进程，新进程就会从它上次停止的地方开始

从一个进程到另一个进程的转换时由操作系统内核(kernel)管理的，内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读文件，它就执行一条特殊的系统调用(system call)指令，将控制权传递给内核，然后内核执行被请求的操作并返回给应用程序。

注意，内核不是一个独立的进程，相反，它是系统管理全部进程所用代码和数据结构的集合

![进程](/images/进程与线程/fig1.png)

# 2 进程之间通信

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都是看不到的。__所以进程之间如果要交换数据就必须通过内核。__

在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信(IPC,InterProcess Communication)。 

__进程间通信的本质__：要让不同的进程看到同一份资源。    

以下为8种进程间通信方式，IPC(Inter-Process Communication)

## 2.1 管道

管道分为两种：匿名管道与命名管道。

### 2.1.1 匿名管道

匿名管道是一种最基本的IPC机制，由pipe函数创建：

```C
#include<unistd.h>
int pipe(int pipefd[2]);
```

调用pipe函数时在内核中开辟一块缓冲区(称为管道)用于通信，它有一个读端一个写端，然后通过pipefd参数传出给用户程序两个文件描述符，pipefd[0]指向管道的读端，fpipefd1]指向管道的写端。

所以管道在用户程序看起来就像一个打开的文件，通过`read(filedes[0]);`或者`write(filedes[1]);`向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。

开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。

![进程](/images/进程与线程/fig2)

1. 父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。
1. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。
1. 父进程关闭管道读端，子进程关闭管道写端（当然也可以反过来）。父进程可以往管道里写，子进程可以从管道里读。管道是用环形队列实现的，数据从写端流入，从读端流出，这样就实现了进程间通信。

因为管道是单向通信的，即单工，所以父子进程必须关闭它们各自不需要的端。其次，匿名管道是通过子进程继承父进程的文件描述符表才得以实现父子进程共同看到一份资源，所以匿名管道也就只能在有亲缘关系的进程间实现通信。

```C
#include <stdio.h>  
#include <unistd.h>  
#include <string.h>  
  
int main()  
{  
    int fd[2];  
    if (pipe(fd))  
    {  
        perror("pipe");  
        return 1;  
    }  
  
    // 实现父进程写，子进程读  
    pid_t id = fork();  
    if (id < 0)  
    {  
        perror("fork");  
        return 2;  
    }  
    else if (id == 0) // child  
    {  
        close(fd[1]);  
          
        char buf[128];  
        int cnt = 0;  
        while (cnt++ < 5)  
        {  
            ssize_t _s = read(fd[0], buf, sizeof(buf));  
            if (_s > 0)  
            {  
                buf[_s] = '\0';;  
                printf("father say to child: %s\n", buf);  
            }  
            else if (_s == 0)  
            {  
                printf("father close write");  
                break;  
            }  
            else  
            {  
                perror("read");  
                break;  
            }  
        }  
  
        close(fd[0]);  
    }  
    else          // father  
    {  
        close(fd[0]);  
          
        char * msg = "hello world";  
        int cnt = 0;  
        while (cnt++ < 5)  
        {  
            write(fd[1], msg, strlen(msg));  
            sleep(1);  
        }  
      
        close(fd[1]);  
    }  
      
    return 0;  
}  
```

匿名管道的特点：

1. 单向通信
1. 具有亲缘关系的进程间通信
1. 管道生命周期随进程（管道文件描述符在进程结束后被关闭）
1. 面向字节流的服务
1. 底层实现的同步机制，无需用户在考虑（为空不允许读，为满不允许写（阻塞））

几种特殊情况：

1. 如果所有指向管道写端的文件描述符都关闭了(管道写端的引用计数等于0)，而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。
1. 如果有指向管道写端的文件描述符没关闭(管道写端的引用计数大于0)，而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。
1. 如果所有指向管道读端的文件描述符都关闭了(管道读端的引用用计数等于0)，这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。
如果有指向管道读端的文件描述符没关闭(管道读端的引用计数大于0)，而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。

### 2.1.2 命名管道

匿名管道的缺点就是只能在有亲缘关系的进程间进行通信，针对这个缺陷，又提出来了命名管道（FIFO）的概念。FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存储于文件系统中。命名管道是一个设备文件，因此，即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信。值得注意的是，FIFO(first input first output)总是按照先进先出的原则工作，第一个被写入的数据将首先从管道中读出。

创建命名管道的方式无非也就是那两种：命令和函数。而且命令和函数对应的名字是一样的，mkfifo(mknod)命令/函数。

server.cpp：
```C
#include <stdio.h>  
#include <sys/types.h>  
#include <sys/stat.h>  
#include <fcntl.h>  
#include <unistd.h>  
#include <string.h>  
  
int main()  
{  
    // 创建管道时需要在mode参数位置传S_IFIFO,表明创建的是命名管道  
    int ret = mkfifo("./.fifo", S_IFIFO | 0644);      
    if (ret < 0)  
    {  
        perror("mkfifo");  
        return 1;  
    }  
  
    int fd = open("./.fifo", O_WRONLY);  
    if (fd < 0)  
    {  
        perror("open");  
        return 2;  
    }  
  
    int cnt = 0;  
    char *msg = "hello world";  
    while (cnt++ < 5)  
    {  
        write(fd, msg, strlen(msg));  
        sleep(1);  
    }  
  
    close(fd);  
    return 0;  
}  
```

client.cpp：
```C
#include <stdio.h>  
#include <sys/types.h>  
#include <sys/stat.h>  
#include <fcntl.h>  
#include <unistd.h>  
#include <string.h>  
  
int main()  
{  
    int fd = open("./.fifo", O_RDONLY);  
    if (fd < 0)  
    {  
        perror("open");  
        return 2;  
    }  
  
    int cnt = 0;  
    char buf[128];  
    while (cnt++ < 5)  
    {  
        ssize_t _s = read(fd, buf, sizeof(buf) - 1);  
        if (_s > 0)  
        {  
            buf[_s] = '\0';;  
            printf("server say to client: %s\n", buf);  
        }  
        else if (_s == 0)  
        {  
            printf("server close write\n");  
            break;  
        }  
        else  
        {  
            perror("read");  
        }  
        sleep(1);  
    }  
  
    close(fd);  
    return 0;  
}  
```

命名管道创建后就可以使用了，命名管道和管道的使用方法基本是相同的。只是使用命名管道时，必须先调用open()将其打开。因为命名管道是一个存在于硬盘上的文件，而管道是存在于内存中的特殊文件。需要注意的是，调用open()打开命名管道的进程可能会被阻塞。但如果同时用读写方式(`O_RDWR`)打开，则一定不会导致阻塞；如果以只读方式(`O_RDONLY`)打开，则调用open()函数的进程将会被阻塞直到有写方打开管道；同样以写方式(`O_WRONLY`)打开也会阻塞直到有读方式打开道。

命名管道与匿名管道不同的地方在于即使没有亲缘关系，也可以通过FIFO来通信，且管道的生命周期不再是随进程，因为即使命名管道文件描述符被关闭，FIFO依然存在于磁盘上，是一个文件。

## 2.2 消息队列(message queue)

消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为是有一个类型，接收者进程接收的数据块可以有不同的类型值。我们可以通过发送消息来避免命名管道的同步和阻塞问题。消息队列与管道不同的是，消息队列是基于消息的，而管道是基于字节流的，且消息队列的读取不一定是先入先出。消息队列与命名管道有一样的不足，就是每个消息的最大长度是有上限的(MSGMAX)，每个消息队列的总的字节数是有上限的(MSGMNB)，系统上消息队列的总数也有一个上限(MSGMNI)。

创建一个消息队列：

```C
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgget(key_t key, int msgflg);
```

* 其中的key一般通过ftok函数来得到（也可以认为是一个端口号），msgflg则与具体的创建方法和权限有关，单独的`IPC_CREAT`表示如果这个消息队列不存在，则创建；存在则打开。`IPC_CREAT | IPC_EXCL`表示如果不存在，则创建，存在则出错返回，此举是为了创建一个全新的消息队列。

消息队列创建好后，可以通过命令行的方式来查看：`ipcs -q`

也可以通过命令行删除它：`ipcrm -q  key值（或msqid）`

当然也可以在程序中删除，要借助msgctl函数：

```C
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

* msqid当然是想要删除的消息队列id了，cmd可以传`IPC_RMID`表示通过msqid来删除，buf用来存储获取自消息队列的一些数据，这里只用到了删除，那么设为NULL即可。

还有msgsnd（发送消息）与msgrcv（接收消息）方法：

```C
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
```

* msgp是一个结构体，有些系统实现了，有些需要我们自己定义

```C
struct msgbuf{
    long mtype;
    char mtext[1];
}
```

mtype用以区分消息类型，因为不同的进程把各自的消息都扔进同一个消息队列，想要取出来自己需要的消息，就需要这个mtype来区分了。mtext是存放数据的数组，大小可以自定义。msgsz就指定了mtext的大小。msgflg用来设置相关的一些模式，这里直接传0，表示以阻塞方式发送（或接收）。

comm.cpp：
```C
#include "comm.h"  
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
  
int cli_type = 1;  
int ser_type = 2;  
  
static int comm_msg(int flag)  
{  
    int key = ftok(_PATH_NAME_, _PROJ_ID_);   
    if (key < 0)  
    {  
        perror("ftok");  
        exit(1);  
    }  
      
    int id = msgget(key, flag);  
    if (id < 0)  
    {  
        perror("msgget");  
        exit(2);  
    }  
      
    return id;  
}  
  
int create_msg()  
{  
    int flag = IPC_CREAT | IPC_EXCL | 0666;   
    return comm_msg(flag);  
}  
  
int get_msg()  
{  
    int flag = IPC_CREAT;   
    return comm_msg(flag);  
}  
  
int send_msg(int id, char *buf, int type)  
{  
    struct msgbuf msg;  
    msg.mtype = type;  
    strncpy(msg.mtext, buf, strlen(buf)+1);  
  
    int ret = msgsnd(id, &msg, sizeof(msg.mtext), 0);   // 0缺省阻塞  
    if (ret < 0)  
    {  
        perror("msgsnd");  
        return ret;  
    }  
    return 0;  
}  
  
int recv_msg(int id, char *buf_out, int type)  
{  
    struct msgbuf msg;  
    size_t _s = msgrcv(id, &msg, sizeof(msg.mtext), type, 0);  
    if (_s < 0)  
    {  
        perror("msgrcv");  
        return _s;  
    }  
    strcpy(buf_out, msg.mtext);  
}     
  
int destory_msg(int id)  
{  
    msgctl(id, IPC_RMID, NULL);  
}  
```

comm.h：
```C
#include <sys/types.h>  
#include <sys/ipc.h>  
#include <sys/msg.h>  
  
#define _PATH_NAME_ "./comm/comm.h"  
#define _PROJ_ID_ 0x111  
#define _SIZE_ 1024  
  
extern int ser_type;  
extern int cli_type;  
  
struct msgbuf  
{  
    long mtype;  
    char mtext[_SIZE_];  
};  
  
int create_msg();  
int get_msg();  
int send_msg(int id, char *buf, int type);  
int recv_msg(int id, char *buf_out, int type);  
int destory_msg(int id);  
```

server.cpp：
```C
#include <stdio.h>  
#include "comm/comm.h"  
#include <unistd.h>  
#include <string.h>  
  
int main()  
{  
    int id = create_msg();  
    printf("%d\n", id);  
  
    char buf[_SIZE_];  
    while (1)  
    {  
        memset(buf, 0, sizeof(buf));  
  
        recv_msg(id, buf, cli_type);  
        printf("client# %s\n", buf);  
        if (strcasecmp(buf, "quit") == 0)  
            break;  
  
        memset(buf, 0, sizeof(buf));  
        printf("Please Enter# ");  
        fflush(stdout);  
        ssize_t _s = read(0, buf, sizeof(buf));  
        if (_s > 0)  
        {  
            buf[_s - 1] = 0;  
        }  
        send_msg(id, buf, ser_type);  
    }  
  
    destory_msg(id);  
  
    return 0;  
}  
```

client.cpp：
```C
#include <stdio.h>  
#include "comm/comm.h"  
#include <unistd.h>  
#include <string.h>  
  
int main()  
{  
    int id = get_msg();  
    printf("%d\n", id);  
  
    char buf[_SIZE_];  
    while (1)  
    {  
        memset(buf, 0, sizeof(buf));  
        printf("Please Enter# ");  
        fflush(stdout);  
        ssize_t _s = read(0, buf, sizeof(buf));  
        if (_s > 0)  
        {  
            buf[_s - 1] = 0;  
        }  
        send_msg(id, buf, cli_type);  
        if (strcasecmp(buf, "quit") == 0)  
            break;  
  
        memset(buf, 0, sizeof(buf));  
        recv_msg(id, buf, ser_type);  
        printf("server# %s\n", buf);  
  
    }  
  
    return 0;  
}  
```

消息队列的特点

1. 面向数据块的服务
1. 相对于管道而言函数复杂
1. 生命周期随内核（不主动删除不会自动释放）
1. System V版本的消息队列，由操作系统在底层提供队列支持。消息条数，消息大小，整个系统中的消息队列数有限制

__消息传递的本质__：借助内核的帮助，将进程A内存空间的一段数据拷贝到进程B的内存空间当中

## 2.3 信号量(semophore)

__两个概念__

1. 临界资源：一次只允许一个进程（一个线程）使用的资源叫做临界资源
1. 临界区：访问临界资源的代码称为临界区

__为什么使用信号量？__

> 为了防止出现因多个程序同时访问一个共享资源而而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。其中共享内存的使用就要用到信号量。

__什么是信号量__

> 信号量是一个计数器，其本质是一种数据操作锁，它本身不具有数据交换的功能，而是通过控制其他的通信资源(文件，外部设备)来实现进程间通信，它本身只是一种外部资源的标识。信号量在此过程中负责数据操作的互斥、同步等功能。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

当请求一个使用信号量来表示的资源时，进程需要先读取信号量的值来判断资源是否可用：

1. 大于0，资源可以请求，将信号量的值-1(P操作)
1. 等于0，无资源可用，进程会进入睡眠状态直至资源可用

当进程不再使用一个信号量控制的共享资源时，信号量的值+1(V操作)。

PV操作均为原子操作。这是由于信号量主要的作用是维护资源的互斥或多进程的同步访问。而在信号量的创建及初始化上，不能保证操作均为原子性(SystemV版本信号量的缺陷)，因为这个版本的信号量的创建与初始化是分开的。

## 2.4 信号(sinal)

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

## 2.5 共享内存(shared memory)

__什么是共享内存__

> 共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式（共享内存是最快的IPC方式）。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

> 但要特别注意的是共享内存并未提供同步机制。也就是说，在第一个进程结束对共享内存的操作之前，并没有自动机制可以阻止第二个进程开始对它进行读取。所以通常需要使用其它的机制来同步对共享内存的访问，比如信号量。

__为什么共享内存速度最快__

> 对比其它的进程间通信机制，都是进程1将数据写到公共资源上，进程2去读，这里面就包含了两次拷贝，第一次将数据从用户空间拷贝到内核，第二次将数据从内核拷贝到用户空间。再来看共享内存机制：进程1将数据写到共享内存，然后无需任何拷贝，进程2可以直接访问到这部分数据，所以就节省了两次拷贝的时间。

## 2.6 套接字(socket)

套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

# 3 线程

通常我们认为一个进程只有单一的控制流，但在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。

__由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据(进程间也能共享数据)，也因为线程一般来说比进程更高效__

下图是Java中线程的状态转移图

![线程](/images/进程与线程/fig3.png)

# 4 多进程与多线程

__进程__：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。__（进程是资源分配的最⼩小单位）__

__线程__：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销⼩小。__（线程是cpu调度的最⼩小单位）__

多进程是指操作系统能同时运行多个任务（程序）。多线程是指在同一程序中有多个顺序流在执行。

__多线程与多进程的区别__：本质的区别在于每个线程拥有自己的一套变量，⽽多线程则共享变量。其次，线程可能⽐进程显得更加“轻量级”，因为创建、撤销⼀个线程都比启动一个新进程的开销要小得多。另外，共享数据的特点使得线程与线程之间的通信变得更加容易与高效。但是，多线程的风险高得多。

# 5 参考

* [进程间通信之管道篇](http://blog.csdn.net/qq_33724710/article/details/52345509)
* [牛人的博客](http://blog.csdn.net/qq_33724710/article/category/6234755)
