---
title: 数据库-优化器
date: 2022-06-24 08:32:09
mathjax: true
tags: 
- 摘录
categories: 
- Database
- Basic Concepts
---

**阅读更多**

<!--more-->

# 1 概述

**优化器涉及到的优化点包括：**

* `Limit`合并
* `Limit`下推
* 子查询重写
* 各种表达式的重写和化简
* 列裁剪
* 谓词下推
* 聚合合并
* 等价谓词推导（常量传播）
* `Outer Join`转`Inner Join`
* 常量折叠
* 公共表达式复用（CTE）
* 子查询重写
* `Lateral Join`化简
* 分区分桶裁剪
* `Empty Node`优化
* `Empty Union, Intersect, Except`裁剪
* `Intersect Reorder`
* `Count Distinct`相关聚合函数重写
* `GroupBy Reordering`

# 2 Subquery Rewrite

这里仅讨论相关子查询的重写

## 2.1 In Subquery

* [[Refactor] Refactor in subquery transform rule](https://github.com/StarRocks/starrocks/pull/6274)
* [[Bug] Fix in-subquery cast to outer join bug](https://github.com/StarRocks/starrocks/pull/7090)

**下面用一个例子来说明**

```sql
DROP TABLE IF EXISTS `S`;
CREATE TABLE IF NOT EXISTS `S` (
  `s1` int(11) NULL,
  `s2` int(11) NULL,
  `s3` int(11) NULL
) ENGINE=OLAP
DUPLICATE KEY(`s1`)
DISTRIBUTED BY HASH(`s1`) BUCKETS 10
PROPERTIES (
 "replication_num" = "1"
);

INSERT INTO `S` (s1, s2, s3) values
    (1, 2, 3),
    (1, 2, 3),
    (4, 5, 6),
    (7, 8, 9),
    (10, NULL, 12),
    (13, 14, 15);

DROP TABLE IF EXISTS `R`;
CREATE TABLE IF NOT EXISTS `R` (
  `r1` int(11) NULL,
  `r2` int(11) NULL,
  `r3` int(11) NULL
) ENGINE=OLAP
DUPLICATE KEY(`r1`)
DISTRIBUTED BY HASH(`r1`) BUCKETS 10
PROPERTIES (
 "replication_num" = "1"
);

INSERT INTO `R` (r1, r2, r3) values
    (1, 2, 3),
    (4, 55, 6),
    (7, NULL, 9),
    (10, NULL, 12);
```

**原`SQL`如下。其含义是，针对`S`表中的每一行，在`R`表中找出满足`S.s3 = R.r3`的所有行，并提取出`R.r2`作为结果集`A`，看`S.s2`是否在这个结果集`A`中**

* 若`S.s2`为`NULL`，那么返回`NULL`
* 若结果集`A`为空，那么返回`false`
* 对于当前行（固定`S.s3`的值），若`R`表中不存在满足`R.r3 = S.s3`的行，那么返回`false`

```sql
SELECT S.s1, S.s2 IN
(
  SELECT R.r2
  FROM R
  WHERE S.s3 = R.r3
)
FROM S;
```

**重写后的`SQL`如下：**

* `R_GroupBy`：通过`Left Outer Join`将谓词`IN`调整谓词`==`
* `R_CountRow`：用于统计`R`表中各分组（`by r3`）下的总行数以及`R.r2`非`NULL`的行数
* **`CASE WHEN`语句分析：**
  * `CASE WHEN 1`：若`R_CountRow.R_Rows IS NULL`，我们知道`count(*)`是不会产生空值的，因此该空值一定是`Left Outer Join`产生的，意味着对于当前行（固定`S.s3`的值），`R`表中不存在满足`R.r3 = S.s3`的行，即集合`A`为空。因此根据`ANY in (empty) -> false`（`ANY`可以是`NULL`），谓词`IN`的结果就是`false`
  * 否则，意味着对于当前行（固定`S.s3`的值），`R`表中存在满足`R.r3 = S.s3`的行，即集合`A`不为空
  * `CASE WHEN 2`：若`S.s2 IS NULL`。因此根据`NULL IN (...) -> NULL`，谓词`IN`的结果就是`NULL`
  * 否则，意味着`S.s2 IS NOT NULL`
  * `CASE WHEN 3`：若`R_GroupBy.r2 IS NOT NULL`，意味着对于当前行（固定`S.s3`的值），集合`A`中至少存在一个元素满足`S.s2 = R.r2`，因此谓词`IN`的结果就是`true`
  * 否则，意味着`R_GroupBy.r2 IS NULL`
  * `CASE WHEN 4`：若`R_CountRow.r2_NotNulls < R_CountRow.R_Rows`，则表示集合`A`中一定存在`NULL`元素
  * 否则，意味着`R_CountRow.r2_NotNulls = R_CountRow.R_Rows`，则集合`A`中的所有元素都是`NULL`，因此根据`ANY VALUE IN (NULL, NULL, ...) -> false`，谓词`IN`的结果就是`false`

```sql
WITH R_CTE AS (SELECT R.r2, R.r3 FROM R)
SELECT S.s1,
       CASE 
           WHEN R_CountRow.R_Rows = 0 OR R_CountRow.R_Rows IS NULL THEN FALSE
           WHEN S.s2 IS NULL THEN NULL
           WHEN R_GroupBy.r2 IS NOT NULL THEN TRUE
           WHEN R_CountRow.r2_NotNulls < R_CountRow.R_Rows THEN NULL
           ELSE FALSE
       END
FROM S
LEFT OUTER JOIN
  (
    SELECT R_CTE.r2, R_CTE.r3
    FROM R_CTE
    GROUP BY R_CTE.r2, R_CTE.r3
  ) AS R_GroupBy 
  ON S.s2= R_GroupBy.r2
  AND S.s3 = R_GroupBy.r3
LEFT OUTER JOIN
  (
    SELECT r3,
          count(*) AS R_Rows,
          count(R_CTE.r2) AS r2_NotNulls
    FROM R_CTE
    GROUP BY R_CTE.r3
  ) AS R_CountRow 
  ON  S.s3 = R_CountRow.r3;
```

# 3 GroupBy Reordering

[Orthogonal Optimization of Subqueries and Aggregation](/resources/paper/Orthogonal-Optimization-of-Subqueries-and-Aggregation.pdf)

用{% raw %}$G_{A,F}(R)${% endraw %}表示`GroupBy`，其中`A`表示`GroupBy`列，`F`表示输出列

## 3.1 Filter

### 3.1.1 push down

{% raw %}$$\sigma_{p}G_{A,F}(R) \rightarrow G_{A,F}(\sigma_{p}R)$${% endraw %}

**上述转换成立的条件如下：**

* `Filter`中用到的列全部来自于`GroupBy`的输入列。换言之，不对`GroupBy`的输出列进行过滤

## 3.2 Join

### 3.2.1 push down

{% raw %}$$G_{A,F}(S \Join_{p} R) \rightarrow S \Join_{p} G_{A \cup columns(p)-columns(S),F}(R)$${% endraw %}

**上述转换成立的条件如下：**

* `Join Predicate p`中与`R`有关的列必须存在于`GroupBy`列中
* `S`的主键必须存在于`GroupBy`列中
* 聚合操作仅用到了`R`中的列

### 3.2.2 pull above

{% raw %}$$S \Join_{p} G_{A,F}(R) \rightarrow G_{A \cup columns(S),F}(S \Join_{p} R)$${% endraw %}

**上述转换成立的条件如下：**

* `Join`的表有主键
* `Join`没有用到聚合函数的结果列

## 3.3 Outer Join

### 3.3.1 push down

{% raw %}$$G_{A,F}(S ⟕_{p} R) \rightarrow \pi_{c}(S ⟕_{p} G_{A - columns(S),F}(R))$${% endraw %}

**上述转换成立的条件如下（同`Join push down`）：**

* `Join Predicate p`中与`R`有关的列必须存在于`GroupBy`列中
* `S`的主键必须存在于`GroupBy`列中
* 聚合操作仅用到了`R`中的列

**可以发现，`Outer Join`与`Join`的差异是，多了一个{% raw %}$\pi_{c}${% endraw %}**

* 当`GroupBy`列为`NULL`时，若聚合函数针对该`NULL`分组可以生成`NULL`时，比如`sum`，无需引入额外的{% raw %}$\pi_{c}${% endraw %}
* 当`GroupBy`列为`NULL`时，若聚合函数针对该`NULL`分组无法生成`NULL`时，比如`count`，则需引入额外的{% raw %}$\pi_{c}${% endraw %}，来产生相应的`NULL`值

**下面用一个例子来说明**

```sql
DROP TABLE IF EXISTS `S`;
CREATE TABLE IF NOT EXISTS `S` (
  `s1` int(11) NOT NULL,
  `s2` int(11) NOT NULL
) ENGINE=OLAP
DUPLICATE KEY(`s1`)
DISTRIBUTED BY HASH(`s1`) BUCKETS 10
PROPERTIES (
 "replication_num" = "1"
);

INSERT INTO `S` (s1, s2) values
    (1, 2),
    (2, 4),
    (3, 6);

DROP TABLE IF EXISTS `R`;
CREATE TABLE IF NOT EXISTS `R` (
  `r1` int(11) NULL,
  `r2` int(11) NULL
) ENGINE=OLAP
DUPLICATE KEY(`r1`)
DISTRIBUTED BY HASH(`r1`) BUCKETS 10
PROPERTIES (
 "replication_num" = "1"
);

INSERT INTO `R` (r1, r2) values
    (1, 12),
    (2, 22);
```

```sql
-- Q1.1
SELECT r1, sum FROM S LEFT OUTER JOIN (SELECT sum(r2) AS sum, r1 FROM R GROUP BY r1)a ON s1 = r1;
-- Q1.2
SELECT r1, sum(r2) AS sum FROM (SELECT * FROM S LEFT OUTER JOIN R ON s1 = r1)a GROUP BY r1;

-- Q2.1
SELECT r1, cnt FROM S LEFT OUTER JOIN (SELECT count(r2) AS cnt, r1 FROM R GROUP BY r1)a ON s1 = r1;
-- Q2.2
SELECT r1, count(r2) AS cnt FROM (SELECT * FROM S LEFT OUTER JOIN R ON s1 = r1)a GROUP BY r1;
-- Q2.3
SELECT r1,
CASE
    WHEN r1 IS NULL
    THEN NULL
    ELSE count(r2)
END AS cnt
FROM (SELECT * FROM S LEFT OUTER JOIN R ON s1 = r1)a GROUP BY r1;
```

**可以发现：**

* `Q1.1`和`Q1.2`可以产生相同的输出，因为聚合函数`sum`对于`NULL`分组可以正常产生`NULL`值
* `Q2.1`和`Q2.2`无法产生相同的输出，因为聚合函数`count`对于`NULL`分组会输出`0`或`1`。因此这里我们通过`case when`语句来对输出列进行改写`Q2.3`，以达到纠正的目的
