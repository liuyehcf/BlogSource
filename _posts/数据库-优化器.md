---
title: 数据库-优化器
date: 2022-06-24 08:32:09
mathjax: true
tags: 
- 摘录
categories: 
- Database
- Basic Concepts
---

**阅读更多**

<!--more-->

# 1 概述

**优化器涉及到的优化点包括：**

* `Limit`合并
* `Limit`下推
* 子查询重写
* 各种表达式的重写和化简
* 列裁剪
* 谓词下推
* 聚合合并
* 等价谓词推导（常量传播）
* `Outer Join`转`Inner Join`
* 常量折叠
* 公共表达式复用（CTE）
* 子查询重写
* `Lateral Join`化简
* 分区分桶裁剪
* `Empty Node`优化
* `Empty Union, Intersect, Except`裁剪
* `Intersect Reorder`
* `Count Distinct`相关聚合函数重写
* `GroupBy Reordering`

# 2 GroupBy Reordering

[Orthogonal Optimization of Subqueries and Aggregation](/resources/paper/Orthogonal-Optimization-of-Subqueries-and-Aggregation.pdf)

用{% raw %}$G_{A,F}(R)${% endraw %}表示`GroupBy`，其中`A`表示`GroupBy`列，`F`表示输出列

## 2.1 Filter

### 2.1.1 push down

{% raw %}$$\sigma_{p}G_{A,F}(R) \rightarrow G_{A,F}(\sigma_{p}R)$${% endraw %}

**上述转换成立的条件如下：**

* `Filter`中用到的列全部来自于`GroupBy`的输入列。换言之，不对`GroupBy`的输出列进行过滤

## 2.2 Join

### 2.2.1 push down

{% raw %}$$G_{A,F}(S \Join_{p} R) \rightarrow S \Join_{p} G_{A \cup columns(p)-columns(S),F}(R)$${% endraw %}

**上述转换成立的条件如下：**

* `Join Predicate p`中与`R`有关的列必须存在于`GroupBy`列中
* `S`的主键必须存在于`GroupBy`列中
* 聚合操作仅用到了`R`中的列

### 2.2.2 pull above

{% raw %}$$S \Join_{p} G_{A,F}(R) \rightarrow G_{A \cup columns(S),F}(S \Join_{p} R)$${% endraw %}

**上述转换成立的条件如下：**

* `Join`的表有主键
* `Join`没有用到聚合函数的结果列

## 2.3 Outer Join

### 2.3.1 push down

{% raw %}$$G_{A,F}(S ⟕_{p} R) \rightarrow \pi_{c}(S ⟕_{p} G_{A - columns(S),F}(R))$${% endraw %}

**上述转换成立的条件如下（同`Join push down`）：**

* `Join Predicate p`中与`R`有关的列必须存在于`GroupBy`列中
* `S`的主键必须存在于`GroupBy`列中
* 聚合操作仅用到了`R`中的列

**可以发现，`Outer Join`与`Join`的差异是，多了一个{% raw %}$\pi_{c}${% endraw %}**

* 当`GroupBy`列为`NULL`时，若聚合函数针对该`NULL`分组可以生成`NULL`时，比如`sum`，无需引入额外的{% raw %}$\pi_{c}${% endraw %}
* 当`GroupBy`列为`NULL`时，若聚合函数针对该`NULL`分组无法生成`NULL`时，比如`count`，则需引入额外的{% raw %}$\pi_{c}${% endraw %}，来产生相应的`NULL`值

**下面用一个例子来说明**

```sql
DROP TABLE IF EXISTS `S`;
CREATE TABLE IF NOT EXISTS `S` (
  `s1` int(11) NOT NULL,
  `s2` int(11) NOT NULL
) ENGINE=OLAP
DUPLICATE KEY(`s1`)
DISTRIBUTED BY HASH(`s1`) BUCKETS 10
PROPERTIES (
 "replication_num" = "1"
);

INSERT INTO `S` (s1, s2) values
    (1, 2),
    (2, 4),
    (3, 6);

DROP TABLE IF EXISTS `R`;
CREATE TABLE IF NOT EXISTS `R` (
  `r1` int(11) NULL,
  `r2` int(11) NULL
) ENGINE=OLAP
DUPLICATE KEY(`r1`)
DISTRIBUTED BY HASH(`r1`) BUCKETS 10
PROPERTIES (
 "replication_num" = "1"
);

INSERT INTO `R` (r1, r2) values
    (1, 12),
    (2, 22);
```

```sql
-- Q1.1
SELECT r1, sum FROM S LEFT OUTER JOIN (SELECT sum(r2) AS sum, r1 FROM R GROUP BY r1)a ON s1 = r1;
-- Q1.2
SELECT r1, sum(r2) AS sum FROM (SELECT * FROM S LEFT OUTER JOIN R ON s1 = r1)a GROUP BY r1;

-- Q2.1
SELECT r1, cnt FROM S LEFT OUTER JOIN (SELECT count(r2) AS cnt, r1 FROM R GROUP BY r1)a ON s1 = r1;
-- Q2.2
SELECT r1, count(r2) AS cnt FROM (SELECT * FROM S LEFT OUTER JOIN R ON s1 = r1)a GROUP BY r1;
-- Q2.3
SELECT r1,
CASE
    WHEN r1 IS NULL
    THEN NULL
    ELSE count(r2)
END AS cnt
FROM (SELECT * FROM S LEFT OUTER JOIN R ON s1 = r1)a GROUP BY r1;
```

**可以发现：**

* `Q1.1`和`Q1.2`可以产生相同的输出，因为聚合函数`sum`对于`NULL`分组可以正常产生`NULL`值
* `Q2.1`和`Q2.2`无法产生相同的输出，因为聚合函数`count`对于`NULL`分组会输出`0`或`1`。因此这里我们通过`case when`语句来对输出列进行改写`Q2.3`，以达到纠正的目的
