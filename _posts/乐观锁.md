---
title: 乐观锁
date: 2017-08-28 10:07:54
tags: 
- 摘录
categories: 
- 数据库
- 基本概念
---

__阅读更多__

<!--more-->

# 1 前言

悲观锁并不是适用于任何场景，它也有它存在的一些不足，因为悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响了程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是对长事务而言，这样的开销往往无法承受。所以与悲观锁相对的，我们有了乐观锁

# 2 乐观锁介绍

乐观锁（Optimistic Locking）相对悲观锁而言，__乐观锁假设认为数据一般情况下不会造成冲突__，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。那么我们如何实现乐观锁呢，一般来说有以下2种方式：

## 2.1 使用数据版本(Version)

使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的"version"字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。用下面的一张图来说明：

![fig1](/images/乐观锁/fig1.jpg)

如上图所示，如果更新操作顺序执行，则数据的版本（version）依次递增，不会产生冲突。但是如果发生有不同的业务操作对同一版本的数据进行修改，那么，先提交的操作（图中B）会把数据version更新为2，当A在B之后提交更新时发现数据的version已经被修改了，那么A的更新操作会失败

```
UPDATE table_name
SET column1 = value1, version = 2
WHERE id = 1 AND version = 1;
```

__提一点，更新version的操作必须是原子的，并且version写 `happens-before` version读(即保证可见性)。__

__由于UPDATE操作本身就作为一个事务来实现，因此写操作必定是串行化的，即多个竞争只会有一个UPDATE成功。__

## 2.2 时间戳

乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp），和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突

同理时间戳的更新也必须是原子的，并且保证可见

# 3 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf#163.com，#替换成@)，博主将在第一时间删除__

* [mysql乐观锁总结和实践](http://chenzhou123520.iteye.com/blog/1863407)
