---
title: 编译原理-词法分析
date: 2017-10-15 10:28:52
mathjax: true
tags: 
- 摘录
categories: 
- 编译
---

__目录__

<!-- toc -->
<!--more-->

# 1 正则表达式

__正则表达式(Regular Expression, RE)__是一种用来描述__正则语言__的更紧凑的表示方法

正则表达式可以由较小的正则表达式按照特定规则__递归__地构建。每个正则表达式$r$定义（表示）一个语言，记为$L\(r\)$。这个语言也是根据r的__子表达式所表示的语言递归定义__的

## 1.1 正则表达式的定义

1. $\varepsilon$是一个RE，$L\(\varepsilon\) = \{\varepsilon\}$
1. 如果$a \in \sum$，则$a$是一个RE，$L\(a\) = \{a\}$
1. 假设$r$和$s$都是RE，表示的语言分别是$L\(r\)$和$L\(s\)$，则
    * $r|s$是一个RE，$L\(r|s\) = L\(r\) \cup L\(s\)$
    * $rs$是一个RE，$L\(rs\) = L\(r\) L\(s\)$
    * $r^\*$是一个RE，$L\(r^\*\) = \(L\(r\)\)^\*$
    * $\(r\)$是一个RE，$L\(\(r\)\) = L\(r\)$
    * __运算优先级：`() > * > 连接 > |`__

## 1.2 正则语言

可以用RE定义的语言叫做__正则语言(regular language)__或__正则集合(regular set)__

RE的代数定理

![fig1](/images/编译原理-词法分析/fig1.jpg)

## 1.3 正则文法与正则表达式等价

对于任何正则文法$G$，存在定义同一语言的正则表达式$r$

对于任何正则表达式$r$，存在生成同一语言的正则文法$G$

# 2 正则定义

__正则定义__是具有如下形式的__定义序列__：
$$d_1 \to r_1 \\
d_2 \to r_2 \\
... \\
d_n \to r_n \\
$$

* 每个$d_i$都是一个__新符号__，它们都不在字母表$\sum$中，而且__各不相同__
* 每个$r_i$是字母表$\sum \cup \{ d_1, d_2, ..., d_{i-1} \}$上的__正则表达式__

# 3 有穷自动机

有穷自动机(Finite Automata, FA)是由两位神经物理学家MeCuloch和Pitts于1948年首先提出，是对__一类处理系统__所建立的__数学模型__

* 这类系统具有一系列__离散的输入输出信息__和__有穷数目的内部状态__（状态：概括了对过去输入信息处理的情况）
* 系统只需要根据__当前所处的状态__和__当前面临的输入信息__就可以决定系统的__后继行为__。每当系统处理了当前的输入后，系统内部的__状态也将发生改变__

## 3.1 FA模型

![fig2](/images/编译原理-词法分析/fig2.jpg)

FA模型由三部分组成

1. __输入带(input tape)__：用来存放输入符号串
1. __读头(head)__：从左向右逐个读取输入符号，不能修改（只读）、不能往返移动
1. __有穷控制器(finite control)__：具有有穷个状态数，根据__当前的状态__和__当前输入符号__控制转入__下一状态__

## 3.2 FA的表示

__转换图(Transition Graph)可以用来表示FA__，其结构如下

1. __结点__：FA的状态
    * 初始状态（开始状态）：只有一个，由__*start*箭头__指向
    * 终止状态（接收状态）：可能有多个，用双圈表示
1. __带有标记的有向边__
    * 如果对于__输入a__，存在一个从状态p到状态q的转换，就在p、q之间画一条有向边，并标记上a，如下
    * ![fig3](/images/编译原理-词法分析/fig3.jpg)

## 3.3 FA定义（接收）的语言

给定输入串$x$，如果存在一个对应于串$x$的从__初始状态__到__某个终止状态__的转换序列，则称串$x$被该FA接收

由一个有穷自动机$M$(Machine)接收的所有串构成的集合称为是该FA定义（接收）的语言，记为$L\(M\)$

## 3.4 最长子串匹配原则

当输入串的__多个前缀__与一个或多个模式匹配时，总是选择__最长的前缀__进行匹配

* 在到达某个终态之后，只要输入带上还有符号，DFA就继续前进，以便寻找尽可能长的匹配
* ![fig4](/images/编译原理-词法分析/fig4.jpg)

# 4 有穷自动机的分类

FA的分类

1. __确定的FA(Deterministic finite automata, DFA)__
1. __非确定的FA(Nondeterministic finite automata, NFA)__

## 4.1 确定的有穷自动机(DFA)

$$M = \( S, \sum, \delta, s_0, F \)$$

1. $S$：__有穷状态集__
1. $\sum$：__输入字母表__，即输入符号集合。假设$\varepsilon$不是$\sum$中的元素
1. $\delta$：将$S\;\times\;\sum$映射到$S$的__转换函数__。$\forall s \in S, a \in \sum, \delta\(s,a\)$表示从状态$s$出发，沿着标记为$a$的边所能到达的状态。
1. $s_0$：__开始状态__（或初始状态），$s_0 \in S$
1. $F$：__接收状态（或终止状态）集合__，$F \subseteq S$

![fig5](/images/编译原理-词法分析/fig5.jpg)

## 4.2 非确定的有穷自动机(NFA)

$$M = \( S, \sum, \delta, s_0, F \)$$

1. $S$：有穷状态集
1. $\sum$：输入字母表，即输入符号集合。假设$\varepsilon$不是$\sum$中的元素
1. $\delta$：将$S\;\times\;\sum$映射到$\textbf{2}^\textbf{S}$的转换函数。$\forall s \in S, a \in \sum, \delta\(s,a\)$表示从状态$s$出发，沿着标记为$a$的边所能到达的状态__集合__。
1. $s_0$：开始状态（或初始状态），$s_0 \in S$
1. $F$：接收状态（或终止状态）集合，$F \subseteq S$

![fig6](/images/编译原理-词法分析/fig6.jpg)

非确定的有穷自动机与确定的有穷自动机的__唯一区别__：

* 确定有穷自动机由__当前状态__和__当前输入符号__可以唯一确定下一个状态
* 非确定有穷自动机由__当前状态__和__当前输入符号__不能唯一确定下一个状态，只能得到一个__状态集合__

## 4.3 DFA和NFA的等价性

对任何非确定的有穷自动机N，存在定义同一语言的确定的有穷自动机D

对任何确定的有穷自动机D，存在定义同一语言的非确定的有穷自动机N

![fig7](/images/编译原理-词法分析/fig7.jpg)

## 4.4 带有$\varepsilon -$边的NFA

$$M = \( S, \sum, \delta, s_0, F \)$$

1. $S$：有穷状态集
1. $\sum$：输入字母表，即输入符号集合。假设$\varepsilon$不是$\sum$中的元素
1. $\delta$：将$S\;\times\;\(\sum \cup \{ \varepsilon \}\)$映射到$\textbf{2}^\textbf{S}$的转换函数。$\forall s \in S, a \in \(\sum \cup \{ \varepsilon \}\), \delta\(s,a\)$表示从状态$s$出发，沿着标记为$a$的边所能到达的状态__集合__。
1. $s_0$：开始状态（或初始状态），$s_0 \in S$
1. $F$：接收状态（或终止状态）集合，$F \subseteq S$

![fig8](/images/编译原理-词法分析/fig8.jpg)

## 4.5 带有和不带有$\varepsilon -$边NFA等价

![fig9](/images/编译原理-词法分析/fig9.jpg)

## 4.6 DFA算法的实现

__输入__：以文件结束符eof结尾的字符串$x$。DFA $D$的开始状态$s_0$，接收状态集$F$，转换函数$move$
__输出__：如果$D$接收$x$，则回答“yes”，否则回答“no”
__方法__：将下述算法应用于输入串$x$。

* 函数`nextChar()`返回输入串$x$的下一个符号
* 函数`move(s, c)`返回从状态$s$出发，沿着标记为$c$的边所能到达的状态

```C
s = s0;
c = nextChar();
while(c != eof) {
    s = move(s, c);
    c = nextChar();
}

if(s in F) return "yes";
else return "no";
```

# 5 从正则表达式到有穷自动机

从正则表达式转换到DFA比较困难，但是从正则表达式转换到带有$\varepsilon -$边的NFA是比较容易的

![fig10](/images/编译原理-词法分析/fig10.jpg)

## 5.1 根据RE构造NFA

1. $\varepsilon$对应的NFA
    * ![fig11](/images/编译原理-词法分析/fig11.jpg)
1. 字母表$\sum$中符号$a$对应的NFA
    * ![fig12](/images/编译原理-词法分析/fig12.jpg)
1. $r = r_1r_2$对应的NFA
    * ![fig13](/images/编译原理-词法分析/fig13.jpg)
1. $r = r_1 | r_2$对应的NFA
    * ![fig14](/images/编译原理-词法分析/fig14.jpg)
1. $r = r1^\*$对应的NFA
    * ![fig15](/images/编译原理-词法分析/fig15.jpg)

__下面以一个例子进行说明__，$RE = \(a|b\)^\*abb$

* ![fig16](/images/编译原理-词法分析/fig16.jpg)
* __转化的过程，就是将复合表达式进行拆分的过程__

# 6 从NFA到DFA的转换

![fig17](/images/编译原理-词法分析/fig17.jpg)

__以上图中的例子进行说明__

* 起始状态$A$，在接收到字符$a$后，下一个__状态集合__是$\{A、B\}$
* 我们将__状态集合__$\{A、B\}$单独作为DFA中的一个状态。状态$\{B、C\}$、$\{C、D\}$同理
* 在NFA中，状态$A$接收字符$a$后，转换到__状态集合__$\{A、B\}$，因此，在DFA中，__状态__$\{A、B\}$接收字符$a$后，转换到__状态__$\{A、B\}$
* 在NFA中，状态$B$接收字符$b$后，转换到__状态集合__$\{B、C\}$，因此，在DFA中，__状态__$\{A、B\}$接收字符$b$后，转换到__状态__$\{B、C\}$
* 其他同理，不再赘述

![fig18](/images/编译原理-词法分析/fig18.jpg)

## 6.1 子集构造法(subset construction)

__输入__：NFA N
__输出__：接收同样语言的DFA D
__方法（类似于BFS）__：一开始，$\varepsilon -closure\( s_0 \)$是Dstates中的唯一状态，且它未加标记

```C
while(在Dstates中有一个未标记状态T)｛
    给T加上标记;
    for(每个输入符号a)｛
        U = ε-closure(move(T, a));
        if(U不在Dstates中)
            将U加入到Dstates中，且不加标记;
        Dtran[T, a]=U;
    }
}
```
| 操作 | 描述 |
|:--|:--|
| $\varepsilon -closure\( s \)$ | 能够从NFA的状态$s$开始只通过$\varepsilon$转换到达的NFA状态集合 |
| $\varepsilon -closure\( T \)$ | 能够从$T$中的某个NFA状态$s$开始只通过$\varepsilon$转换到达的NFA状态集合，即$U_{s \in T}\; \varepsilon -closure\( s \)$ |
| $move(T, a)$ | 能够从$T$中的某个状态$s$出发通过标号为$a$的转换到达的NFA状态的集合 |

__计算__$\varepsilon -closure\( T \)$的算法

```C
将T的所有状态压入stack中;
将ε-closure(T)初始化为T;
while(stack非空)｛
    将栈顶元素t弹出;
    for(每个满足如下条件的u:从t出发有一个标号为ε的转换到达状态u) {
        if(u不在ε-closure(T)中) {
            将u加入到ε-closure(T)中；
            将u压入栈中;
        }
    }
}
```

# 7 识别单词的DFA

## 7.1 识别标识符的DFA

__标识符的正则定义如下__

$$
digit \to 0|1|2|...|9 \\
letter\\_ \to A|B|...|Z|a|b|...|z|\\_ \\
id \to letter\\_\( letter\\_|digit \)^*
$$

![fig19](/images/编译原理-词法分析/fig19.jpg)

## 7.2 识别无符号数的DFA

__无符号数的正则定义如下__

$$
digit \to 0|1|2|...|9 \\
digits \to digit\;\;digit^* \\
optionalFraction \to .digits|\varepsilon \\
optionalExponent \to \( E\( +|-|\varepsilon \) digits \) | \varepsilon \\
number \to digits\;\;optionalFraction\;\;optionalExponent
$$

![fig20](/images/编译原理-词法分析/fig20.jpg)

![fig21](/images/编译原理-词法分析/fig21.jpg)

## 7.3 识别各进制无符号整数的DFA

![fig22](/images/编译原理-词法分析/fig22.jpg)

## 7.4 识别注释的DFA

![fig23](/images/编译原理-词法分析/fig23.jpg)

## 7.5 识别Token的DFA

![fig24](/images/编译原理-词法分析/fig24.jpg)

## 7.6 词法分析阶段的错误处理

__词法分析阶段可检测的错误类型__

1. 单词拼写错误
1. 非法字符

__语法错误检测__：如果当前状态与当前输入符号在转换表对应项中的信息为空，而当前状态又不是终止状态，则调用错误处理程序

__错误处理__：查找已扫描字符串中最后一个对应于某终态的字符

* 如果__找到了__，将该字符与其前面的字符识别成一个单词。然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词
* 如果__没找到__，则确定出错，采用错误恢复策略

__错误恢复策略__：

* 最简单的错误恢复策略“恐慌模式(panic mode)”恢复，即从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止

# 8 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《MOOC-编译原理-陈鄞》
