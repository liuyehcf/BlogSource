---
title: 编译原理-词法分析
date: 2017-10-15 10:28:52
mathjax: true
tags: 
- 摘录
categories: 
- 编译
---

__目录__

<!-- toc -->
<!--more-->

# 1 正则表达式

__正则表达式(Regular Expression, RE)__是一种用来描述__正则语言__的更紧凑的表示方法

正则表达式可以由较小的正则表达式按照特定规则__递归__地构建。每个正则表达式{% raw %}$r${% endraw %}定义（表示）一个语言，记为{% raw %}$L(r)${% endraw %}。这个语言也是根据r的__子表达式所表示的语言递归定义__的

## 1.1 正则表达式的定义

1. {% raw %}$\varepsilon${% endraw %}是一个RE，{% raw %}$L(\varepsilon) = \{\varepsilon\}${% endraw %}
1. 如果{% raw %}$a \in \sum${% endraw %}，则{% raw %}$a${% endraw %}是一个RE，{% raw %}$L(a) = \{a\}${% endraw %}
1. 假设{% raw %}$r${% endraw %}和{% raw %}$s${% endraw %}都是RE，表示的语言分别是{% raw %}$L(r)${% endraw %}和{% raw %}$L(s)${% endraw %}，则
    * {% raw %}$r|s${% endraw %}是一个RE，{% raw %}$L(r|s) = L(r) \cup L(s)${% endraw %}
    * {% raw %}$rs${% endraw %}是一个RE，{% raw %}$L(rs) = L(r) L(s)${% endraw %}
    * {% raw %}$r^*${% endraw %}是一个RE，{% raw %}$L(r^*) = (L(r))^*${% endraw %}
    * {% raw %}$(r)${% endraw %}是一个RE，{% raw %}$L((r)) = L(r)${% endraw %}
    * __运算优先级：`() > * > 连接 > |`__

## 1.2 正则语言

可以用RE定义的语言叫做__正则语言(regular language)__或__正则集合(regular set)__

RE的代数定理

![fig1](/images/编译原理-词法分析/fig1.jpg)

## 1.3 正则文法与正则表达式等价

对于任何正则文法{% raw %}$G${% endraw %}，存在定义同一语言的正则表达式{% raw %}$r${% endraw %}

对于任何正则表达式{% raw %}$r${% endraw %}，存在生成同一语言的正则文法{% raw %}$G${% endraw %}

# 2 正则定义

__正则定义__是具有如下形式的__定义序列__：
{% raw %}$$d_1 \to r_1 \\
d_2 \to r_2 \\
... \\
d_n \to r_n \\
$${% endraw %}

* 每个{% raw %}$d_i${% endraw %}都是一个__新符号__，它们都不在字母表{% raw %}$\sum${% endraw %}中，而且__各不相同__
* 每个{% raw %}$r_i${% endraw %}是字母表{% raw %}$\sum \cup \{ d_1, d_2, ..., d_{i-1} \}${% endraw %}上的__正则表达式__

# 3 有穷自动机

有穷自动机(Finite Automata, FA)是由两位神经物理学家MeCuloch和Pitts于1948年首先提出，是对__一类处理系统__所建立的__数学模型__

* 这类系统具有一系列__离散的输入输出信息__和__有穷数目的内部状态__（状态：概括了对过去输入信息处理的情况）
* 系统只需要根据__当前所处的状态__和__当前面临的输入信息__就可以决定系统的__后继行为__。每当系统处理了当前的输入后，系统内部的__状态也将发生改变__

## 3.1 FA模型

![fig2](/images/编译原理-词法分析/fig2.jpg)

FA模型由三部分组成

1. __输入带(input tape)__：用来存放输入符号串
1. __读头(head)__：从左向右逐个读取输入符号，不能修改（只读）、不能往返移动
1. __有穷控制器(finite control)__：具有有穷个状态数，根据__当前的状态__和__当前输入符号__控制转入__下一状态__

## 3.2 FA的表示

__转换图(Transition Graph)可以用来表示FA__，其结构如下

1. __结点__：FA的状态
    * 初始状态（开始状态）：只有一个，由__*start*箭头__指向
    * 终止状态（接收状态）：可能有多个，用双圈表示
1. __带有标记的有向边__
    * 如果对于__输入a__，存在一个从状态p到状态q的转换，就在p、q之间画一条有向边，并标记上a，如下
    * ![fig3](/images/编译原理-词法分析/fig3.jpg)

## 3.3 FA定义（接收）的语言

给定输入串{% raw %}$x${% endraw %}，如果存在一个对应于串{% raw %}$x${% endraw %}的从__初始状态__到__某个终止状态__的转换序列，则称串{% raw %}$x${% endraw %}被该FA接收

由一个有穷自动机{% raw %}$M${% endraw %}(Machine)接收的所有串构成的集合称为是该FA定义（接收）的语言，记为{% raw %}$L(M)${% endraw %}

## 3.4 最长子串匹配原则

当输入串的__多个前缀__与一个或多个模式匹配时，总是选择__最长的前缀__进行匹配

* 在到达某个终态之后，只要输入带上还有符号，DFA就继续前进，以便寻找尽可能长的匹配
* ![fig4](/images/编译原理-词法分析/fig4.jpg)

# 4 有穷自动机的分类

FA的分类

1. __确定的FA(Deterministic finite automata, DFA)__
1. __非确定的FA(Nondeterministic finite automata, NFA)__

## 4.1 确定的有穷自动机(DFA)

{% raw %}$$M = ( S, \sum, \delta, s_0, F )$${% endraw %}

1. {% raw %}$S${% endraw %}：__有穷状态集__
1. {% raw %}$\sum${% endraw %}：__输入字母表__，即输入符号集合。假设{% raw %}$\varepsilon${% endraw %}不是{% raw %}$\sum${% endraw %}中的元素
1. {% raw %}$\delta${% endraw %}：将{% raw %}$S\;\times\;\sum${% endraw %}映射到{% raw %}$S${% endraw %}的__转换函数__。{% raw %}$\forall s \in S, a \in \sum, \delta(s,a)${% endraw %}表示从状态{% raw %}$s${% endraw %}出发，沿着标记为{% raw %}$a${% endraw %}的边所能到达的状态
1. {% raw %}$s_0${% endraw %}：__开始状态__（或初始状态），{% raw %}$s_0 \in S${% endraw %}
1. {% raw %}$F${% endraw %}：__接收状态（或终止状态）集合__，{% raw %}$F \subseteq S${% endraw %}

![fig5](/images/编译原理-词法分析/fig5.jpg)

## 4.2 非确定的有穷自动机(NFA)

{% raw %}$$M = ( S, \sum, \delta, s_0, F )$${% endraw %}

1. {% raw %}$S${% endraw %}：有穷状态集
1. {% raw %}$\sum${% endraw %}：输入字母表，即输入符号集合。假设{% raw %}$\varepsilon${% endraw %}不是{% raw %}$\sum${% endraw %}中的元素
1. {% raw %}$\delta${% endraw %}：将{% raw %}$S\;\times\;\sum${% endraw %}映射到{% raw %}$\textbf{2}^\textbf{S}${% endraw %}的转换函数。{% raw %}$\forall s \in S, a \in \sum, \delta(s,a)${% endraw %}表示从状态{% raw %}$s${% endraw %}出发，沿着标记为{% raw %}$a${% endraw %}的边所能到达的状态__集合__
1. {% raw %}$s_0${% endraw %}：开始状态（或初始状态），{% raw %}$s_0 \in S${% endraw %}
1. {% raw %}$F${% endraw %}：接收状态（或终止状态）集合，{% raw %}$F \subseteq S${% endraw %}

![fig6](/images/编译原理-词法分析/fig6.jpg)

非确定的有穷自动机与确定的有穷自动机的__唯一区别__：

* 确定有穷自动机由__当前状态__和__当前输入符号__可以唯一确定下一个状态
* 非确定有穷自动机由__当前状态__和__当前输入符号__不能唯一确定下一个状态，只能得到一个__状态集合__

## 4.3 DFA和NFA的等价性

对任何非确定的有穷自动机N，存在定义同一语言的确定的有穷自动机D

对任何确定的有穷自动机D，存在定义同一语言的非确定的有穷自动机N

![fig7](/images/编译原理-词法分析/fig7.jpg)

## 4.4 带有{% raw %}$\varepsilon -${% endraw %}边的NFA

{% raw %}$$M = ( S, \sum, \delta, s_0, F )$${% endraw %}

1. {% raw %}$S${% endraw %}：有穷状态集
1. {% raw %}$\sum${% endraw %}：输入字母表，即输入符号集合。假设{% raw %}$\varepsilon${% endraw %}不是{% raw %}$\sum${% endraw %}中的元素
1. {% raw %}$\delta${% endraw %}：将{% raw %}$S\;\times\;(\sum \cup \{ \varepsilon \})${% endraw %}映射到{% raw %}$\textbf{2}^\textbf{S}${% endraw %}的转换函数。{% raw %}$\forall s \in S, a \in (\sum \cup \{ \varepsilon \}), \delta(s,a)${% endraw %}表示从状态{% raw %}$s${% endraw %}出发，沿着标记为{% raw %}$a${% endraw %}的边所能到达的状态__集合__
1. {% raw %}$s_0${% endraw %}：开始状态（或初始状态），{% raw %}$s_0 \in S${% endraw %}
1. {% raw %}$F${% endraw %}：接收状态（或终止状态）集合，{% raw %}$F \subseteq S${% endraw %}

![fig8](/images/编译原理-词法分析/fig8.jpg)

## 4.5 带有和不带有{% raw %}$\varepsilon -${% endraw %}边NFA等价

![fig9](/images/编译原理-词法分析/fig9.jpg)

## 4.6 DFA算法的实现

__输入__：以文件结束符eof结尾的字符串{% raw %}$x${% endraw %}。DFA {% raw %}$D${% endraw %}的开始状态{% raw %}$s_0${% endraw %}，接收状态集{% raw %}$F${% endraw %}，转换函数{% raw %}$move${% endraw %}
__输出__：如果{% raw %}$D${% endraw %}接收{% raw %}$x${% endraw %}，则回答“yes”，否则回答“no”
__方法__：将下述算法应用于输入串{% raw %}$x${% endraw %}

* 函数`nextChar()`返回输入串{% raw %}$x${% endraw %}的下一个符号
* 函数`move(s, c)`返回从状态{% raw %}$s${% endraw %}出发，沿着标记为{% raw %}$c${% endraw %}的边所能到达的状态

```C
s = s0;
c = nextChar();
while(c != eof) {
    s = move(s, c);
    c = nextChar();
}

if(s in F) return "yes";
else return "no";
```

# 5 从正则表达式到有穷自动机

从正则表达式转换到DFA比较困难，但是从正则表达式转换到带有{% raw %}$\varepsilon -${% endraw %}边的NFA是比较容易的

![fig10](/images/编译原理-词法分析/fig10.jpg)

## 5.1 根据RE构造NFA

1. {% raw %}$\varepsilon${% endraw %}对应的NFA
    * ![fig11](/images/编译原理-词法分析/fig11.jpg)
1. 字母表{% raw %}$\sum${% endraw %}中符号{% raw %}$a${% endraw %}对应的NFA
    * ![fig12](/images/编译原理-词法分析/fig12.jpg)
1. {% raw %}$r = r_1r_2${% endraw %}对应的NFA
    * ![fig13](/images/编译原理-词法分析/fig13.jpg)
1. {% raw %}$r = r_1 | r_2${% endraw %}对应的NFA
    * ![fig14](/images/编译原理-词法分析/fig14.jpg)
1. {% raw %}$r = r1^*${% endraw %}对应的NFA
    * ![fig15](/images/编译原理-词法分析/fig15.jpg)

__下面以一个例子进行说明__，{% raw %}$RE = (a|b)^*abb${% endraw %}

* ![fig16](/images/编译原理-词法分析/fig16.jpg)
* __转化的过程，就是将复合表达式进行拆分的过程__

# 6 从NFA到DFA的转换

![fig17](/images/编译原理-词法分析/fig17.jpg)

__以上图中的例子进行说明__

* 起始状态{% raw %}$A${% endraw %}，在接收到字符{% raw %}$a${% endraw %}后，下一个__状态集合__是{% raw %}$\{A、B\}${% endraw %}
* 我们将__状态集合__{% raw %}$\{A、B\}${% endraw %}单独作为DFA中的一个状态。状态{% raw %}$\{B、C\}${% endraw %}、{% raw %}$\{C、D\}${% endraw %}同理
* 在NFA中，状态{% raw %}$A${% endraw %}接收字符{% raw %}$a${% endraw %}后，转换到__状态集合__{% raw %}$\{A、B\}${% endraw %}，因此，在DFA中，__状态__{% raw %}$\{A、B\}${% endraw %}接收字符{% raw %}$a${% endraw %}后，转换到__状态__{% raw %}$\{A、B\}${% endraw %}
* 在NFA中，状态{% raw %}$B${% endraw %}接收字符{% raw %}$b${% endraw %}后，转换到__状态集合__{% raw %}$\{B、C\}${% endraw %}，因此，在DFA中，__状态__{% raw %}$\{A、B\}${% endraw %}接收字符{% raw %}$b${% endraw %}后，转换到__状态__{% raw %}$\{B、C\}${% endraw %}
* 其他同理，不再赘述

![fig18](/images/编译原理-词法分析/fig18.jpg)

## 6.1 子集构造法(subset construction)

__输入__：NFA N
__输出__：接收同样语言的DFA D
__方法__：一开始，{% raw %}$\varepsilon -closure( s_0 )${% endraw %}是Dstates中的唯一状态，且它未加标记

```C
while(在Dstates中有一个未标记状态T)｛
    给T加上标记;
    for(每个输入符号a)｛
        // 首先，move(T, a)函数返回的是一个集合
        // 然后，通过ε-closure(T)计算出包含ε-边的集合
        // 注意到，这里的U在NFA中是一个状态集合，但是对于DFA而言仅是一个状态，理解这一点很重要
        U = ε-closure(move(T, a));

        // 如果状态U是一个新状态，那么将其加入Dstates中
        if(U不在Dstates中) {
            将U加入到Dstates中，且不加标记;
        }

        // 在DFA D中，状态T在输入a时转移到状态U，即画一条边
        Dtran[T, a]=U;
    }
}
```

| 操作 | 描述 |
|:--|:--|
| {% raw %}$\varepsilon -closure( s )${% endraw %} | 能够从NFA的状态{% raw %}$s${% endraw %}开始只通过{% raw %}$\varepsilon${% endraw %}转换到达的NFA状态集合 |
| {% raw %}$\varepsilon -closure( T )${% endraw %} | 能够从{% raw %}$T${% endraw %}中的某个NFA状态{% raw %}$s${% endraw %}开始只通过{% raw %}$\varepsilon${% endraw %}转换到达的NFA状态集合，即{% raw %}$U_{s \in T}\; \varepsilon -closure( s )${% endraw %} |
| {% raw %}$move(T, a)${% endraw %} | 能够从{% raw %}$T${% endraw %}中的某个状态{% raw %}$s${% endraw %}出发通过标号为{% raw %}$a${% endraw %}的转换到达的NFA状态的集合 |

__计算__{% raw %}$\varepsilon -closure( T )${% endraw %}的算法，__该过程类似于BFS算法__

```C
将T的所有状态压入stack中;
将ε-closure(T)初始化为T;
while(stack非空)｛
    将栈顶元素t弹出;
    for(每个满足如下条件的u:从t出发有一个标号为ε的转换到达状态u) {
        if(u不在ε-closure(T)中) {
            将u加入到ε-closure(T)中
            将u压入栈中;
        }
    }
}
```

# 7 识别单词的DFA

## 7.1 识别标识符的DFA

__标识符的正则定义如下__

{% raw %}$$
digit \to 0|1|2|...|9 \\
letter\_ \to A|B|...|Z|a|b|...|z|\_ \\
id \to letter\_( letter\_|digit )^*
$${% endraw %}

![fig19](/images/编译原理-词法分析/fig19.jpg)

## 7.2 识别无符号数的DFA

__无符号数的正则定义如下__

{% raw %}$$
digit \to 0|1|2|...|9 \\
digits \to digit\;\;digit^* \\
optionalFraction \to .digits|\varepsilon \\
optionalExponent \to ( E( +|-|\varepsilon ) digits ) | \varepsilon \\
number \to digits\;\;optionalFraction\;\;optionalExponent
$${% endraw %}

![fig20](/images/编译原理-词法分析/fig20.jpg)

![fig21](/images/编译原理-词法分析/fig21.jpg)

## 7.3 识别各进制无符号整数的DFA

![fig22](/images/编译原理-词法分析/fig22.jpg)

## 7.4 识别注释的DFA

![fig23](/images/编译原理-词法分析/fig23.jpg)

## 7.5 识别Token的DFA

![fig24](/images/编译原理-词法分析/fig24.jpg)

## 7.6 词法分析阶段的错误处理

__词法分析阶段可检测的错误类型__

1. 单词拼写错误
1. 非法字符

__语法错误检测__：如果当前状态与当前输入符号在转换表对应项中的信息为空，而当前状态又不是终止状态，则调用错误处理程序

__错误处理__：查找已扫描字符串中最后一个对应于某终态的字符

* 如果__找到了__，将该字符与其前面的字符识别成一个单词。然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词
* 如果__没找到__，则确定出错，采用错误恢复策略

__错误恢复策略__：

* 最简单的错误恢复策略“恐慌模式(panic mode)”恢复，即从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止

# 8 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf#163.com，#替换成@)，博主将在第一时间删除__

* 《MOOC-编译原理-陈鄞》
