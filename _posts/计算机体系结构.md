---
title: 计算机体系结构
date: 2021-11-16 09:19:25
tags: 
- 摘录
categories: 
- System Architecture
---

**阅读更多**

<!--more-->

# 1 概述

## 1.1 引言

**系统和系统架构：**

1. **系统是为实现一个或多个所声明的目标而组织的相互关联的要素的组合**
1. **系统架构是系统组件的组织结构、它们之间的关系、与环境的关系、以及指导其设计和进化的原则**

**体系结构的定义：**

1. **设计、选择和连接硬件组件以及设计硬件/软件接口，以创建一个满足功能、性能、能耗、成本和其他具体目标的计算系统的科学和艺术**
1. **体现为描述计算机系统的功能、结构组织和实现的一组规则和方法**
* **广义：计算机体系结构指计算机（硬件）系统的抽象表示，基于这些抽象表示使得我们可以更好地使用可用的制造技术实现（信息处理）硬件系统，高效地设计与实现（信息处理）软件系统**

**计算机体系结构研究范畴：**

* **早期定义（Amdahl, Blaauw, and Brooks, 1964）：程序员可见的计算系统的属性。包括：概念性的结构和功能行为。不包括：数据流和控制流的组织、逻辑设计以及物理实现**
* **狭义：计算机体系结构是软件设计者与硬件设备设计者（VLSI）之间的中间层（ISA），以及微体系结构**
* **扩展的观点：计算机体系结构包括：算法层、程序/语言层、系统软件层、ISA层、微体系结构、逻辑电路层、以及器件层**

**计算机组成与实现：**

* **计算机组成（Computer Organization or Microarchitecture)：ISA的逻辑实现。包括，物理机器级中的数据流和控制流的组成以及逻辑设计等**
* **计算机实现（Computer Implementation)：计算机组成的物理实现。包括，`CPU`，`MEMORY`等的物理结构，器件的集成度、速度，模块、插件、底板的划分与连接、信号传输、电源、冷却及整机装配技术等**

## 1.2 量化设计与分析基础

**管理复杂性：**

* 将工程师或计算机科学家与门外汉区分开来的特征之一是管理复杂性的系统方法
* 现代数字系统是由数百万甚至数十亿个晶体管组成的。没有人能够通过写出描述每个晶体管中电子运动的方程并同时解出所有方程来理解这些系统
* **管理复杂性的方法：抽象 (Abstraction)+ 原则 (Discipline)+ 3'Y**

**影响体系结构技术发展的主要因素：**

* 产品应用方面：`PC/Server => IoT, Mobile/Cloud`
* 集成电路技术方面：
    * 登纳德缩放比例定律的终结：功耗成为关键制约条件
    * Moore定律的终结：晶体管的集成度提高延缓
* 体系结构方面
    * 挖掘指令级并行性方面的限制和低效，04年结束了单处理器时代
    * Amdahl定律暗示了简单多核时代的结束

## 1.3 定量分析基础

**过去数十年间，计算机系统设计方面的巨大变化**

* 在过去的50年，`Moore's law`和`Dennard scaling`(登纳德缩放比例定律)主宰着芯片产业的发展
    * `Moore`在1965年预测：晶体管数量随着尺寸缩小按接近平方关系增长（每18个月翻倍）
    * `Dennard`在1974年预测：晶体管尺寸变小，功耗会同比变小（相同面积下功耗不变）
    * 工艺技术的进步可在不改变软件模型的情况下，持续地提高系统性能/能耗比
* 最近10年间，工艺技术的发展受到了很大制约
    * Dennard scaling over (supply voltage ~fixed)
    * Moore's Law (cost/transistor) over?
    * Energy efficiency constrains everything
* 功耗问题成为系统结构设计必须考虑的问题
* 软件设计者必须考虑
    * Parallel systems
    * Heterogeneous systems

**有关体系结构的新旧观念**

* **旧观念：**
    * 能源很便宜，晶体管很贵
    * 通过编译、体系结构创新来增加指令级并行
    * 乘法器速度较慢，访存速度比较快
    * 单处理器性能，每1.5年翻倍
* **新观念：**
    * 能源很贵，晶体管很便宜
    * 挖掘指令级并行的收益越来越小
    * 乘法器速度提升了，访存成为瓶颈
    * `Power Wall + ILP Wall + Memory Wall = Brick Wall`，单处理器性能，每5年翻倍
    * 每2年，单个芯片上的处理器数量翻倍

**性能：**

* 性能度量
    * 响应时间
    * 吞吐率
* CPU执行时间=`IC * CPI * T`
    * `CPI`指的是`Cycles per Instruction`
* `Latency`与`Bandwidth`
    * `Latency`指单个任务的执行时间，`Bandwidth`指单位时间完成的任务量（rate）
    * `Latency`的提升滞后于带宽的提升 (在过去的30年）
* `Amdahl's Law`用来度量加速比
    * 性能提升受限于任务中可加速部分所占的比例
    * 应用于多处理器系统的基本假设：在给定的问题规模下，随着处理器数目的增加性能的变化
* `Benchmarks`：指一组用于测试的程序
    * 比较计算机系统的性能 （算术平均、调和平均、几何平均）

## 1.4 相关课件

* [Chapter-1.1](/Papers/System-Architecture/1-1.pdf)
* [Chapter-1.2](/Papers/System-Architecture/1-2.pdf)
* [Chapter-1.3](/Papers/System-Architecture/1-3.pdf)

# 2 ISA

## 2.1 ISA的基本概念

**什么是指令集架构？**

* 软件子系统与硬件子系统的关键界面
* 一组直接由硬件执行的指令，包括
    * 程序员可见的机器状态
    * 程序员可见的指令集合（操作机器状态的指令）
* 应具备的特征（七个衡量指标）
    1. 成本
    1. 简洁性
    1. 架构和具体实现分离：可持续多代，以保持向后兼容
    1. 可扩展空间：可用于不同应用领域（desktops、servers、embedded applications）
    1. 程序大小：所生成的代码占用空间小
    1. 易于编程/编译/链接：为高层软件的实现与开发提供方便的功能
    1. 性能：方便低层硬件子系统高效实现

**重要的系统界面（System Interface）：**

* `ISA`界面
* `ABI`界面

**`ISA`：用户级`ISA`+特权级`ISA`**

* 用户级ISA适用于操作系统和应用程序
* 特权级ISA适用于硬件资源的管理（操作系统）

**ISA必须说明哪些东西？**

* 指令格式
* 存储器寻址
* 操作数的类型和大小
* 所支持的操作
* 控制转移类指令

**尾端问题：在一个字内部的字节顺序问题，以int（`0x12345678`）为例**

* `Little Endian`：高位在前，但是每个字节内部的`bit`还是按原来的顺序存放，即`0x78->0x56->0x34->0x12`
* `Big Endian`：低位在前，即`0x12->0x34->0x56->0x78`

**寻址方式：**

| Model | Example | Meaning | When used |
|:--|:--|:--|:--|
| Register | `Add R1, R2` | `R1 ← R1 + R2` | 操作数在寄存器中 |
| Immediate | `Add R1, 100` | `R1 ← R1 + 100` | 立即数寻址，常量 |
| Register Indirect | `Add R1, (R2)` | `R1 ← R1 + Mem(R2)` | `R2`存储的是地址 |
| Displacement | `Add R1, (R2 + 16)` | `R1 ← R1 + Mem(R2 + 16)` | 访问局部变量 |
| Absolute | `Add R1, (1000)` | `R1 ← R1 + Mem(1000)` | 访问静态变量 |
| Indexed | `Add R1, (R2 + R3)` | `R1 ← R1 + Mem(R2 + R3)` | 偏移寻址，`R2 = base`、`R3 = index` |
| Scaled Index | `Add R1, (R2 + s * R3)` | `R1 ← R1 + Mem(R2 + s * R3)` | `s = scale factor(2,4,8)` |
| Post-increment | `Add R1, (R2)+` | `R1 ← R1 + Mem(R2)`</br>`R2 ← R2 + s` | 向后跳过`array`，其中`s = element size` |
| Pre-decrement | `Add R1, -(R2)` | `R2 ← R2 - s`</br>`R1 ← R1 + Mem(R2)` | 向前跳过`array`，其中`s = element size` |

**操作数的类型、表示和大小：**

* 操作数类型和操作数表示是软硬件的主要界面之一
* 操作数类型：是面向应用、面向软件系统所处理的各种数据类型
* 操作数的表示：操作数在机器中的表示，硬件结构能够识别，指令系统可以直接使用的表示格式

**控制类指令：**

1. 条件分支`Conditional Branch`
1. 跳转`Jump`
1. 过程调用`Procedure calls`
1. 过程返回`Procedure returns`

**指令格式选择策略**

* 如果代码规模最重要，那么使用变长指令格式
* 如果性能至关重要，使用固定长度指令
* 有些嵌入式CPU附加可选模式，由每一应用自己选择性能还是代码量

## 2.2 ISA的功能设计

**功能设计：**

* 任务：确定硬件支持哪些操作
* 方法：统计的方法

**CISC：**

* 目标：强化指令功能，减少运行的指令条数，提高系统性能
* 方法：面向目标程序的优化，面向高级语言和编译器的优化

**RISC：**

* 目标：通过简化指令系统，用高效的方法实现最常用的指令
* 方法：充分发挥流水线的效率，降低CPI

### 2.2.1 CISC

**目标：强化指令功能，减少指令条数，以提高系统性能**

**基本优化方法：**

1. **面向目标程序的优化是提高计算机系统性能最直接的方法**
    * 优化目标：
        * 缩短程序长度
        * 缩短程序的执行时间
    * 优化方法：
        * 统计分析目标程序执行情况，找出使用频率高，执行时间长的指令或指令串
        * 优化使用频度高的指令
        * 用心得指令代替使用频度高的指令串
    * 主要优化途径：
        1. 增强运算型指令的功能
        1. 增强数据传送类指令的功能
        1. 增强程序控制指令的功能
1. **面向高级语言和编译程序改进指令系统**
    * 优化目标：
        * 缩小`HL-ML`之间的差距
    * 优化方法：
        1. 增强面向`HL`和`Compiler`支持的指令功能
            * 统计分析源程序中各种语句的使用频度和执行时间
            * 增强相关指令的功能，优化使用频度高、执行时间长的语句
            * 增加专门指令，以缩短目标程序长度，减少目标程序执行时间，缩短编译时间
        2. 高级语言计算机系统：缩小`HL`和`ML`的差别
            * 极端：`HL=ML`，即所谓的高级语言计算机高级语言不需要经过编译，直接由机器硬件来执行
            * 如`LISP`机，`PROLOG`机
        3. 支持操作系统的优化实现：特权指令
            * 处理器工作状态和访问方式的转换
            * 进程的管理和切换
            * 存储管理和信息保护
            * 进程同步和互斥，信号量的管理等

### 2.2.2 RISC

**目标：通过简化指令系统，用最高效的方法实现最常用的指令**

**`RISC`是一种计算机体系结构的设计思想，它不是一种产品**

**`RISC`是近代计算机体系结构发展史中的一个里程碑**

**早期对RISC特点的描述：**

* 大多数指令在单周期内完成
* 采用`Load/Store`结构
* 硬布线控制逻辑
* 少指令和寻址方式的种类
* 固定的指令格式
* 注重代码的优化

**从目前的发展看，`RISC`体系结构还应具有如下特点：**

* 面向寄存器结构
* 十分重视流水线的执行效率－尽量减少断流
* 重视优化编译技术

**减少指令平均执行周期数是`RISC`思想的精华**

**`RISC`如何降低`CPI`：**

* 硬件方面：
    * 硬布线控制逻辑
    * 减少指令和寻址方式的种类
    * 使用固定格式
    * 采用Load/Store
    * 指令执行过程中设置多级流水线
* 软件方面：十分强调优化编译的作用

### 2.2.3 典型ISA

#### 2.2.3.1 MIPS

**MIPS是最典型的RISC 指令集架构：**

* `Stanford` (1980)提出
* 第一个商业实现是`R2000`（1986）
* 最初的设计中，其整数指令集仅有58条指令，直接实现单发射、顺序流水线
* 30年来，逐步增加到约400条指令。

**主要特征：**

* `Load/Store`型结构
* `ALU`类指令的操作数来源于寄存器或立即数
* 降低了`ISA`和硬件的复杂性，方便了流水线的实现
* 依赖于优化编译技术

**主要缺陷：**

* 针对特定的微体系架构的实现方式（5级流水、单发射、顺序流水线）进行过度的优化设计
* `ISA`对位置无关的代码（position-independent code, PIC)支持不足
* 16位位宽立即数消耗了大量编码空间，只有少量的编码空间可供扩展指令
* 乘除指令使用了特殊的寄存器（`HI`，`LO`)，导致上下文切换内容、指令条数、代码尺寸增加，微架构实现复杂
* 除了技术方面，`MIPS`是非开放的专属指令集，不能自由使用

#### 2.2.3.2 SPARC

**`Sun Microsystems`的专属指令集**

**`SPARC V8`主要特征**

* 用户级整型`ISA`90条指令
* 硬件支持`IEEE 754-1985`标准的浮点数50条
* 特权级指令20条

**主要问题：**

* `SPARC`使用了寄存器窗口来加速函数调用。当函数调用所需的栈空间超过了窗口的寄存器数，性能会急剧下降。对于所有的实现来说，寄存器窗口都消耗很大的面积和功耗
* 分支使用条件码。这些条件码由于在一些指令之间创建了额外的依赖关系，增加了体系结构状态并使实现复杂化
* `load`和`store`相邻寄存器对的指令。对于简单的微体系结构很有吸引力，可以在增加很少硬件复杂性的情况下提高吞吐量。遗憾的是当使用寄存器重命名时使实现复杂化，因为在寄存器文件中数据在物理上可能不再相邻
* 浮点寄存器文件和整数寄存器文件之间的移动必须使用内存系统作为中介，限制了系统性能
* 唯一的原子内存操作是`fetch-and-store`，这对于实现许多无等待的数据结构是不够的

#### 2.2.3.3 Alpha（DEC）

**主要特征：**

* 摒弃了当时非常吸引人的特性，如分支延迟、条件码、寄存器窗口等
* 创建了64位寻址空间、设计简洁、实现简单、高性能的ISA
* `Alpha`架构师仔细地将特权体系结构和硬件平台的大部分细节隔离在抽象接口（特权体系结构库）后面（PALcode）

**主要问题：DEC对顺序微架构的Alpha进行了过度优化，并添加了一些不太适合现代实现的特性**

* 为了追求高时钟频率，`ISA`的原始版本避免了8位和16位的`load/store`指令，实际上创建了一个字寻址的内存系统。为了补偿广泛使用这些（非字）操作的应用程序性能，添加了特殊的未对齐的`load/store`指令以及一些整数指令来加速重新对齐操作
* 为了方便长延迟浮点指令的乱序完成，`Alpha`有一个非精确的浮点陷阱模型。这一决定单独来看是可以的。但是`ISA`还规定：如果使用这种浮点陷阱模型，必须由软件处理例程来给出异常标记和默认值
* `Alpha`缺少整数除法指令，建议使用软件牛顿迭代法实现，导致浮点除法速度高于整数除法
* 与其他前期的`RISC`一样，没有预先考虑可能的压缩指令集扩展，因此没有足够的操作码空间来进行更新
* `ISA`包含有条件的`mov`操作，这使得带有寄存器重命名的微架构复杂化
* 使用商业`Alpha ISAs`的一个重要风险：它们可能会被摒弃

#### 2.2.3.4 ARMv7

**`ARMv7`是32位`RISC ISA`**

* 使用最广的体系结构
    * 当我们权衡指令集（选择`vs`重新设计）时，`ARMv7`是一个自然的选择
    * 大量的软件已经移植到该`ISA`上，在嵌入式和移动设备中无处不在
* 是一个封闭的标准，剪裁或扩充是不允许的，即使是微架构的创新也仅限于那些能够获得ARM所称的架构许可的组织
* `ARMv7`十分庞大复杂。整型类指令600+条

**即使知识产权不是问题，它仍然存在一些技术缺陷：**

* 不支持64位地址，`ISA`缺乏硬件支持`IEEE754-2008`标准（`ARMv8`纠正了这些缺陷）
* 特权体系结构的细节渗透到用户级体系结构的定义中
* `ISA`中包含了许多实现复杂的特性。例如程序计数器PC是整数寄存器组的成员，这意味着几乎任何指令都可以改变控制流（比如`ADD`指令）

#### 2.2.3.5 ARMv8

**2011年，`ARM`发布新的`ISA ARMv8`**

* 64位地址；扩展了整型寄存器组
* 摒弃了`ARMv7`中实现复杂的一些特性

**主要问题：**

* 使用条件码
* 存在许多特殊的寄存器
* 指令集更加厚重：1070条指令，53种格式，8种寻址方式。说明文档达到了5778页
* 以暴露底层实现的方式将用户级`ISA`和特权级`ISA`紧密地结合在一起
* 随着`ARMv8`的引入，`ARM`不再支持压缩指令编码
* `ARMv8`也是一个封闭的标准

#### 2.2.3.6 OpenRISC

**OpenRISC项目是一个开放源码处理器设计项目**

* 来源于`Hennessy`和`Patterson`的体系结构教科书`DLX ISA`
* 适用于教学、科研和工业界的实现

**主要问题：**

* OpenRISC项目主要是开源处理器设计项目，而不是开源的`ISA`规格说明，ISA和实现是紧密耦合的
* 固定的32位编码与16位立即数阻碍了压缩`ISA`扩展
* 不支持`IEEE 754-2008`标准
* 用于分支和有条件mov的条件码使高性能实现复杂化
* `ISA`对位置无关的寻址方式支持较弱
* `OpenRISC`不利于虚拟化。从异常返回的指令`L.RFE`，定义为在用户模式下功能，而不是捕获

#### 2.2.3.7 80x86

**`Intel 8086`架构是过去40年里 笔记本电脑、台式机和服务器市场上最流行的指令集**

* 除了嵌入式系统领域，几乎所有流行的软件都被移植到x86上，或者是为x86开发的
* 它受欢迎的原因有很多：该架构在`IBM PC`诞生之初的偶然可用性；英特尔专注于二进制兼容性；它们积极的卓有成效的微结构实现；以及他们的前沿制造技术
* 指令集设计质量并不是它流行的原因之一

**主要问题：**

* 1300条指令，许多寻址方式，很多特殊寄存器，多种地址翻译方式，从`AMD K5`微架构开始，所有的`Intel`支持乱序执行的微结构，都是动态地将x86指令翻译为内部的`RISC`风格的指令集。
* 不利于虚拟化。因为一些特权指令在用户模式下会无声地失败，而不是被捕获。`VMware`的工程师们用动态二进制翻译软件解决了这一缺陷
* `ISA`的指令长度为任意整数字节数，最多为15个字节，数量较少的短操作码已经被随意使用
* `ISA`有数量极少的寄存器组
* 大多数整数寄存器在`ISA`中执行特殊功能，加剧了体系结构寄存器的不足
* 更糟糕的是，大多数x86指令只有一种破坏性的指令格式，它会覆盖其中一个源操作数
* 一些`ISA`特性，包括隐式条件码和带有谓词的mov操作，在微架构中实现复杂

**80x86是一个专有指令集**

#### 2.2.3.8 小结

|  | MIPS | SPARAC | Alpha | ARMv7 | ARMv8 | OpenRISC | 80x86 |
|:--|:--|:--|:--|:--|:--|:--|:--|
| Free and Open |  | ✅ |  |  |  | ✅ |  |
| 64-bit Address | ✅ | ✅ | ✅ |  | ✅ | ✅ | ✅ |
| Compressed Instructions | ✅ |  |  | ✅ |  |  | Partial |
| Separate Privileged ISA |  |  | ✅ |  |  |  |  |
| Position-Indep. Code | Partial |  |  | ✅ | ✅ |  | ✅ |
| IEEE 754-2008 |  |  |  |  | ✅ |  | ✅ |
| Classically Virtualizable | ✅ | ✅ | ✅ |  | ✅ |  |  |

## 2.3 相关课件

* [Chapter-2.1](/Papers/System-Architecture/2-1.pdf)
* [Chapter-2.2](/Papers/System-Architecture/2-2.pdf)
* [Chapter-2.3](/Papers/System-Architecture/2-3.pdf)

# 3 基本流水线

## 3.1 相关课件

* [Chapter-3.1](/Papers/System-Architecture/3-1.pdf)
* [Chapter-3.2](/Papers/System-Architecture/3-2.pdf)

# 4 存储层次结构设计

## 4.1 相关课件

* [Chapter-4.1](/Papers/System-Architecture/4-1.pdf)
* [Chapter-4.2](/Papers/System-Architecture/4-2.pdf)
* [Chapter-4.3](/Papers/System-Architecture/4-3.pdf)
* [Chapter-4.4](/Papers/System-Architecture/4-4.pdf)

# 5 指令级并行

## 5.1 相关课件

* [Chapter-5.1](/Papers/System-Architecture/5-1.pdf)
* [Chapter-5.2](/Papers/System-Architecture/5-2.pdf)
* [Chapter-5.3](/Papers/System-Architecture/5-3.pdf)
* [Chapter-5.4](/Papers/System-Architecture/5-4.pdf)
* [Chapter-5.5](/Papers/System-Architecture/5-5.pdf)
* [Chapter-5.6](/Papers/System-Architecture/5-6.pdf)
* [Chapter-5.7](/Papers/System-Architecture/5-7.pdf)

# 6 数据级并行

## 6.1 相关课件

* [Chapter-6.1](/Papers/System-Architecture/6-1.pdf)
* [Chapter-6.2](/Papers/System-Architecture/6-2.pdf)
* [Chapter-6.3](/Papers/System-Architecture/6-3.pdf)
* [Chapter-6.4](/Papers/System-Architecture/6-4.pdf)

# 7 多处理器及线程级并行

## 7.1 相关课件

* [Chapter-7.1](/Papers/System-Architecture/7-1.pdf)
* [Chapter-7.2](/Papers/System-Architecture/7-2.pdf)
* [Chapter-7.3](/Papers/System-Architecture/7-3.pdf)

# 8 缩写表

| 缩写 | 全称 |
|:--|:--|
| `ISA` | Instruction-Set Architecture |
| `VLIW` | Very Long Instruction Word |
| `EPIC` | Explicitly Parallel Instruction Computing |
| `CISC` | Complex Instruction Set Computer |
| `RISC` | Reduced Instruction Set Computer |
| `CPI` | Cycles per Instruction |
| `MIPS` | Millions of Instructions Per Second |
| `ABI` | Application Binary Interface |
| `HL`/`ML` | High Level/Machine Level |

# 9 参考

* [计算机体系结构(Spring 2021)](http://staff.ustc.edu.cn/~xhzhou/CA-Spring2021/CA.html)
