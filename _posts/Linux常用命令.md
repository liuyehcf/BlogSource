---
title: Linux常用命令
date: 2017-08-15 20:17:57
tags: 
- 摘录
categories: 
- 操作系统
- Linux
---

__目录__

<!-- toc -->
<!--more-->

# 1 字符串处理命令

## 1.1 sed

__格式：__

* `sed [-nefr] [动作] [文件]`
* `STD IN | sed [-nefr] [动作]`

__参数说明：__

* `-n`：使用安静(silent)模式，在一般sed中，所有来自STDIN的数据一般都会被列到屏幕上，加了参数-n后，只有经过sed特殊处理的那一行才会被列出来
* `-e`：直接在命令行模式上进行sed的动作编辑
* `-f`：直接将sed的动作写在一个文件内，`-f filenmae`则可以执行filename内的sed动作
* `-r`：sed的动作支持的是扩展正则表达式的语法
* `-i`：直接修改读取的文件内容，而不是由屏幕输出

__动作说明，格式为`[n1 [,n2]]function`，接的动作必须以两个单引号括住__

* `a`：新增，a的后面可接字符串，而这些字符串会在新的一行出现(目前行的下一行)
* `c`：替换，c的后面可接字符串，这些字符串可以替换n1,n2之间的行
* `d`：删除，后面通常不接任何参数
* `i`：插入，i的后面可接字符串，而这些字符串会在新的一行出现(目前行的上一行)
* `p`：打印，也就是将某个选择的数据打印出来，通常p会与参数sed -n一起运行
* `s`：替换，可以直接进行替换的工作，通常这个s可以搭配正则表达式，例如1,20s/lod/new/g  (跟vim里面的很像！！！)

__示例：__

* `sed '2d' example`  <==删除example文件第二行
* `sed '2,$d' example`  <==删除第二至最后一行(注意这里$是代表最后一行的意思，而vim里面的操作以及正则表达式中$都代表行末)
* `sed '$d' example`  <==删除example文件最后一行
* `sed '/test/d' example`   <==删除example文件包含test的所有行
* `sed 's/test/mytest/g' example`  <==在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest
* `sed -n 's/^test/mytest/p' example`  <==(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它
* `sed 's/^192.168.0.1/&localhost/' example`  <==&符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1localhost
* `sed -n 's/\(love\)able/\1rs/p' example`  <==love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来
* `sed -n '/test/,/check/p' example`  <==所有在test和check所确定的范围内的行都被打印。逗号作用：选定行的范围
* `sed -n '5,/^test/p' example`  <==打印从第五行开始到第一个包含以test开始的行之间的所有行
* `sed '/test/,/check/s/$/sed test/' example`  <==对于模板test和west之间的行，每行的末尾用字符串sed test替换

## 1.2 awk

相比于sed(管道命令)常常作用于一整行的处理，awk(管道命令)则比较倾向于将一行分成数个"字段"来处理，因此awk相当适合处理小型的数据处理

__格式：__

* `awk [-F] '条件类型1{动作1} 条件类型2{动作2}...' [filename]`

__参数说明：__

* `-F`：后接分隔符。例如：`-F ':'`、`-F '[,.;]'`

注意awk后续的所有动作都是以单引号括住的，而且如果以print打印时，非变量的文字部分，包括格式等(例如制表`\t`、换行`\n`等)都需要以双引号的形式定义出来，因为单引号已经是awk的命令固定用法了。例如`last -n 5 | awk '{print $1 "\t" $3}'`

__awk处理流程：__

1. 读入第一行，并将第一行的数据填入$0,$1,...等变量中
1. 依据条件类型的限制，判断是否需要进行后面的动作
1. 做完所有的动作与条件类型
1. 若还有后续的'行'，重复上面的步骤，直到所有数据都读取完为止

__awk内置变量：__

* ARGC：命令行参数个数
* ARGV：命令行参数排列
* ENVIRON：支持队列中系统环境变量的使用
* FILENAME：awk浏览的文件名
* FNR：浏览文件的记录数
* __FS：设置输入域分隔符，默认是空格键，等价于命令行 -F选项__
* __NF：每一行($0)拥有的字段总数__
* __NR：目前awk所处理的是第几行__
* OFS：输出域分隔符
* ORS：输出记录分隔符
* RS：控制记录分隔符
* 在动作内部引用这些变量不需要用$，例如`last -n 5 | awk '{print $1 "\t  lines: " NR "\t columes: " NF}'`
* 此外，$0变量是指整条记录。$1表示当前行的第一个域，$2表示当前行的第二个域，以此类推。

__动作说明：__

* 所有awk的动作，即在{}内的动作，如果有需要多个命令辅助时，可以用分号";"间隔，或者直接以[Enter]按键来隔开每个命令

__BEGIN与END__

* 在Unix awk中两个特别的表达式，BEGIN和END，这两者都可用于pattern中（参考前面的awk语法），__提供BEGIN和END的作用是给程序赋予初始状态和在程序结束之后执行一些扫尾的工作。__
* __任何在BEGIN之后列出的操作（在{}内）将在Unix awk开始扫描输入之前执行，而END之后列出的操作将在扫描完全部的输入之后执行。__因此，通常使用BEGIN来显示变量和预置（初始化）变量，使用END来输出最终结果。

__示例：__

* `cat /etc/passwd | awk '{FS=":"} $3<10 {print $1 "\t" $3}'`，__注意`{FS=":"}`是作为一个动作存在的，因此从第二行开始分隔符才变为":"，第一行分隔符仍然是空格__。
* `cat /etc/passwd | awk 'BEGIN {FS=":"} $3<10 {print $1 "\t" $3}'`。__这样写`{FS=":"}`在处理第一行时也会生效__
* 
```shell
awk 
'BEGIN {FS=":";print "统计销售金额";total=0} 
{print $3;total=total+$3;} 
END {print "销售金额总计：",total}' sx
```

## 1.3 grep

grep分析一行信息，若当前有我们所需要的信息，就将该行拿出来

__格式：__

* `grep [-acinvrAB] [--color=auto] '查找的字符串' filename`

__参数说明：__

* `-a`：将binary文件以text文件的方式查找数据
* `-c`：计算找到'查找字符串'的次数
* `-i`：忽略大小写的不同
* `-n`：顺便输出行号
* `-v`：反向选择，即输出没有'查找字符串'内容的哪一行
* `-r`：在指定目录中递归查找
* `--color=auto`：将找到的关键字部分加上颜色
* `-A`：后面可加数字，为after的意思，除了列出该行外，后面的n行也列出来
* `-B`：后面可加数字，为before的意思，除了列出该行外，前面的n行也列出来

__示例：__

* `grep -r [--color=auto] '查找的字符串' [目录名]`

# 2 查找

## 2.1 find

__格式：__

* `find [文件路径] [option] [action]`

__参数说明：__

* `-name`：后接文件名，支持通配符。__注意匹配的是相对路径__
* `-regex`：后接正则表达式，__注意匹配的是完整路径__

__示例：__

* `find . -name "*.c"`
* `find . -regex ".*/.*\.c"`

# 3 文件压缩

## 3.1 tar

__格式：__

* 压缩：`tar -jcv -f [压缩创建的文件(*.tar.bz2)] [被压缩的文件或目录1] [被压缩的文件或目录2]...`
* 查询：`tar -jtv -f [压缩文件(*.tar.bz2)]`
* 解压缩：`tar -jxv -f [压缩文件(*.tar.bz2)] -C [欲解压的目录]`

__参数说明：__

* `-c`：新建打包文件，可以搭配-v查看过程中被打包的文件名
* `-t`：查看打包文件的内容含有那些文件名，终点在查看文件
* `-x`：解打包或解压缩的功能，可搭配-C在特定目录解开
* __注意，c t x是互斥的__
* `-j`：通过bzip2的支持进行压缩/解压，此时文件名最好为*.tar.bz2
* `-z`：通过gzip的支持进行压缩/解压，此时文件名最好是*.tar.gz
* `-v`：在压缩/解压缩过程中，将正在处理的文件名显示出来
* `-f` filename：-f后面接要被处理的文件名，建议-f单独写一个参数
* `-C` [目录名]：用于在解压时指定解压目录
* `-p`：保留备份数据原本权限与属性，常用语备份(-c)重要的配置文件
* `-P`：保留绝对路径，即允许备份数据中含有根目录存在之意

# 4 进程管理

## 4.1 &

在命令最后加上`&`代表将命令丢到后台执行

* 此时bash会给予这个命令一个工作号码(job number)，后接该命令触发的PID
* 不能被[Ctrl]+C中断
* 在后台中执行的命令，如果有stdout以及stderr时，它的数据依旧是输出到屏幕上面，所以我们会无法看到提示符，命令结束后，必须按下[Enter]才能看到命令提示符，同时也无法用[Ctrl]+C中断。解决方法就是利用数据流重定向

__示例：__

* `tar -zpcv -f /tmp/etc.tar.gz /etc > /tmp/log.txt 2>&1 &`

## 4.2 Ctrl+C

终止当前进程

## 4.3 Ctrl+Z

暂停当前进程

## 4.4 jobs

__格式：__

* `jobs [option]`

__参数说明：__

* `-l`：除了列出job number与命令串之外，同时列出PID号码
* `-r`：仅列出正在后台run的工作
* `-s`：仅列出正在后台中暂停(stop)的工作
* 输出信息中的'+'与'-'号的意义：
    * +：最近被放到后台的工作号码，代表默认的取用工作，即仅输入'fg'时，被拿到前台的工作
    * -：代表最近后第二个被放置到后台的工作号码
    * 超过最后第三个以后，就不会有'+'与'-'号存在了

__示例：__

* `jobs -lr`
* `jobs -ls`

## 4.5 fg

将后台工作拿到前台来处理

__示例：__

* `fg %jobnumber`：取出编号为`jobnumber`的工作。jubnumber为工作号码(数字)，%是可有可无的
* `fg +`：取出标记为+的工作
* `fg -`：取出标记为-的工作`

## 4.6 bg

让工作在后台下的状态变为运行中

__示例：__

* `bg %jobnumber`：取出编号为`jobnumber`的工作。jubnumber为工作号码(数字)，%是可有可无的
* `bg +`：取出标记为+的工作
* `bg -`：取出标记为-的工作
* 不能让类似vim的工作变为运行中，即便使用该命令会，该工作又立即变为暂停状态

## 4.7 kill

管理后台当中的工作

__格式：__

* `kill [-signal] PID`
* `kill [-signal] %jobnumber`
* `kill -l`

__参数说明：__

* `-l`：列出目前kill能够使用的signal有哪些
* `-signal`：
    * `-1`：重新读取一次参数的配置文件，类似reload
    * `-2`：代表与由键盘输入[Ctrl]+C同样的操作
    * `-9`：立刻强制删除一个工作，通常在强制删除一个不正常的工作时使用
    * `-15`：以正常的程序方式终止一项工作，与-9是不同的，-15以正常步骤结束一项工作，这是默认值
* 与bg、fg不同，若要管理工作，kill中的%不可省略，因为kill默认接PID

<!--

__格式：__

* `find [文件路径] [option] [action]`

__参数说明：__

* `-name`：后接文件名，支持通配符。__注意匹配的是相对路径__

__示例：__

* `find . -name "*.c"`

-->

# 5 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 鸟哥的Linux私房菜
