---
title: Linux常用命令
date: 2017-08-15 20:17:57
tags: 
- 原创
categories: 
- 操作系统
- Linux
---

__目录__

<!-- toc -->
<!--more-->

# 1 字符串处理命令

## 1.1 sed

__格式：__

* `sed [-nefr] [动作] [文件]`
* `STD IN | sed [-nefr] [动作]`

__参数说明：__

* `-n`：使用安静(silent)模式，在一般sed中，所有来自STDIN的数据一般都会被列到屏幕上，加了参数-n后，只有经过sed特殊处理的那一行才会被列出来
* `-e`：直接在命令行模式上进行sed的动作编辑
* `-f`：直接将sed的动作写在一个文件内，`-f filenmae`则可以执行filename内的sed动作
* `-r`：sed的动作支持的是扩展正则表达式的语法
* `-i`：直接修改读取的文件内容，而不是由屏幕输出

__动作说明，格式为`[n1 [,n2]]function`，接的动作必须以两个单引号括住__

* `a`：新增，a的后面可接字符串，而这些字符串会在新的一行出现(目前行的下一行)
* `c`：替换，c的后面可接字符串，这些字符串可以替换n1,n2之间的行
* `d`：删除，后面通常不接任何参数
* `i`：插入，i的后面可接字符串，而这些字符串会在新的一行出现(目前行的上一行)
* `p`：打印，也就是将某个选择的数据打印出来，通常p会与参数sed -n一起运行
* `s`：替换，可以直接进行替换的工作，通常这个s可以搭配正则表达式，例如1,20s/lod/new/g  (跟vim里面的很像！！！)

__示例：__

* `sed '2d' example`  <==删除example文件第二行
* `sed '2,$d' example`  <==删除第二至最后一行(注意这里$是代表最后一行的意思，而vim里面的操作以及正则表达式中$都代表行末)
* `sed '$d' example`  <==删除example文件最后一行
* `sed '/test/d' example`   <==删除example文件包含test的所有行
* `sed 's/test/mytest/g' example`  <==在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest
* `sed -n 's/^test/mytest/p' example`  <==(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它
* `sed 's/^192.168.0.1/&localhost/' example`  <==&符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1localhost
* `sed -n 's/\(love\)able/\1rs/p' example`  <==love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来
* `sed -n '/test/,/check/p' example`  <==所有在test和check所确定的范围内的行都被打印。逗号作用：选定行的范围
* `sed -n '5,/^test/p' example`  <==打印从第五行开始到第一个包含以test开始的行之间的所有行
* `sed '/test/,/check/s/$/sed test/' example`  <==对于模板test和west之间的行，每行的末尾用字符串sed test替换

## 1.2 awk

相比于sed(管道命令)常常作用于一整行的处理，awk(管道命令)则比较倾向于将一行分成数个"字段"来处理，因此awk相当适合处理小型的数据处理

__格式：__

* `awk [-F] '条件类型1{动作1} 条件类型2{动作2}...' [filename]`
__参数说明：__

* `-F`：后接分隔符。例如：`-F ':'`、`-F '[,.;]'`

注意awk后续的所有动作都是以单引号括住的，而且如果以print打印时，非变量的文字部分，包括格式等(例如制表`\t`、换行`\n`等)都需要以双引号的形式定义出来，因为单引号已经是awk的命令固定用法了。例如`last -n 5 | awk '{print $1 "\t" $3}'`

__awk处理流程：__

1. 读入第一行，并将第一行的数据填入$0,$1,...等变量中
1. 依据条件类型的限制，判断是否需要进行后面的动作
1. 做完所有的动作与条件类型
1. 若还有后续的'行'，重复上面的步骤，直到所有数据都读取完为止

__awk内置变量：__

* ARGC：命令行参数个数
* ARGV：命令行参数排列
* ENVIRON：支持队列中系统环境变量的使用
* FILENAME：awk浏览的文件名
* FNR：浏览文件的记录数
* __FS：设置输入域分隔符，默认是空格键，等价于命令行 -F选项__
* __NF：每一行($0)拥有的字段总数__
* __NR：目前awk所处理的是第几行__
* OFS：输出域分隔符
* ORS：输出记录分隔符
* RS：控制记录分隔符
* 在动作内部引用这些变量不需要用$，例如`last -n 5 | awk '{print $1 "\t  lines: " NR "\t columes: " NF}'`
* 此外，$0变量是指整条记录。$1表示当前行的第一个域，$2表示当前行的第二个域，以此类推。

__动作说明：__

* 所有awk的动作，即在{}内的动作，如果有需要多个命令辅助时，可以用分号";"间隔，或者直接以[Enter]按键来隔开每个命令

__BEGIN与END__

* 在Unix awk中两个特别的表达式，BEGIN和END，这两者都可用于pattern中（参考前面的awk语法），__提供BEGIN和END的作用是给程序赋予初始状态和在程序结束之后执行一些扫尾的工作。__
* __任何在BEGIN之后列出的操作（在{}内）将在Unix awk开始扫描输入之前执行，而END之后列出的操作将在扫描完全部的输入之后执行。__因此，通常使用BEGIN来显示变量和预置（初始化）变量，使用END来输出最终结果。

__示例：__

* `cat /etc/passwd | awk '{FS=":"} $3<10 {print $1 "\t" $3}'`，__注意`{FS=":"}`是作为一个动作存在的，因此从第二行开始分隔符才变为":"，第一行分隔符仍然是空格__。
* `cat /etc/passwd | awk 'BEGIN {FS=":"} $3<10 {print $1 "\t" $3}'`。__这样写`{FS=":"}`在处理第一行时也会生效__
* 
```shell
awk 
'BEGIN {FS=":";print "统计销售金额";total=0} 
{print $3;total=total+$3;} 
END {print "销售金额总计：",total}' sx
```

# 2 文件压缩

## 2.1 tar

__格式：__

* 压缩：`tar -jcv -f [压缩创建的文件(*.tar.bz2)] [被压缩的文件或目录1] [被压缩的文件或目录2]...`
* 查询：`tar -jtv -f [压缩文件(*.tar.bz2)]`
* 解压缩：`tar -jxv -f [压缩文件(*.tar.bz2)] -C [欲解压的目录]`

__参数说明：__

* `-c`：新建打包文件，可以搭配-v查看过程中被打包的文件名
* `-t`：查看打包文件的内容含有那些文件名，终点在查看文件
* `-x`：解打包或解压缩的功能，可搭配-C在特定目录解开
* __注意，c t x是互斥的__
* `-j`：通过bzip2的支持进行压缩/解压，此时文件名最好为*.tar.bz2
* `-z`：通过gzip的支持进行压缩/解压，此时文件名最好是*.tar.gz
* `-v`：在压缩/解压缩过程中，将正在处理的文件名显示出来
* `-f` filename：-f后面接要被处理的文件名，建议-f单独写一个参数
* `-C` [目录名]：用于在解压时指定解压目录
* `-p`：保留备份数据原本权限与属性，常用语备份(-c)重要的配置文件
* `-P`：保留绝对路径，即允许备份数据中含有根目录存在之意

# 3 参考

* 鸟哥的Linux私房菜
