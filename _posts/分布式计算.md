---
title: 分布式计算
date: 2017-08-22 14:32:02
tags: 
- 摘录
categories: 
- 分布式
- 基本概念
---

__目录__

<!-- toc -->
<!--more-->

# 1 介绍

分布式计算简单来说，是把一个大计算任务拆分成多个小计算任务分布到若干台机器上去计算，然后再进行结果汇总。目的在于分析计算海量的数据，从雷达监测的海量历史信号中分析异常信号(外星文明)，淘宝双十一实时计算各地区的消费习惯等

海量计算最开始的方案是提高单机计算性能，如大型机，后来由于数据的爆发式增长、单机性能却跟不上，才有分布式计算这种妥协方案。因为计算一旦拆分，问题会变得非常复杂，像一致性、数据完整、通信、容灾、任务调度等问题也都来了

举个例子，要求从数据库中100G的用户购买数据，分析出各地域的消费习惯金额等。如果没什么时间要求，就写个对应的业务处理服务程序，部署到服务器上，让它慢慢跑就是了，预计10个小时能处理完。后面嫌太慢，想办法加快到3个小时

平常开发中类似的需求也很多，总结出来就是，数据量大、单机计算慢。如果上Hadoop、storm之类成本较高、而且有点大才小用。当然让老板买更好的服务器配置也是一种办法

# 2 利用分片算法

分布式计算的核心在于计算任务拆分，如果数据能以水平拆分的方式，分布到5台机器上，每台机器只计算自身的1/5数据，这样即能在3小时内完成需求了

如上所述，需要把这些数据按照一定维度进行划分。按需求来看以用户ID划分最好，__由于用户之间没有状态上的关联，所以也不需要事务性及二次迭代计算__。用简单的hash取模对id进行划分

```
f(memberid) % 5 = ServerN
```

这样程序可以分别部署到5台机器上，然后程序按照配置只取对应余数的用户id，计算出结果并入库。__这种方式多机之间毫无关联，不需要进行通信，可以避免很多问题。__机器上的程序本身也不具备分布式的特性，它和单机一样，只计算自身获取到的数据即可，所以如果某台机器上程序崩溃的话，处理方式和单机一样，比如记录下处理进度，下次从当前进度继续进行后续计算

# 3 利用消息队列

使用分片方式相对比较简单，但有如下不足之处

* 它不具有负载均衡的能力，如果某台机器配置稍好点，它可能最先计算完，然后空闲等待着。也有可能是某些用户行为数据比较少，导致计算比较快完成
* 还有一个弊端就是每台机器上需要手动更改对应的配置，这样的话多台机器上的程序不是完全一样的，这样可以用远程配置动态修改的办法来解决

现在引入了个第三方，消息队列。先用一个单独的程序把用户信息推送到消息队列里去，然后各台机器分别取消费这个队列。于是就有了3个角色：

1. 推送消息的，简称Master
1. 消息队列，这里以Rabbitmq为例
1. 各个处理程序，简称Worker或Slave都行

虽然仅仅引入了个第三方，但它已经具备了分布式计算的很多特性

1. __计算任务分发__：Master把需要计算的用户数据，不断的推送消息队列
1. __程序一致性__：Worker订阅相同的消息队列即可，无需更改程序代码
1. __任意扩容__：由于程序完全一样，意味着如果想要加快速度，重复部署一份程序到新机器即可。当然这是理论上的，实际当中会受限于消息队列、数据库存储等
1. __容灾性__：如果5台中某一台程序挂了也不影响，利用Rabbitmq的消息确认机制，机器崩溃时正在计算的那一条数据会在超时，在其他节点上进行消费处理

# 4 Hadoop简介

Hadoop介绍已经相当多了，这里简述一下："Hadoop是一套海量数据计算存储的基础平台架构"。下面分析一下这句话

* 其中计算指的是MapReduce，这是做分布式计算用的
* 存储指的是HDFS，基于此上层的有HBase、Hive，用来做数据存储用的
* 平台，指可以给多个用户使用，比如有一计算需求，他只需要按照对应的接口编写业务逻辑即可，然后把程序以包的形式发布到平台上，平台进行分配调度计算等。而上面的分布式计算设计只能给自己使用，如果另外有小华要使用就需要重新写一份，然后单独部署，申请机器等。Hadoop最大的优势之一就在于提供了一套这样的完整解决方案

下面找了介绍Hadoop的概览图

![fig1](/images/分布式计算/fig1.jpg)

* 大数据计算任务：对应100G用户数据的计算任务
* 任务划分：对应Master和消息队列
* 子任务：对应Worker的业务逻辑
* 结果合并：对应把每个worker的计算结果入库
* 计算结果：对应入库的用户消费习惯数据

# 5 MapReduce

由于MapReduce计算输入和输出都是基于HDFS文件，所以大多数公司的做法是把mysql或sqlserver的数据导入到HDFS，计算完后再导出到常规的数据库中，这是MapReduce不够灵活的地方之一。MapReduce优势在于提供了比较简单的分布式计算编程模型，使开发此类程序变得非常简单，像之前的MPI编程就相当复杂

狭隘的来讲，MapReduce是把计算任务给规范化了，它可以等同于小和尚中Worker的业务逻辑部分。MapReduce把业务逻辑给拆分成2个大部分，Map和Reduce，可以先在Map部分把任务计算一半后，扔给Reduce部分继续后面的计算。当然在Map部分把计算任务全做完也是可以的。关于Mapreduce实现细节部分不多解释

如果把上述需求放到Hadoop来做，其处理流程大致如下：

1. 把100G数据导入到HDFS
1. 按照Mapreduce的接口编写处理逻辑，分Map、Reduce两部分
1. 把程序包提交到Mapreduce平台上，存储在HDFS里
1. 平台中有个叫Jobtracker进程的角色进行分发任务。这个类似小和尚的Master负载调度管理
1. 如果有5台机器进行计算的话，就会提前运行5个叫TaskTracker的slave进程。这类似小和尚worker的分离版，平台把程序和业务逻辑进行分离了，简单来说就是在机器上运行个独立进程，它能动态加载、执行jar或dll的业务逻辑代码
1. Jobtracker把任务分发到TaskTracker后，TaskTracker把开始动态加载jar包，创建个独立进程执行Map部分，然后把结果写入到HDFS上
1. 如果有Reduce部分，TaskTracker会创建个独立进程把Map输出的HDFS文件，通过RPC方式远程拉取到本地，拉取成功后，Reduce开始计算后续任务
1. Reduce再把结果写入到HDFS中
1. 从HDFS中把结果导出

这样一看好像是把简单的计算任务给复杂化了，其实如果只有几台计算任务的话，使用Mapreduce确实是杀鸡用牛刀了。如果有TB、PB级别的数据、跑在成百上千台计算节点上，Mapreduce的优势才会体现出来。其计算框架图架构如下：

![fig2](/images/分布式计算/fig2.jpg)

# 6 离线计算

通常称Mapreduce及小和尚这种计算为离线计算，因为它对已经持久化的文件数据进行计算，不能实时响应。还有个原因就是它的处理速度比较慢，它的输入和输出源都是基于HDFS设计，如果数据不是一开始就写入到HDFS上，就会涉及到数据导入导出，这部分相对耗费时间。而且它的数据流动是基于文件系统的，Map部分输出的数据不是直接传送到Reduce部分，而是先写入HDFS再进行传送

处理速度慢也是Mapreduce的不足之处，促使了后面实时计算的诞生
另外个缺点是Mapreduce的计算任务流比较单一，它只有Map、Reduce两部分。简单的可以只写一部分逻辑来解决，如果想拆分成多个部分，如逻辑A、逻辑B、逻辑C等，而且一部分计算逻辑依赖上一次计算结果的话，MapReduce处理起来就比较困难了。像storm框架解决此类问题的方案，也称为流式计算

# 7 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf#163.com，#替换成@)，博主将在第一时间删除__

* [浅谈分布式计算的开发与实现(一)](http://www.cnblogs.com/mushroom/p/4959904.html)
