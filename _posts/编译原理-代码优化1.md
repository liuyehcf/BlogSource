---
title: 编译原理-代码优化1
date: 2017-11-22 16:16:27
mathjax: true
tags: 
- 摘录
categories: 
- 编译
---

__目录__

<!-- toc -->
<!--more-->

# 1 流图

## 1.1 基本块(Basic Block)

__基本块__是满足下列条件的__最大__的__连续__三地址指令序列

* 控制流只能从基本块的__第一个指令__进入该块。也就是说，没有跳转到基本块中间或末尾指令的转移指令
* 除了基本块的__最后一个指令__，控制流在离开基本块之前不会跳转或者停机

## 1.2 基本块划分算法

输入：三地址指令序列
输出：输入序列对应的__基本块列表__，其中每个指令恰好被分配给一个基本块
方法：

* 首先，确定指令序列中哪些指令是__首指令__(leaders)，即某个基本块的第一个指令
    * 指令序列的__第一个三地址指令__是一个首指令
    * 任意一个条件或无条件__转移指令的目标指令__是一个首指令
    * 紧跟在一个条件或无条件__转移指令之后的指令__是一个首指令
* 然后，每个首指令对应的基本块包括了从它自己开始，直到__下一个首指令__（不含）或者__指令序列结尾__之间的所有指令

![fig1](/images/编译原理-代码优化1/fig1.jpg)

## 1.3 流图 (Flow Graphs)

流图的__节点__是一些__基本块__

从基本块B到基本块C之间有一条边，__当且仅当__基本块C的第一个指令__可能__紧跟在B的最后一条指令之后执行。此时称B是C的前驱(predecessor)，C是B的后继(successor)

有两种方式可以确认这样的边

1. 有一个从__B的结尾跳转到C的开头__的条件或无条件跳转语句
1. 按照原来的三地址语句序列中的顺序，C紧跟在B之后，且B的结尾不存在__无条件__跳转语句

![fig2](/images/编译原理-代码优化1/fig2.jpg)

![fig3](/images/编译原理-代码优化1/fig3.jpg)

# 2 常用的代码优化方法

__优化的分类__

* 机器无关优化：针对中间代码
* 机器相关优化：针对目标代码
* 局部代码优化：单个基本块范围内的优化
* 全局代码优化：面向多个基本块的优化

__常用的优化方法__

* 删除公共子表达式
* 删除无用代码
* 常量合并
* 代码移动
* 强度削弱
* 删除归纳变量

## 2.1 删除公共子表达式

如果表达式$x\;op\;y$先前已被计算过，并且从先前的计算到现在，$x\;op\;y$中变量的值没有改变，那么$x\;op\;y$的这次出现就称为公共子表达式(common subexpression)

![fig4](/images/编译原理-代码优化1/fig4.jpg)

![fig5](/images/编译原理-代码优化1/fig5.jpg)

![fig6](/images/编译原理-代码优化1/fig6.jpg)

![fig7](/images/编译原理-代码优化1/fig7.jpg)

![fig8](/images/编译原理-代码优化1/fig8.jpg)

![fig9](/images/编译原理-代码优化1/fig9.jpg)

![fig10](/images/编译原理-代码优化1/fig10.jpg)

![fig11](/images/编译原理-代码优化1/fig11.jpg)

![fig12](/images/编译原理-代码优化1/fig12.jpg)

![fig13](/images/编译原理-代码优化1/fig13.jpg)

![fig14](/images/编译原理-代码优化1/fig14.jpg)

## 2.2 删除无用代码

常用的__公共子表达式消除算法__和其它一些优化算法会引入一些复制语句(形如$x = y$的赋值语句)

* ![fig15](/images/编译原理-代码优化1/fig15.jpg)

__复制传播__：在复制语句$x = y$之后尽可能地用$y$代替$x$

* ![fig16](/images/编译原理-代码优化1/fig16.jpg)

__无用代码（死代码Dead-Code）__：其计算结果__永远不会被使用__的语句

![fig17](/images/编译原理-代码优化1/fig17.jpg)

## 2.3 常量合并(Constant Folding)

如果在__编译时刻__推导出__一个表达式的值是常量__，就可以使用该常量来替代这个表达式。该技术被称为__常量合并__

* ![fig18](/images/编译原理-代码优化1/fig18.jpg)

## 2.4 代码移动(Code Motion)

这个转换处理的是那些__不管循环执行多少次都得到相同结果的表达式__(即__循环不变计算__，loop-invariant computation)，在进入循环之前就对它们求值

* ![fig19](/images/编译原理-代码优化1/fig19.jpg)

对于多重嵌套的循环，循环不变计算是相对于某个循环而言的。可能对于更加外层的循环，它就不是循环不变计算

## 2.5 强度削弱(Strength Reduction)

用__较快__的操作代替__较慢__的操作

1. 加代替乘
1. 乘代替除
1. 乘代替乘方
1. 加乘复合操作代替多项式
* ![fig20](/images/编译原理-代码优化1/fig20.jpg)

### 2.5.1 循环中的强度削弱

__归纳变量__：对于一个变量$x$，如果存在一个正的或负的常数$c$使得每次$x$被赋值时它的值总增加$c$，那么$x$就称为__归纳变量(Induction Variable)__

* 归纳变量可以通过在每次循环迭代中进行一次简单的增量运算（加法或减法）来计算
* ![fig21](/images/编译原理-代码优化1/fig21.jpg)

## 2.6 删除归纳变量

在沿着循环运行时，如果有__一组归纳变量__的值的变化保持__步调一致__，常常可以将这组变量删除为只剩一个

* ![fig22](/images/编译原理-代码优化1/fig22.jpg)

# 3 基本块的优化

很多重要的__局部优化技术__首先把一个__基本块__转换成为一个__无环有向图__(directed acyclic graph, DAG)

## 3.1 基本块的DAG表示

基本块中的每个__语句__$s$都对应一个__内部结点__$N$

* 结点$N$的__标号__是$s$中的__运算符__；同时还有一个__定值变量表__被关联到$N$，表示$s$是在此基本块内最晚对表中变量进行定值的语句
* $N$的子结点是基本块中在$s$之前、最后一个对$s$所使用的某个__运算分量__进行定值的语句对应结点。如果$s$的某个运算分量在基本块内没有在$s$之前被定值，则这个运算分量对应的子结点就是代表该运算分量初始值的叶结点 (为区别起见，叶节点的定值变量表中的变量加上下脚标0)
* 在为语句$x = y + z$构造结点$N$的时候，如果$x$已经在某结点$M$的定值变量表中，则从$M$的定值变量表中删除变量$x$

## 3.2 基于基本块的DAG删除无用代码

从一个DAG上删除所有__没有附加活跃变量__（活跃变量是指其值可能会在以后被使用的变量）的根节点（即没有父节点的节点）。重复应用这样的处理过程就可以从DAG中消除所有对应于无用代码的节点

* ![fig23](/images/编译原理-代码优化1/fig23.jpg)

## 3.3 数组元素赋值指令的表示

在构造DAG时，如何防止系统将$a[i]$误判为公共子表达式

* 对于形如$a[j]=y$的三地址指令，创建一个运算符为"[]="的节点，这个节点有3个子节点，分别表示$a$、$j$、和$y$
* 该节点没有定值变量表
* 该节点的创建将__杀死__所有已经建立的、其值依赖于$a$的节点
* 一个被杀死的节点__不能再获得任何定值变量__，也就是说，它不可能成为一个公共子表达式
* ![fig24](/images/编译原理-代码优化1/fig24.jpg)

## 3.4 根据基本块的DAG可以获得一些非常有用的信息

1. 确定哪些变量的值在该基本块中赋值前被__引用__过，即在DAG中创建了__叶节点__的那些变量
1. 确定哪些语句计算的值可以在基本块外被引用
    * 在DAG构造过程中为语句$s$（该语句为变量$x$定值）创建的节点$N$，在DAG构造结束时$x$仍然是$N$的定值变量

## 3.5 从DAG到基本块的重组

对每个具有若干定值变量的节点，构造一个__三地址语句__来计算其中某个变量的值

* 倾向于把计算得到的结果赋值给一个在基本块__出口处活跃__的变量（如果没有__全局活跃变量的信息__作为依据，就要假设所有变量都在基本块出口处活跃，但是不包含编译器为处理表达式而生成的临时变量）
* 如果结点有__多个附加的活跃变量__，就必须引入__复制语句__，以便给每一个变量都赋予正确的值

![fig25](/images/编译原理-代码优化1/fig25.jpg)

![fig26](/images/编译原理-代码优化1/fig26.jpg)

# 4 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf#163.com，#替换成@)，博主将在第一时间删除__

* 《MOOC-编译原理-陈鄞》
