---
title: 编译原理-代码优化1
date: 2017-11-22 16:16:27
mathjax: true
tags: 
- 摘录
categories: 
- Compile Principle
---

**阅读更多**

<!--more-->

# 1 流图

## 1.1 基本块(Basic Block)

**基本块**是满足下列条件的**最大**的**连续**三地址指令序列

* 控制流只能从基本块的**第一个指令**进入该块。也就是说，没有跳转到基本块中间或末尾指令的转移指令
* 除了基本块的**最后一个指令**，控制流在离开基本块之前不会跳转或者停机

## 1.2 基本块划分算法

输入：三地址指令序列
输出：输入序列对应的**基本块列表**，其中每个指令恰好被分配给一个基本块
方法：

* 首先，确定指令序列中哪些指令是**首指令**(leaders)，即某个基本块的第一个指令
    * 指令序列的**第一个三地址指令**是一个首指令
    * 任意一个条件或无条件**转移指令的目标指令**是一个首指令
    * 紧跟在一个条件或无条件**转移指令之后的指令**是一个首指令
* 然后，每个首指令对应的基本块包括了从它自己开始，直到**下一个首指令**（不含）或者**指令序列结尾**之间的所有指令

![fig1](/images/编译原理-代码优化1/fig1.jpg)

## 1.3 流图 (Flow Graphs)

流图的**节点**是一些**基本块**

从基本块B到基本块C之间有一条边，**当且仅当**基本块C的第一个指令**可能**紧跟在B的最后一条指令之后执行。此时称B是C的前驱(predecessor)，C是B的后继(successor)

有两种方式可以确认这样的边

1. 有一个从**B的结尾跳转到C的开头**的条件或无条件跳转语句
1. 按照原来的三地址语句序列中的顺序，C紧跟在B之后，且B的结尾不存在**无条件**跳转语句

![fig2](/images/编译原理-代码优化1/fig2.jpg)

![fig3](/images/编译原理-代码优化1/fig3.jpg)

# 2 常用的代码优化方法

**优化的分类**

* 机器无关优化：针对中间代码
* 机器相关优化：针对目标代码
* 局部代码优化：单个基本块范围内的优化
* 全局代码优化：面向多个基本块的优化

**常用的优化方法**

* 删除公共子表达式
* 删除无用代码
* 常量合并
* 代码移动
* 强度削弱
* 删除归纳变量

## 2.1 删除公共子表达式

如果表达式{% raw %}$x\;op\;y${% endraw %}先前已被计算过，并且从先前的计算到现在，{% raw %}$x\;op\;y${% endraw %}中变量的值没有改变，那么{% raw %}$x\;op\;y${% endraw %}的这次出现就称为公共子表达式(common subexpression)

![fig4](/images/编译原理-代码优化1/fig4.jpg)

![fig5](/images/编译原理-代码优化1/fig5.jpg)

![fig6](/images/编译原理-代码优化1/fig6.jpg)

![fig7](/images/编译原理-代码优化1/fig7.jpg)

![fig8](/images/编译原理-代码优化1/fig8.jpg)

![fig9](/images/编译原理-代码优化1/fig9.jpg)

![fig10](/images/编译原理-代码优化1/fig10.jpg)

![fig11](/images/编译原理-代码优化1/fig11.jpg)

![fig12](/images/编译原理-代码优化1/fig12.jpg)

![fig13](/images/编译原理-代码优化1/fig13.jpg)

![fig14](/images/编译原理-代码优化1/fig14.jpg)

## 2.2 删除无用代码

常用的**公共子表达式消除算法**和其它一些优化算法会引入一些复制语句(形如{% raw %}$x = y${% endraw %}的赋值语句)

* ![fig15](/images/编译原理-代码优化1/fig15.jpg)

**复制传播**：在复制语句{% raw %}$x = y${% endraw %}之后尽可能地用{% raw %}$y${% endraw %}代替{% raw %}$x${% endraw %}

* ![fig16](/images/编译原理-代码优化1/fig16.jpg)

**无用代码（死代码Dead-Code）**：其计算结果**永远不会被使用**的语句

![fig17](/images/编译原理-代码优化1/fig17.jpg)

## 2.3 常量合并(Constant Folding)

如果在**编译时刻**推导出**一个表达式的值是常量**，就可以使用该常量来替代这个表达式。该技术被称为**常量合并**

* ![fig18](/images/编译原理-代码优化1/fig18.jpg)

## 2.4 代码移动(Code Motion)

这个转换处理的是那些**不管循环执行多少次都得到相同结果的表达式**(即**循环不变计算**，loop-invariant computation)，在进入循环之前就对它们求值

* ![fig19](/images/编译原理-代码优化1/fig19.jpg)

对于多重嵌套的循环，循环不变计算是相对于某个循环而言的。可能对于更加外层的循环，它就不是循环不变计算

## 2.5 强度削弱(Strength Reduction)

用**较快**的操作代替**较慢**的操作

1. 加代替乘
1. 乘代替除
1. 乘代替乘方
1. 加乘复合操作代替多项式
* ![fig20](/images/编译原理-代码优化1/fig20.jpg)

### 2.5.1 循环中的强度削弱

**归纳变量**：对于一个变量{% raw %}$x${% endraw %}，如果存在一个正的或负的常数{% raw %}$c${% endraw %}使得每次{% raw %}$x${% endraw %}被赋值时它的值总增加{% raw %}$c${% endraw %}，那么{% raw %}$x${% endraw %}就称为**归纳变量(Induction Variable)**

* 归纳变量可以通过在每次循环迭代中进行一次简单的增量运算（加法或减法）来计算
* ![fig21](/images/编译原理-代码优化1/fig21.jpg)

## 2.6 删除归纳变量

在沿着循环运行时，如果有**一组归纳变量**的值的变化保持**步调一致**，常常可以将这组变量删除为只剩一个

* ![fig22](/images/编译原理-代码优化1/fig22.jpg)

# 3 基本块的优化

很多重要的**局部优化技术**首先把一个**基本块**转换成为一个**无环有向图**(directed acyclic graph, DAG)

## 3.1 基本块的DAG表示

基本块中的每个**语句**{% raw %}$s${% endraw %}都对应一个**内部结点**{% raw %}$N${% endraw %}

* 结点{% raw %}$N${% endraw %}的**标号**是{% raw %}$s${% endraw %}中的**运算符**；同时还有一个**定值变量表**被关联到{% raw %}$N${% endraw %}，表示{% raw %}$s${% endraw %}是在此基本块内最晚对表中变量进行定值的语句
* {% raw %}$N${% endraw %}的子结点是基本块中在{% raw %}$s${% endraw %}之前、最后一个对{% raw %}$s${% endraw %}所使用的某个**运算分量**进行定值的语句对应结点。如果{% raw %}$s${% endraw %}的某个运算分量在基本块内没有在{% raw %}$s${% endraw %}之前被定值，则这个运算分量对应的子结点就是代表该运算分量初始值的叶结点 (为区别起见，叶节点的定值变量表中的变量加上下脚标0)
* 在为语句{% raw %}$x = y + z${% endraw %}构造结点{% raw %}$N${% endraw %}的时候，如果{% raw %}$x${% endraw %}已经在某结点{% raw %}$M${% endraw %}的定值变量表中，则从{% raw %}$M${% endraw %}的定值变量表中删除变量{% raw %}$x${% endraw %}

## 3.2 基于基本块的DAG删除无用代码

从一个DAG上删除所有**没有附加活跃变量**（活跃变量是指其值可能会在以后被使用的变量）的根节点（即没有父节点的节点）。重复应用这样的处理过程就可以从DAG中消除所有对应于无用代码的节点

* ![fig23](/images/编译原理-代码优化1/fig23.jpg)

## 3.3 数组元素赋值指令的表示

在构造DAG时，如何防止系统将{% raw %}$a[i]${% endraw %}误判为公共子表达式

* 对于形如{% raw %}$a[j]=y${% endraw %}的三地址指令，创建一个运算符为"[]="的节点，这个节点有3个子节点，分别表示{% raw %}$a${% endraw %}、{% raw %}$j${% endraw %}、和{% raw %}$y${% endraw %}
* 该节点没有定值变量表
* 该节点的创建将**杀死**所有已经建立的、其值依赖于{% raw %}$a${% endraw %}的节点
* 一个被杀死的节点**不能再获得任何定值变量**，也就是说，它不可能成为一个公共子表达式
* ![fig24](/images/编译原理-代码优化1/fig24.jpg)

## 3.4 根据基本块的DAG可以获得一些非常有用的信息

1. 确定哪些变量的值在该基本块中赋值前被**引用**过，即在DAG中创建了**叶节点**的那些变量
1. 确定哪些语句计算的值可以在基本块外被引用
    * 在DAG构造过程中为语句{% raw %}$s${% endraw %}（该语句为变量{% raw %}$x${% endraw %}定值）创建的节点{% raw %}$N${% endraw %}，在DAG构造结束时{% raw %}$x${% endraw %}仍然是{% raw %}$N${% endraw %}的定值变量

## 3.5 从DAG到基本块的重组

对每个具有若干定值变量的节点，构造一个**三地址语句**来计算其中某个变量的值

* 倾向于把计算得到的结果赋值给一个在基本块**出口处活跃**的变量（如果没有**全局活跃变量的信息**作为依据，就要假设所有变量都在基本块出口处活跃，但是不包含编译器为处理表达式而生成的临时变量）
* 如果结点有**多个附加的活跃变量**，就必须引入**复制语句**，以便给每一个变量都赋予正确的值

![fig25](/images/编译原理-代码优化1/fig25.jpg)

![fig26](/images/编译原理-代码优化1/fig26.jpg)

# 4 参考

* 《MOOC-编译原理-陈鄞》
