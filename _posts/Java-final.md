---
title: Java final
date: 2017-07-05 17:01:05
tags:
categories:
- Java Memory Model
---


# 前言

本篇博客主要介绍final的内存语义


<!--more-->


# final域的重排序规则

对于final域，编译器和处理器要遵守两个重要排序规则

* 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
* 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序

## 写final域的重排序规则

写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含以下2方面

1. JMM禁止编译器把final域的写重排序到构造函数之外
1. 编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外


如果允许final域的写重排到构造函数之外，那么其他线程将可能访问到一个尚未初始化的final域(此时构造函数已经return，但是对象尚未构造完成)
* 这也就是单例模式中双重检测机制为什么存在问题的原因

写final域的重排序规则可以保证：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障

## 读final域的重排序规则

读final域的重排序规则是，在一个线程中，初次读取对象引用与初次读取该对象包含的final域，JMM禁止处理器重排序这两个操作(注意，这个规则仅仅针对处理器)。编译器会在读final域操作的前面插入一个LoadLoad屏障

初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。担有少数处理器允许对存在间接依赖关系的操作做重排序(比如alpha处理器)

读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个fianl域的对象的引用

# final域为引用类型


# 为什么final引用不能从构造函数中溢出


# final语义在处理器中的实现


# JSR-133为什么要增强final的语义