---
title: Java 锁机制简介
date: 2017-07-02 22:57:53
tags:
- 原创
categories:
- Java
- Java 并发
- Java 锁机制
---

__目录__

<!-- toc -->
<!--more-->

# 1 前言
本篇博客对Java中与 __锁__ 有关的概念进行了整理，大致上分为如下几个部分

* Java内建锁机制
* JVM对内建锁机制的优化
* 自旋锁及其相关变体
* AQS框架

# 2 Java内建锁机制

## 2.1 synchronized
Java中每一个对象都可以作为锁，这是 synchronized实现同步的基础

* synchronized修饰普通方法，锁是当前实例对象
* synchronized修饰静态方法，锁是当前类的Class对象
* synchronized同步方法块，锁是括号里面的对象

synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性(同步代码块结束后从工作内存刷新到主内存中)

synchronized是重量级锁，重量级锁通过对象内部的监视器(monitor)实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高

当退出或者抛出异常时必须要释放锁，synchronized代码块能自动保证这一点

# 3 JVM对内建锁机制的优化

## 3.1 锁消除
为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除，锁消除可以节省毫无意义的请求锁/释放锁的时间。锁消除的依据是逃逸分析的数据支持(逃逸分析的另一用处就是让对象在栈上而非堆中分配空间以提高效率)
如果不存在竞争，为什么还需要加锁呢？变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样：我们虽然没有显式使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作

## 3.2 锁粗化
我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。

在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念

锁粗化概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁

* 例如：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象(vector)连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外

## 3.3 Java对象头
首先介绍一下Java对象头，这是理解轻量级锁，偏向锁的基础

锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。

| 长度 | 内容 | 说明 |
|:--|:--|:--|
| 32/64bit | Mark Word | 存储对象的hashCode或锁信息等 |
| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针 |
| 32/32bit | Array length | 数组长度(如果当前对象是数组) |

Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：

| 锁状态 | 25bit | 4bit | 1bit(是否偏向锁) | 2bit(锁标志位) |
|:--|:--|:--|:--|:--|
| 无锁状态 | 对象的hashCode | 对象分代年龄 | 0 | 01 |

在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：

![](/images/Java-锁机制简介/MarkWord.jpg)

## 3.4 重量级锁

synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。

__那么为什么说这种操作很重呢？__

> 重量级锁是使用操作系统互斥量来实现的。Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统内核的帮忙，这就要从用户态转换到内核态，因此状态转换需要花费很多的处理器时间，对于代码简单的同步块（如被synchronized修饰的get或set方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说synchronized是Java语言中一个重量级的操作。所以JVM的研究人员在1.6的时候花费了大量的时间来优化重量级锁，于是在1.6中出现了轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在1.4就有，只不过默认的是关闭的，JDK1.6是默认开启的)，这些操作都是为了在线程之间更高效的共享数据，解决竞争问题。

## 3.5 轻量级锁

“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。__但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗__。在解释轻量级锁的执行过程之前，先明白一点，__轻量级锁所适应的场景是线程交替执行同步块的情况__，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。

上面说到：__轻量级锁所适应的场景是线程交替执行同步块的情况__，这种说法其实并不准确。其实，轻量级锁采用了一种`循环+CAS操作的方式进行加锁解锁操作`，循环的次数有限制，意味着在这有限的时间内不断地__自旋__尝试获取锁。如果在这段自旋时间内成功获取到锁，那么其开销是要小于`先阻塞然后唤醒`的。但是如果在有限的循环次数内，或者说有限的时间内无法获取到锁，那么此时就需要升级成重量级锁，然后阻塞当前线程，避免其一直自旋占用大量的CPU资源

因此轻量级锁的使用场景是：__多线程交替执行同步块代码时，线程之间不存在竞争，或者线程执行同步块代码的速度非常快__

__获取锁__

1. 判断当前对象是否处于无锁状态(锁标志位01，偏向锁标志位0)
    * 若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word)。然后拷贝对象头中的Mark Word复制到锁记录中
    * 否则执行步骤(3)
2. JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针
    * 如果成功表示竞争到锁，则将锁标志位变成00(表示此对象处于轻量级锁状态)，执行同步操作
    * 如果失败则执行步骤(3)
3. 判断当前对象的Mark Word是否指向当前线程的栈帧
    * 如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块
    * 否则只能说明该锁对象已经被其他线程抢占了，再进行一定次数的锁获取操作(循环+CAS替换MarkWord)，如果仍然没有获取到锁，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态

__释放锁__

1. 取出在获取轻量级锁保存在Displaced Mark Word中的数据
2. 用CAS操作将取出的数据替换当前对象的Mark Word中
    * 如果成功，则说明释放锁成功
    * 否则执行(3)
3. 如果CAS操作替换失败，此时Mark Word中存放的是指向重量级锁（Monitor，即系统互斥量）的指针，那么对象头中的Mark Word中数据的恢复将由重量级锁的释放来完成。此时需要在释放轻量级锁的同时唤醒被挂起的线程

![](/images/Java-锁机制简介/轻量级锁膨胀流程图.png)

## 3.6 偏向锁

我们首先回顾一下__轻量级锁的引入是为了提升在没有线程竞争(不存在竞争，或者存在竞争但是同步块执行的效率非常高)的情况下执行同步代码的效率__。那么还有一种特殊的情况：__始终只有一个线程在执行同步块__，在这种情况下，即使使用轻量级锁也是需要多个CAS操作的，所以也有一部分开销，于是JVM研究人员又引入了另一种锁即偏向锁来适用这种情况。偏向锁中的偏就是偏心的“偏”，它的意思是让这个锁始终偏向第一个获取它的线程，如果接下来的执行过程中，该锁没有被其他线程获取则持有偏向锁的线程将永远不需要再进行同步。当开启了偏向锁功能，当代码进入同步块的时候，虚拟机会检查当前线程是否处于无锁状态（锁标志位为01）且没有偏向（偏向标记位为0），那么线程就会使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中，如果获取成功，那么持有偏向锁的线程以后在每次进入这个锁相关的同步块的时候，虚拟机不再使用任何的同步操作只检测对象头中是否是当前线程ID，如果是，则直接进入，省去了CAS操作。当另外一个线程获取该对象锁的时候，偏向模式就会宣告结束，根据锁对象的当前状态，撤销偏向后恢复到无锁状态或偏向锁状态，之后的操作就如同上述轻量级锁的介绍。

__引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径(CAS原子指令)。__因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。__上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。__

那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可

__获取锁__

1. 检测Mark Word是否为可偏向状态(锁标识位01，偏向锁标志位1)
2. 若为可偏向状态，则测试线程ID是否为当前线程ID
    * 如果是，则执行步骤(5)
    * 否则执行步骤(3)
3. 如果线程ID不为当前线程ID，则通过CAS操作竞争锁
    * 竞争成功，将Mark Word的线程ID替换为当前线程ID，执行步骤(5)
    * 否则执行步骤(4)
4. 通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块
5. 执行同步代码块

__释放锁__：__偏向锁的释放在上述第四步骤中有提到。__偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点(这个时间点是上没有正在执行的字节码)。其步骤如下

1. 先暂停持有偏向锁的线程，检查持有偏向锁的线程是否活着
    * 如果线程不处于活动状态，__则将对象头设置成无锁状态，并且将偏向标志位设置为0__，表示不可偏向
    * 如果线程仍然活着，__则将对象头设置成轻量级锁状态(锁标志位00)__，并且让当前获取偏向锁的线程重新获取一下轻量级锁(因为此时可能正在执行同步代码块，必须保证没有其他线程能够获取升级后的轻量级锁)

![](/images/Java-锁机制简介/偏向锁膨胀流程图.png)

另一方面，偏向锁比轻量锁更容易被终结，轻量锁是在__有锁竞争出现且尝试一定次数后仍失败__时升级为重量锁，而一般偏向锁是在有不同线程申请锁时升级为轻量锁，这也就意味着假如一个对象先被线程1加锁解锁，再被线程2加锁解锁，这过程中没有锁冲突，也一样会发生偏向锁失效，不同的是这回要先退化为无锁的状态，再加轻量级锁，如下图所示

![](/images/Java-锁机制简介/偏向锁2.jpg)

__总结一下：偏向锁只适用于在只有一个线程执行同步代码块的情况，如果程序中大部分锁总是被不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下有时候禁用偏向锁反而可以提高性能。__

## 3.7 总结
偏向锁

* 优点：加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距
* 缺点：如果线程间存在锁竞争，会带来额外的锁撤销的消耗
* 场景：适用于只有一个线程访问同步块场景

轻量级锁

* 优点竞争的线程不会阻塞，提高了程序的响应速度
* 缺点：如果始终得不到锁竞争的线程使用自旋会消耗CPU
* 场景：追求响应时间，锁占用时间很短

重量级锁

* 优点：线程竞争不使用自旋，不会消耗CPU
* 缺点：线程阻塞，响应时间缓慢
* 场景：追求吞吐量,锁占用时间较长

# 4 自旋锁及其相关变体

## 4.1 自旋锁
线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁

所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可(自旋)

自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间

* 如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好
* 反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费
* 所以说，自旋等待的时间(自旋的次数)必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。

一个简单的自旋锁Demo
```Java
public class SpinLockDemo {

    private AtomicInteger state = new AtomicInteger();

    public void lock() {
        for (; ; ) {
            if (state.compareAndSet(0, 1)) {
                break;
            }
        }
    }

    public void unlock() {
        if (!state.compareAndSet(1, 0)) {
            throw new RuntimeException();
        }
    }
}
```

自旋锁优劣势总结

* 优势
    * lock-free：不加锁(没有唤醒阻塞的系统开销)
* 劣势
    * CPU开销大
    * 无法响应中断
    * 不支持FIFO

## 4.2 Ticket Lock
Ticket Lock是自旋锁的改进，这种锁机制可以类比去银行办理业务，一开始，我们会拿一个号，然后等着，直到办理业务的工作人员叫到我们的号，然后我们去办理业务

一个简单的Ticket Lock的例子
```Java
public class TicketLockDemo {

    private AtomicInteger serviceNum = new AtomicInteger();//当前服务号

    private AtomicInteger ticketNum = new AtomicInteger();//排队号

    public int lock() {
        //排队前拿个号
        int myTicketNum = ticketNum.getAndIncrement();

        while (serviceNum.get() != myTicketNum) {

        }

        System.out.println(Thread.currentThread() + " is hold the lock, order: " + myTicketNum);

        return myTicketNum;
    }

    public void unlock(int myTicket) {
        int next = myTicket + 1;
        if (!serviceNum.compareAndSet(myTicket, next)) {
            throw new RuntimeException();
        }
        System.out.println(Thread.currentThread() + " is release the lock\n");
    }
}
```

Ticket Lock优劣势总结

* 优势
    * 支持FIFO
    * lock-free：不加锁(没有唤醒阻塞的系统开销)
* 劣势
    * CPU开销大
    * 无法响应中断
    * 多个公共线程在共享资源上自旋，开销较大

## 4.3 CLH锁
CLH锁(Craig，Landin，and Hagersten locks)在Ticket锁的机制上进行了优化，让每个线程在 __非共享变量上自旋__ ，减少了共享变量的同步开销

CLH锁的简单Demo
```Java
class QNode {
    volatile boolean locked;
}

public class CLHLockDemo {
    AtomicReference<QNode> tail = new AtomicReference<QNode>(new QNode());
    ThreadLocal<QNode> currNode;

    public CLHLockDemo() {
        tail = new AtomicReference<QNode>(new QNode());
        currNode = new ThreadLocal<QNode>() {
            protected QNode initialValue() {
                return new QNode();
            }
        };
    }

    public void lock() {
        QNode curr = this.currNode.get();
        curr.locked = true;

        //将当前节点通过CAS操作加到队列尾，返回原先的队列尾，作为它的前继节点
        QNode prev = tail.getAndSet(curr);

        while (prev.locked) {
            //在前继节点的状态上自旋
        }
    }

    public void unlock() {
        QNode qnode = currNode.get();
        qnode.locked = false;
    }
}
```

# 5 AQS框架

AQS框架是CLH锁的变体，AQS相比于CLH锁，AQS采用了自旋与阻塞相结合的策略，提高整体的性能，既不会出现自旋锁盲目自旋消耗大量CPU的情况，也不会出线程频繁的阻塞和唤醒

具体AQS源码剖析，请移步 {% post_link Java-concurrent-AQS-源码剖析 %}

# 6 参考

* [1-偏向锁，轻量级锁，自旋锁，重量级锁的详细介绍](http://www.cnblogs.com/wade-luffy/p/5969418.html)
* [2-synchronized实现原理](http://www.cnblogs.com/pureEve/p/6421273.html)
* [3-几种锁算法的实现](https://segmentfault.com/a/1190000002881664)
* [Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）](http://www.cnblogs.com/paddix/p/5405678.html)
