---
title: 银行家算法
date: 2017-08-16 21:20:29
tags: 
- 摘录
categories: 
- 算法
- 其他
---

__目录__

<!-- toc -->
<!--more-->

# 1 需求分析

## 1.1 银行家算法的实现思想

允许进程动态地申请资源，__系统在每次实施资源分配之前，先计算资源分配的安全性__，若此次资源分配安全（即资源分配后，系统能按某种顺序来为每个进程分配其所需的资源，直至最大需求，使每个进程都可以顺利地完成），便将资源分配给进程，否则不分配资源，让进程等待。

## 1.2 死锁的概念

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

银行家算法是避免死锁的一种重要方法。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。

## 1.3 产生死锁的必要条件

1. __互斥条件__：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
1. __请求和保持条件__：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
1. __不剥夺条件__：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
1. __环路等待条件__：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合`{P0, P1, P2, ···, Pn}`中的`P0`正在等待一个`P1`占用的资源；`P1`正在等待`P2`占用的资源，......，`Pn`正在等待已被`P0`占用的资源。

## 1.4 功能实现

理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何能够不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源，在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配。因此，对资源的分配要给予合理的规划。

# 2 概要设计

## 2.1 数据结构

1. __可利用资源向量Available__：这是一个含有m个元素的数组，其中的而每一个元素代表一类可利用资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态的改变。如果`Available[j] = K`，则表示系统中现有`Rj类资源`的数目为`K`。
1. __最大需求矩阵Max__：这是一个n*m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果`Max[i,j] = K`，则表示`进程i`需要`Rj类资源`的最大数目为`K`。
1. __分配矩阵Allocation__：这也是一个n*m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果`Allocation[i,j] = K`，则表示`进程i`当前已分得`Rj类资源`的数目为`K`。
1. __需求矩阵Need__：这也是一个n*m的矩阵，用以表示每一个进程尚需的各类资源数。如果`Need[i,j] = K`，则表示`进程i`还需要`Rj类资源`的数目为`K`个，方能完成任务。
* 上述三个矩阵间存在下述关系：`Need[i,j] = Max[i,j] - Allocation[i,j]`

## 2.2 设计思路

__第一部分：银行家算法模块__

1. 如果`Request <= Need`，则转向2；否则出错
1. 如果`Request <= Available`，则转向3；否则等待
1. 系统试探分配请求的资源给进程
1. 系统执行安全性算法

__第二部分:安全性算法模块__

1. 设置两个向量
    * `Work = Available`：表示系统可提供给进程继续运行所需要的各类资源数目
    * `Finish`：表示系统是否有足够资源分配给进程
1. 若`Finish[i] == False && Need <= Work`(i为资源类别)，则执行3；否则执行4
1. 进程P获得第i类资源，则顺利执行直至完成，并释放资源：`Work = Work + Allocation`以及`Finish[i] = true`；转2
1. 若所有进程的`Finish[i] == true`，则表示系统安全；否则不安全！

# 3 参考

* [银行家算法](http://www.cnblogs.com/Lynn-Zhang/p/5672080.html)
* [http://blog.csdn.net/yaopeng_2005/article/details/6935235](http://blog.csdn.net/yaopeng_2005/article/details/6935235)
