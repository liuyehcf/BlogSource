---
title: 云原生杂记
date: 2020-11-10 13:37:39
tags: 
- 摘录
categories: 
- Cloud Native
---

__阅读更多__

<!--more-->

# 1 概念

## 1.1 什么是云原生

云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括「容器」、「服务网格」、「微服务」、「不可变基础设施」和「声明式API」

这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更

云原生既包含技术（微服务，敏捷基础设施），也包含管理（DevOps，持续交付，康威定律，重组等）。云原生也可以说是一系列云技术、企业管理方法的集合

## 1.2 什么是云原生应用

云原生（Cloud Native）应用，是指原生为在云平台上部署运行而设计开发的应用，云原生应用不只是将应用打包成Docker镜像，而且需要将镜像部署到到Kubernetes容器云上运行

# 2 理论探索

## 2.1 十五要素

1. 基准代码：一份代码，多份部署
1. 依赖：
1. 配置、凭证、代码
1. 后端服务
1. 设计、构建、发布、运行
1. 无状态进程
1. 端口绑定
1. 并发
1. 易处理
1. 环境等价
1. 日志
1. 管理进程
1. API优先
1. 遥测
1. 认证和授权

## 2.2 云原生设计理念

1. 面向分布式设计：容器、微服务、API驱动
1. 面向配置设计：一个镜像，多个环境配置
1. 面向韧性设计：熔断、限流、故障容忍、自愈
1. 面向弹性设计：弹性扩展和对环境变化（负载）作出相应
1. 面向交付设计：自动拉起，缩短交付时间
1. 面向性能设计：响应式，并发和资源高效利用
1. 面向自动化设计：自动化的DevOps
1. 面向诊断性设计：集群级别的日志、metric和追踪
1. 面向安全性设计：安全端点、API Gateway、端到端加密

## 2.3 编排上移论

自己无法编排和管理自己，自身一定是自闭环的，所以总有更上一层的对象编排自己

* IaaS：资源编排
* Kubernetes：容器编排
* ServiceMesh：微服务编排
* APaaS：应用编排
* GraphQL：API编排
* 产品：功能编排
* 解决方案：产品编排
* 业务中台：能力编排

# 3 其他

面向终态是k8s的核心理念之一，那么面向终态设计的核心手段就是「声明式API」

运维的本质是面向过程的，所以过程也需要定义。如同人的一生的终态是走向死亡，终态真的是我们向往的吗？我们需要去拓宽生命的宽度，寻找幸福的意义。云原生中的运维也是类似的，所有资源都有生命周期，有生命周期就有过程，有过程就有状态，有状态就有状态机

解耦是为了更好的组合，那如何来把控粒度呢？这其实可以从物理学的发展看出一二。理论上人类文明进化得越高，微观会更微，宏观会更宏，例如量子力学和相对论。所以粒度的大小是跟当今社会的创新能力相匹配的

解耦的关键在于自闭环，组合的关键在于编排，自动化的关键在于调度和调协

未来我们要打技术生态，对于技术点的组合编排创新必然成为主旋律。可以这么说，单点技术很难发挥价值和沉淀下来，也极易被替换，靠做单点被集成去获得生态，这条路很难长久。一个好的平台，其中的任何一个技术点在都是可替换的。技术编排的时代到来了，云原生的最终目标是解交付，而非成本，为了更快创新

实现自动化的关键就是定义好每个资源的生命周期，并编排每个阶段的钩子和订阅事件进行消费

一个好的架构一般会兼容人类的愚蠢，所以这里的旧业务可能是历史包袱，可能是知识瓶颈带来的偏见

所以有着严格约束的语言好呢，还是灵活万能的语言好呢？我认为跟它的使用场景有关，一味的统一只是抹杀了业务的丰富多彩，践行“通用就是无用”的理论

# 4 参考

* [CNCF-git](https://github.com/cncf)
* [CNCF对于云原生的定义](https://github.com/cncf/toc/blob/master/DEFINITION.md)
