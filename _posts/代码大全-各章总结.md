---
title: 代码大全-各章总结
date: 2017-11-26 18:40:18
tags: 
- 摘录
categories: 
- 代码规范
---

__目录__

<!-- toc -->
<!--more-->

# 1 第一章-欢迎进入软件构建的世界

1. __软件开发过程中，各种不同的活动__
    1. 定义问题（problem definition）
    1. 需求分析（requirements development）
    1. 规划构建（construction planning）
    1. 软件架构/高层设计（software architecture/high-level design）
    1. 详细设计（detailed design）
    1. 编码与调试（coding and debugging）
    1. 单元测试（unit testing）
    1. 集成测试（integration testing）
    1. 集成（integration）
    1. 系统测试（system testing）
    1. 保障维护（corrective maintenance）

## 1.1 要点

1. __软件构建__是软件开发的核心活动，构建活动是每个项目唯一一项必不可少的工作
1. 软件构建的主要活动包括
    * 详细设计
    * 编码
    * 调试
    * 集成
    * 开发者测试
1. 构建也常被称作“编码”和“编程”
1. 构建活动的质量对软件的质量有着实质性的影响
1. 对“如何进行构建”的理解程度，决定了程序员的优秀程度

# 2 第二章-用隐喻来更充分地理解软件开发

1. 通过把你不太理解的东西和一些你较为理解、且十分类似的东西做比较，你可以对这些不太理解的东西产生更深刻的理解，__这种使用隐喻的方式叫做建模（modeling）__
1. 模型的威力就在于其生动性，让你能够把握整个概念。它能隐隐地暗示各种属性（properties）、关系（relationships）以及需要补充查证的部分（additional areas of inquiry）
1. 科学发展的历史并不是一系列“错误”的隐喻到“正确”的隐喻的转变，而是一系列从“不太合适”的隐喻到“更好”的隐喻的转变
1. 对于编程来说，最大的挑战还是将问题概念化
1. 对于软件构建来说，“努力创造真正原创成果”的开发效率，往往低于专注于重用（reuse）以往项目的一些设计思想、代码以及测试用例（test case）的开发效率
1. 一次设计系统的一小部分、写出一段代码、做一点测试，并将成果一点点添加到整个系统中。__通过这种小步前进，你可以把每次可能遇到的麻烦减到最小__
1. 在进行增量式开发时，我们先做出软件系统的一个尽可能简单、但能运行的版本。它不必接受真实的输入，也无需对数据进行真正的处理，更不用产生真实的输出--它仅仅需要构成一个足够强壮的__骨架__，支撑起未来将要开发的真实系统。对于你标识出的每一项基本功能，可能仅需要调用虚假的类（dummy classes）
1. 作为一个隐喻而言，__增量式开发的优势在于未做过度承诺__
1. 一项规划得当的项目能够提升你“在后期改变细节（设计）”的能力
1. 超大型的结构一旦出现问题，后果将非常严重，因此有必要对这样的结构进行超出常规的规划与建设（over-engineered）
1. 对于超大型项目，不太可能有一个人能完全理解这种规模的项目的所有设计细节--甚至只是通读一遍都不那么容易
1. 很多常见的软件开发术语都是从__建筑这一隐喻__中衍生出来的
    1. 软件架构（建筑学，architecture）
    1. 支撑性测试代码（脚手架，scaffolding）
    1. 构建（建设，construction）
    1. 基础类（foundation classes）
    1. 分离代码（tearing code apart）

## 2.1 要点

1. 隐喻是启示而不是算法。因此它们往往有一点随意
1. 隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好地理解
1. 有些隐喻比其他一些隐喻更贴切
1. 通过把软件的构建过程比作房屋的建设过程，我们可以发现，仔细的准备是必要的，而大型项目和小型项目之间也是有差异的
1. 通过把软件开发中的实践比作是智慧工具箱中的工具，我们又发现，每位程序员都有许多工具，但并不存在任何一个能适用于所有工作的工具，__因地制宜地选择正确的工具是成为能有效编程的程序员的关键__
1. 不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合

# 3 第三章-三思而后行：前期准备

1. 将项目中最昂贵的部分（构建）执行两遍，这无论在软件行业还是其他行业都是愚蠢的主意
1. __测试只是完整的质量保证的一部分，而且不是最有影响的部分__。测试是不可能检查出诸如“制造了一个错误的产品”，或者“使用错误的方法制造正确的产品”之类的缺陷。这样的缺陷必须在测试之前解决--更确切地说是在构建活动之前
1. 有一些程序员确实知道如何进行前期工作，但是它们并没有做，因为他们__不能抵抗“尽快开始编码”的欲望:)__
1. 程序员是软件食物链的最后一环：架构师吃掉需求；设计师吃掉架构；程序员吃掉设计
1. __发现错误的时间要尽可能地接近引入该错误的时间。缺陷在软件食物链里面呆的时间越长，它对食物链的后级造成的损害就越严重__
1. 如果没有一个良好的问题定义，你努力解决的可能是一个错误的问题
1. 明确的需求有助于确保用户（而不是程序员）驾驭系统的功能。如果需求明确，那么用户就可以自行评审，并进行核准。否则，程序员就常常会在编程期间自行决定需求。明确的需求避免你去猜测用户想要的是什么
1. 充分详尽的需求，是项目成功的关键，它甚至可能比有效的构建技术更重要
1. 一旦需求稳定，项目就能以__有序的、可预测的、平稳的__方式，完成从架构到设计到编码到测试等一系列工作
1. __为什么要把架构作为前期准备？因为架构的质量决定了系统的“概念完整性”。后者继而决定了系统的最终质量__
1. 系统架构首先要以概括的形式对有关系统做一个综述，架构应该定义程序的主要构造块（building blocks），应该明确定义各个构造块的责任
1. __每个构造块应该负责某一个区域的事情，并且对其他构造块负责的区域知道的越少越好__。通过使各个构造块对其他构造块的了解达到最小，才能将设计的信息局限于各个构造块之内
1. 应该明确定义每个构造块的通信规则，对于每个构造块，架构应该描述它能直接使用哪些构造块，能间接使用哪些构造块，不能使用哪些构造块
1. 架构无须详细说明系统中的每一个类。__瞄准80/20法则：对哪些构成系统80%行为的20%的类进行详细说明__
1. 架构师应该清楚地指出程序员应该“为了谨慎起见宁可进行过度工程（overengineering）”，还是应该做出最简单的能工作的东西
1. 架构应该踏在对系统“欠描述”和“过度描述”之间的那条线上
1. 架构应该明确地指出有风险的区域 

## 3.1 核对表

### 3.1.1 需求核对表

__针对功能需求__

1. 是否详细定义了系统的全部输入，包括其来源、精度、取值范围、出现频率等？
1. 是否详细定义了系统的全部输出，包括目的地、精度、取值范围、出现频率、格式等？
1. 是否详细定义了所有输出格式（Web页面、报表、等等）？
1. 是否详细定义了所有硬件及软件的外部接口？
1. 是否详细定义了全部外部通信接口，包括握手协议、纠错协议、通信协议等？
1. 是否列出了用户想要做的全部事情？
1. 是否详细定义了每个任务所用的数据，以及每个任务得到的数据？

__针对非功能需求（质量需求）__

1. 是否为全部必要的操作，从用户的视角，详细描述了期望响应时间？
1. 是否详细描述了其他与设计有关的考虑，例如处理时间、数据传输率、系统吞吐量？
1. 是否详细定义了安全级别？
1. 是否详细定义了可靠性，包括软件失灵的后果、发生故障时需要保护的至关重要的信息、错误检测与恢复的策略等？
1. 是否详细定义了机器内存和剩余磁盘空间的最小值？
1. 是否详细定义了系统的可维护性，包括适应特定功能的变更、操作环境的变更、与其他软件接口的变更能力？
1. 是否包含对“成功”与“失败”的定义？

__需求的质量__

1. 需求是用用户的语言写的码？用户也这么认为吗？
1. 每条需求都不与其他需求冲突吗？
1. 是否详细定义了相互竞争的特性之间的权衡---例如，健壮性与正确性之间的权衡？
1. 是否避免在需求中规定设计（方案）？
1. 需求是否在详细程度上保持相当一致的水平？有些需求应该更详细地描述吗？有些需求应该更粗略地描述吗？
1. 需求是否足够清晰，即使转交给一个独立的小组去构建，它们也能理解吗？开发者也这么想吗？
1. 每个条款都与待解决的问题及其解决方案相关吗？能从每个条款上溯到它在问题域中对应的根源吗？
1. 是否每条需求都是可测试的？是否可能进行独立的测试，以检验满不满足各项需求？
1. 是否详细描述了所有可能的对需求的改动，包括各项改动的可能性？

__需求的完备性__

1. 对于在开始之前无法获得的信息，是否详细描述了信息不完全的区域？
1. 需求的完备度是否能达到这种程度：如果产品满足所有需求，那么它就是可接受的？
1. 你对全部需求都感到很舒服吗？你是否已经去掉了那些不可能实现的需求---那些只是为了安抚客户和老板的东西？

### 3.1.2 架构核对表

__针对各架构主题__

1. 程序的整体组织结构是否清晰？是否包含一个良好的架构全局观（及其理由）？
1. 是否明确定义了主要的构造块（包括每个构造块的职责范围及与其他构造块的接口）？
1. 是否明显涵盖了“需求”中列出的所有功能（每个功能对应的构造块不太多也不太少）？
1. 是否描述并论证了那些最关键的类？
1. 是否描述并论证了数据设计？
1. 是否详细定义了数据库的组织结构和内容？
1. 是否指出了所用关键的业务规则，并描述其对系统的影响？
1. 是否描述了用户界面设计的策略？
1. 是否将用户界面模块化，使界面的变更不会影响程序其他部分？
1. 是否描述并论证了处理I/O的策略？
1. 是否估算了稀缺资源（如线程、数据库连接、句柄、网络带宽等）的使用量，是否描述并论证了资源管理的策略？
1. 是否描述了架构的安全需求？
1. 架构是否为每个子类、每个子系统、或每个功能域提出空间与时间预算？
1. 架构是否描述了如何达到可伸缩性？
1. 架构是否关注互操作性？
1. 是否描述了国际化/本地化的策略？
1. 是否提供了一套内聚的错误处理策略？
1. 是否规定了容错的办法（如果需要）？
1. 是否证实了系统各个部分的技术可行性？
1. 是否详细描述了过度工程的方法？
1. 是否包含了必要的“买vs造”的策略？
1. 架构是否描述了如何加工被复用的代码，使之符合其他架构目标？
1. 是否将架构设计得能够适应很可能出现的变更？

__架构的总体质量__

1. 架构是否解决了全部需求？
1. 有没有哪个部分是过度架构或欠架构？是否明确宣布了在这个方面的预期指标？
1. 整个架构是否在概念上协调一致？
1. 顶层设计是否独立于作用实现它的机器和语言？
1. 是否说明了所有主要的决策的动机？
1. 作为一名实现该系统的程序员，是否对这个架构感觉良好？

### 3.1.3 前期准备核对表

1. 你是否辨明了自己所从事的软件的类型，并对所用的开发方法做出相应的裁剪？
1. 是否充分明确地定义了需求？而且需求足够稳定？能开始构建了？（详见需求核对表）
1. 是否充分明确定义了架构，以便开始构建？（详见架构核对表）
1. 是否已经指出当前项目中独有的风险，以避免构建活动面临不必要的风险？

## 3.2 要点

1. 构建活动的准备工作的__根本目标在于降低风险__。要确认你的准备活动是在降低风险，而非增加风险
1. 如果向开发高质量的软件，软件开发过程必须由始至终关注质量。在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的影响要大
1. 程序员的一部分工作是教育老板和合作者，告诉他们软件开发过程，包括在开始编程之前进行充分准备的重要性
1. 你所从事的软件项目的类型对构建活动的前期准备有重大影响---许多项目应该是高度迭代的，某些应该是序列式的
1. 如果没有明确的问题定义，那么你可能会在构建期间解决错误的问题
1. 如果没有做完良好的需求分析，你可能没能察觉待解决的问题的重要细节。__如果需求变更发生在构建之后的阶段，其代价是“在项目早期更改需求”的20-100倍__。因此在开始编程之前，你要确认“需求”已经到位了
1. 如果没有做完良好的架构设计，你可能会在构建期间用错误的方法解决正确的问题。__架构变更的代价随着“为错误的架构编写代码的数量”增加而增加__，因此，也要确认“架构”已经到位了
1. 理解项目的前期准备所采用的方法，并相应地选择构建方法

# 4 第四章-选择主要的构建实践方法

## 4.1 核对表

### 4.1.1 构建实践核对表

__编码__

1. 你有没有确定，多少设计工作将要预先进行，多少设计工作在键盘上进行（在编写代码的同时）？
1. 你有没有规定诸如名称、注释、代码格式等“编码约定”？
1. 你有没有规定特定的由软件架构确定的编码实践，比如如何处理错误条件、如何处理安全性事项、对于类接口有哪些约定、可重用的代码遵循哪些标准、在编码时考虑多少性能因素等？
1. 你有没有找到自己在技术浪潮中的位置，并相应调整自己的措施？如果必要，你是否知道如何“深入一种语言去编程”，而不受限于语言（仅仅“在一种语言上编程”）？

__团队工作__

1. 你有没有定义一套集成工具---即，你有没有定义一套特定的步骤，规定程序员在把代码check in（签入）到主源码（代码库）中之前，必须履行这些步骤？
1. 程序员是结对编程、还是独自编程，或者这二者的某种组合？

__质量保证__

1. 程序员在编写代码之前，是否先为之编写测试用例？
1. 程序员会为自己的代码写单元测试吗（无论先写还是后写）？
1. 程序员在check in代码之前，会用调试器单步跟踪整个代码流程吗？
1. 程序员在check in代码之前，是否进行集成测试（integration-test）？
1. 程序员会复审（review）或检查别人的代码吗？

__工具__

1. 你是否选用了某种版本控制工具？
1. 你是否选定了一种语言，以及语言的版本或编译器版本？
1. 你是否选择了某个编程框架（framework，如J2EE或Microsoft.NET），或明确决定不使用编程框架？
1. 你是否决定允许使用非标准的语言特性？
1. 你是否选定并拥有了其他将要用到的工具---编译器、重构工具、调试器、测试框架（test framework）、语法检查器等？

## 4.2 要点

1. 每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点
1. 在开始编程之前，做好一些约定。改变代码使之符合这些约定是近乎不可能的
1. “构建的实践方法”的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的实践方法
1. 问问你自己，你采用的编程实践是对你所用的编程语言的正确响应，还是受它控制？请记得“深入一种语言去编程”，不要仅“在一种语言上编程”
1. 你在技术浪潮中的位置决定了哪种方法是有效的---甚至是可能用到的。确定你在技术浪潮中的位置，并相应调整计划和预期目标

# 5 第五章-软件构建中的设计

## 5.1 核对表

### 5.1.1 构造设计核对表

__设计实践__

1. 你已经做过多次迭代，并且从众多尝试结果中选择最佳的一种，而不是简单选择一次尝试的结果吗？
1. 你尝试用多种方案来分解系统，以确定最佳方案吗？
1. 你同时用自下而上和自上而下的方法来解决设计问题吗？
1. 为了解决某些特定的问题，你对系统中的风险部分或者不熟悉的部分创建过原型、写出数量最少的可抛弃的代码吗？
1. 你的设计方案被其他人检查了吗（无论正确与否）？
1. 你一直在开展设计，直到实施细节跃然纸上了吗？
1. 你用某种适当的技术---比如说Wiki、电子邮件、挂图、数码照片、UML、CRC卡或者在代码写注释---来保留设计成果吗？

__设计目标__

1. 你的设计是否充分地处理了由系统架构层定义出并且推迟确定的事项？
1. 你的设计被划分为层次吗？
1. 你对把这一程序分解成为子程序、包和类的方式感到满意吗？
1. 你把对这个类分解成为子程序的方法感到满意吗？
1. 类与类之间的交互关系是否已设计为最小化了？
1. 类和子程序是否被设计为能够在其他的系统中重用？
1. 程序是不是易于维护？
1. 设计是否精简？设计出来的每一部分都绝对必要吗？
1. 设计中是否采用了标准的技术？是否避免使用怪异且难以理解的元素？
1. 整体而言，你的设计是否有助于最小化偶然性和本质性的复杂度吗？

## 5.2 要点

1. 软件的首要技术使命就是管理复杂度。以简单性为努力目标的设计方案对此最有帮助
1. 简单性可以通过两种方式来获取：一是__减少在同一时间所关注的本质性复杂度的量__，二是避免生成不必要的偶然的复杂度
1. 设计时一种启发式的过程。固执于某一种单一方法会损害创新能力，从而损害你的程序
1. 好的设计都是迭代的。你尝试设计的可能性越多，你的最终设计方案就会变得越好
1. 信息隐藏是个非常有价值的概念。通过询问“我应该隐藏些什么？”能够解决很多困难的设计问题

# 6 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《代码大全》
