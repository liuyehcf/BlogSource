---
title: 代码大全-各章总结
date: 2017-11-26 18:40:18
tags: 
- 摘录
categories: 
- 代码规范
---

__目录__

<!-- toc -->
<!--more-->

# 1 第一章-欢迎进入软件构建的世界

1. __软件开发过程中，各种不同的活动__
    1. 定义问题（problem definition）
    1. 需求分析（requirements development）
    1. 规划构建（construction planning）
    1. 软件架构/高层设计（software architecture/high-level design）
    1. 详细设计（detailed design）
    1. 编码与调试（coding and debugging）
    1. 单元测试（unit testing）
    1. 集成测试（integration testing）
    1. 集成（integration）
    1. 系统测试（system testing）
    1. 保障维护（corrective maintenance）

## 1.1 要点

1. __软件构建__是软件开发的核心活动，构建活动是每个项目唯一一项必不可少的工作
1. 软件构建的主要活动包括
    * 详细设计
    * 编码
    * 调试
    * 集成
    * 开发者测试
1. 构建也常被称作“编码”和“编程”
1. 构建活动的质量对软件的质量有着实质性的影响
1. 对“如何进行构建”的理解程度，决定了程序员的优秀程度

# 2 第二章-用隐喻来更充分地理解软件开发

1. 通过把你不太理解的东西和一些你较为理解、且十分类似的东西做比较，你可以对这些不太理解的东西产生更深刻的理解，__这种使用隐喻的方式叫做建模（modeling）__
1. 模型的威力就在于其生动性，让你能够把握整个概念。它能隐隐地暗示各种属性（properties）、关系（relationships）以及需要补充查证的部分（additional areas of inquiry）
1. 科学发展的历史并不是一系列“错误”的隐喻到“正确”的隐喻的转变，而是一系列从“不太合适”的隐喻到“更好”的隐喻的转变
1. 对于编程来说，最大的挑战还是将问题概念化
1. 对于软件构建来说，“努力创造真正原创成果”的开发效率，往往低于专注于重用（reuse）以往项目的一些设计思想、代码以及测试用例（test case）的开发效率
1. 一次设计系统的一小部分、写出一段代码、做一点测试，并将成果一点点添加到整个系统中。__通过这种小步前进，你可以把每次可能遇到的麻烦减到最小__
1. 在进行增量式开发时，我们先做出软件系统的一个尽可能简单、但能运行的版本。它不必接受真实的输入，也无需对数据进行真正的处理，更不用产生真实的输出--它仅仅需要构成一个足够强壮的__骨架__，支撑起未来将要开发的真实系统。对于你标识出的每一项基本功能，可能仅需要调用虚假的类（dummy classes）
1. 作为一个隐喻而言，__增量式开发的优势在于未做过度承诺__
1. 一项规划得当的项目能够提升你“在后期改变细节（设计）”的能力
1. 超大型的结构一旦出现问题，后果将非常严重，因此有必要对这样的结构进行超出常规的规划与建设（over-engineered）
1. 对于超大型项目，不太可能有一个人能完全理解这种规模的项目的所有设计细节--甚至只是通读一遍都不那么容易
1. 很多常见的软件开发术语都是从__建筑这一隐喻__中衍生出来的
    1. 软件架构（建筑学，architecture）
    1. 支撑性测试代码（脚手架，scaffolding）
    1. 构建（建设，construction）
    1. 基础类（foundation classes）
    1. 分离代码（tearing code apart）

## 2.1 要点

1. 隐喻是启示而不是算法。因此它们往往有一点随意
1. 隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好地理解
1. 有些隐喻比其他一些隐喻更贴切
1. 通过把软件的构建过程比作房屋的建设过程，我们可以发现，仔细的准备是必要的，而大型项目和小型项目之间也是有差异的
1. 通过把软件开发中的实践比作是智慧工具箱中的工具，我们又发现，每位程序员都有许多工具，但并不存在任何一个能适用于所有工作的工具，__因地制宜地选择正确的工具是成为能有效编程的程序员的关键__
1. 不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合

# 3 第三章-三思而后行：前期准备

1. 将项目中最昂贵的部分（构建）执行两遍，这无论在软件行业还是其他行业都是愚蠢的主意
1. __测试只是完整的质量保证的一部分，而且不是最有影响的部分__。测试是不可能检查出诸如“制造了一个错误的产品”，或者“使用错误的方法制造正确的产品”之类的缺陷。这样的缺陷必须在测试之前解决--更确切地说是在构建活动之前
1. 有一些程序员确实知道如何进行前期工作，但是它们并没有做，因为他们__不能抵抗“尽快开始编码”的欲望:)__
1. 程序员是软件食物链的最后一环：架构师吃掉需求；设计师吃掉架构；程序员吃掉设计
1. __发现错误的时间要尽可能地接近引入该错误的时间。缺陷在软件食物链里面呆的时间越长，它对食物链的后级造成的损害就越严重__
1. 如果没有一个良好的问题定义，你努力解决的可能是一个错误的问题
1. 明确的需求有助于确保用户（而不是程序员）驾驭系统的功能。如果需求明确，那么用户就可以自行评审，并进行核准。否则，程序员就常常会在编程期间自行决定需求。明确的需求避免你去猜测用户想要的是什么
1. 充分详尽的需求，是项目成功的关键，它甚至可能比有效的构建技术更重要
1. 一旦需求稳定，项目就能以__有序的、可预测的、平稳的__方式，完成从架构到设计到编码到测试等一系列工作
1. __为什么要把架构作为前期准备？因为架构的质量决定了系统的“概念完整性”。后者继而决定了系统的最终质量__
1. 系统架构首先要以概括的形式对有关系统做一个综述，架构应该定义程序的主要构造块（building blocks），应该明确定义各个构造块的责任
1. __每个构造块应该负责某一个区域的事情，并且对其他构造块负责的区域知道的越少越好__。通过使各个构造块对其他构造块的了解达到最小，才能将设计的信息局限于各个构造块之内
1. 应该明确定义每个构造块的通信规则，对于每个构造块，架构应该描述它能直接使用哪些构造块，能间接使用哪些构造块，不能使用哪些构造块
1. 架构无须详细说明系统中的每一个类。__瞄准80/20法则：对哪些构成系统80%行为的20%的类进行详细说明__
1. 架构师应该清楚地指出程序员应该“为了谨慎起见宁可进行过度工程（overengineering）”，还是应该做出最简单的能工作的东西
1. 架构应该踏在对系统“欠描述”和“过度描述”之间的那条线上
1. 架构应该明确地指出有风险的区域 

## 3.1 核对表

### 3.1.1 需求核对表

__针对功能需求__

1. 是否详细定义了系统的全部输入，包括其来源、精度、取值范围、出现频率等？
1. 是否详细定义了系统的全部输出，包括目的地、精度、取值范围、出现频率、格式等？
1. 是否详细定义了所有输出格式（Web页面、报表、等等）？
1. 是否详细定义了所有硬件及软件的外部接口？
1. 是否详细定义了全部外部通信接口，包括握手协议、纠错协议、通信协议等？
1. 是否列出了用户想要做的全部事情？
1. 是否详细定义了每个任务所用的数据，以及每个任务得到的数据？

__针对非功能需求（质量需求）__

1. 是否为全部必要的操作，从用户的视角，详细描述了期望响应时间？
1. 是否详细描述了其他与设计有关的考虑，例如处理时间、数据传输率、系统吞吐量？
1. 是否详细定义了安全级别？
1. 是否详细定义了可靠性，包括软件失灵的后果、发生故障时需要保护的至关重要的信息、错误检测与恢复的策略等？
1. 是否详细定义了机器内存和剩余磁盘空间的最小值？
1. 是否详细定义了系统的可维护性，包括适应特定功能的变更、操作环境的变更、与其他软件接口的变更能力？
1. 是否包含对“成功”与“失败”的定义？

__需求的质量__

1. 需求是用用户的语言写的码？用户也这么认为吗？
1. 每条需求都不与其他需求冲突吗？
1. 是否详细定义了相互竞争的特性之间的权衡---例如，健壮性与正确性之间的权衡？
1. 是否避免在需求中规定设计（方案）？
1. 需求是否在详细程度上保持相当一致的水平？有些需求应该更详细地描述吗？有些需求应该更粗略地描述吗？
1. 需求是否足够清晰，即使转交给一个独立的小组去构建，它们也能理解吗？开发者也这么想吗？
1. 每个条款都与待解决的问题及其解决方案相关吗？能从每个条款上溯到它在问题域中对应的根源吗？
1. 是否每条需求都是可测试的？是否可能进行独立的测试，以检验满不满足各项需求？
1. 是否详细描述了所有可能的对需求的改动，包括各项改动的可能性？

__需求的完备性__

1. 对于在开始之前无法获得的信息，是否详细描述了信息不完全的区域？
1. 需求的完备度是否能达到这种程度：如果产品满足所有需求，那么它就是可接受的？
1. 你对全部需求都感到很舒服吗？你是否已经去掉了那些不可能实现的需求---那些只是为了安抚客户和老板的东西？

### 3.1.2 架构核对表

__针对各架构主题__

1. 程序的整体组织结构是否清晰？是否包含一个良好的架构全局观（及其理由）？
1. 是否明确定义了主要的构造块（包括每个构造块的职责范围及与其他构造块的接口）？
1. 是否明显涵盖了“需求”中列出的所有功能（每个功能对应的构造块不太多也不太少）？
1. 是否描述并论证了那些最关键的类？
1. 是否描述并论证了数据设计？
1. 是否详细定义了数据库的组织结构和内容？
1. 是否指出了所用关键的业务规则，并描述其对系统的影响？
1. 是否描述了用户界面设计的策略？
1. 是否将用户界面模块化，使界面的变更不会影响程序其他部分？
1. 是否描述并论证了处理I/O的策略？
1. 是否估算了稀缺资源（如线程、数据库连接、句柄、网络带宽等）的使用量，是否描述并论证了资源管理的策略？
1. 是否描述了架构的安全需求？
1. 架构是否为每个子类、每个子系统、或每个功能域提出空间与时间预算？
1. 架构是否描述了如何达到可伸缩性？
1. 架构是否关注互操作性？
1. 是否描述了国际化/本地化的策略？
1. 是否提供了一套内聚的错误处理策略？
1. 是否规定了容错的办法（如果需要）？
1. 是否证实了系统各个部分的技术可行性？
1. 是否详细描述了过度工程的方法？
1. 是否包含了必要的“买vs造”的策略？
1. 架构是否描述了如何加工被复用的代码，使之符合其他架构目标？
1. 是否将架构设计得能够适应很可能出现的变更？

__架构的总体质量__

1. 架构是否解决了全部需求？
1. 有没有哪个部分是过度架构或欠架构？是否明确宣布了在这个方面的预期指标？
1. 整个架构是否在概念上协调一致？
1. 顶层设计是否独立于作用实现它的机器和语言？
1. 是否说明了所有主要的决策的动机？
1. 作为一名实现该系统的程序员，是否对这个架构感觉良好？

### 3.1.3 前期准备核对表

1. 你是否辨明了自己所从事的软件的类型，并对所用的开发方法做出相应的裁剪？
1. 是否充分明确地定义了需求？而且需求足够稳定？能开始构建了？（详见需求核对表）
1. 是否充分明确定义了架构，以便开始构建？（详见架构核对表）
1. 是否已经指出当前项目中独有的风险，以避免构建活动面临不必要的风险？

## 3.2 要点

1. 构建活动的准备工作的__根本目标在于降低风险__。要确认你的准备活动是在降低风险，而非增加风险
1. 如果向开发高质量的软件，软件开发过程必须由始至终关注质量。在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的影响要大
1. 程序员的一部分工作是教育老板和合作者，告诉他们软件开发过程，包括在开始编程之前进行充分准备的重要性
1. 你所从事的软件项目的类型对构建活动的前期准备有重大影响---许多项目应该是高度迭代的，某些应该是序列式的
1. 如果没有明确的问题定义，那么你可能会在构建期间解决错误的问题
1. 如果没有做完良好的需求分析，你可能没能察觉待解决的问题的重要细节。__如果需求变更发生在构建之后的阶段，其代价是“在项目早期更改需求”的20-100倍__。因此在开始编程之前，你要确认“需求”已经到位了
1. 如果没有做完良好的架构设计，你可能会在构建期间用错误的方法解决正确的问题。__架构变更的代价随着“为错误的架构编写代码的数量”增加而增加__，因此，也要确认“架构”已经到位了
1. 理解项目的前期准备所采用的方法，并相应地选择构建方法

# 4 第四章-关键的“构建”决策

## 4.1 核对表

### 4.1.1 构建实践核对表

__编码__

1. 你有没有确定，多少设计工作将要预先进行，多少设计工作在键盘上进行（在编写代码的同时）？
1. 你有没有规定诸如名称、注释、代码格式等“编码约定”？
1. 你有没有规定特定的由软件架构确定的编码实践，比如如何处理错误条件、如何处理安全性事项、对于类接口有哪些约定、可重用的代码遵循哪些标准、在编码时考虑多少性能因素等？
1. 你有没有找到自己在技术浪潮中的位置，并相应调整自己的措施？如果必要，你是否知道如何“深入一种语言去编程”，而不受限于语言（仅仅“在一种语言上编程”）？

__团队工作__

1. 你有没有定义一套集成工具---即，你有没有定义一套特定的步骤，规定程序员在把代码check in（签入）到主源码（代码库）中之前，必须履行这些步骤？
1. 程序员是结对编程、还是独自编程，或者这二者的某种组合？

__质量保证__

1. 程序员在编写代码之前，是否先为之编写测试用例？
1. 程序员会为自己的代码写单元测试吗（无论先写还是后写）？
1. 程序员在check in代码之前，会用调试器单步跟踪整个代码流程吗？
1. 程序员在check in代码之前，是否进行集成测试（integration-test）？
1. 程序员会复审（review）或检查别人的代码吗？

__工具__

1. 你是否选用了某种版本控制工具？
1. 你是否选定了一种语言，以及语言的版本或编译器版本？
1. 你是否选择了某个编程框架（framework，如J2EE或Microsoft.NET），或明确决定不使用编程框架？
1. 你是否决定允许使用非标准的语言特性？
1. 你是否选定并拥有了其他将要用到的工具---编译器、重构工具、调试器、测试框架（test framework）、语法检查器等？

## 4.2 要点

1. 每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点
1. 在开始编程之前，做好一些约定。改变代码使之符合这些约定是近乎不可能的
1. “构建的实践方法”的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的实践方法
1. 问问你自己，你采用的编程实践是对你所用的编程语言的正确响应，还是受它控制？请记得“深入一种语言去编程”，不要仅“在一种语言上编程”
1. 你在技术浪潮中的位置决定了哪种方法是有效的---甚至是可能用到的。确定你在技术浪潮中的位置，并相应调整计划和预期目标

# 5 第五章-软件构建中的设计

## 5.1 核对表

### 5.1.1 构造设计核对表

__设计实践__

1. 你已经做过多次迭代，并且从众多尝试结果中选择最佳的一种，而不是简单选择一次尝试的结果吗？
1. 你尝试用多种方案来分解系统，以确定最佳方案吗？
1. 你同时用自下而上和自上而下的方法来解决设计问题吗？
1. 为了解决某些特定的问题，你对系统中的风险部分或者不熟悉的部分创建过原型、写出数量最少的可抛弃的代码吗？
1. 你的设计方案被其他人检查了吗（无论正确与否）？
1. 你一直在开展设计，直到实施细节跃然纸上了吗？
1. 你用某种适当的技术---比如说Wiki、电子邮件、挂图、数码照片、UML、CRC卡或者在代码写注释---来保留设计成果吗？

__设计目标__

1. 你的设计是否充分地处理了由系统架构层定义出并且推迟确定的事项？
1. 你的设计被划分为层次吗？
1. 你对把这一程序分解成为子程序、包和类的方式感到满意吗？
1. 你把对这个类分解成为子程序的方法感到满意吗？
1. 类与类之间的交互关系是否已设计为最小化了？
1. 类和子程序是否被设计为能够在其他的系统中重用？
1. 程序是不是易于维护？
1. 设计是否精简？设计出来的每一部分都绝对必要吗？
1. 设计中是否采用了标准的技术？是否避免使用怪异且难以理解的元素？
1. 整体而言，你的设计是否有助于最小化偶然性和本质性的复杂度吗？

## 5.2 要点

1. 软件的首要技术使命就是管理复杂度。以简单性为努力目标的设计方案对此最有帮助
1. 简单性可以通过两种方式来获取：一是__减少在同一时间所关注的本质性复杂度的量__，二是避免生成不必要的偶然的复杂度
1. 设计时一种启发式的过程。固执于某一种单一方法会损害创新能力，从而损害你的程序
1. 好的设计都是迭代的。你尝试设计的可能性越多，你的最终设计方案就会变得越好
1. 信息隐藏是个非常有价值的概念。通过询问“我应该隐藏些什么？”能够解决很多困难的设计问题

# 6 第六章-可以工作的类

## 6.1 核对表

### 6.1.1 类质量核对表

__抽象数据类型__

1. 你是否把程序中的类都看做是抽象数据类型？是否从这个角度评估它们的接口了？

__抽象__

1. 类是否有一个中心目的？
1. 类的命名是否恰当？其名字是否表达了其中心目的？
1. 类的接口是否展现了一致的抽象？
1. 类的接口是否能让人清楚明白地知道该如何使用它？
1. 类的接口是否足够抽象，使你能不必顾虑它是如何实现其服务的？你能把类看做黑盒子吗？
1. 类提供的服务是否足够完整，能让其他类无须动用其内部数据？
1. 是否已从类中除去无关信息？
1. 是否考虑过把类进一步分解为组件类？是否已尽可能将其分解？
1. 在修改类时是否维持了其接口的完整性？

__封装__

1. 是否把类的成员的可访问性降低到最小？
1. 是否避免暴露类中的数据成员？
1. 在编程语言所许可的范围内，类是否已尽可能地对其他类隐藏了自己的实现细节？
1. 类是否避免对其使用者，包括其派生类会如何使用它做了假设？
1. 类是否不依赖于其他类？它是松散耦合的吗？

__继承__

1. 继承是否只用来建立一个“是一个/is a”的关系？也就是说，派生类是否遵循了LSP（Liskov替换原则P144）？
1. 类的文档中是否记述了其继承策略？
1. 派生类是否避免了“覆盖”不可覆盖的方法？
1. 是否把公用的接口、数据和行为都放到尽可能高的继承层次中了？
1. 继承层次是否很浅？
1. 基类中所有的数据成员是否都被定义为private而非protected的了？

__与实现相关的问题__

1. 类中是否只有大约七个或更少的数据成员？
1. 是否把类直接或间接调用其他类的子程序的数量见到最少了？
1. 类是否只在绝对必要时才与其他的类相互协作？
1. 是否在构造函数中初始化了所有的数据成员？
1. 除非拥有了经过测量的、创建浅层复本的理由，类是否都被设计为当做深层复本使用？

__与语言相关的问题__

1. 你是否研究过所用编程语言里和类相关的各种特有问题？

## 6.2 要点

1. 类的接口应提供一致的抽象。很多问题都是由于违背该原则而引起的
1. 类的接口应该隐藏一些信息--如某个系统接口、某项设计决策、或一些实现细节
1. 包含往往比继承更为可取--除非你要对“是一个/is a”的关系建模
1. 继承是一种有用的工具，但它却会增加复杂度，这有违于软件的首要技术使命--管理复杂度
1. 类是管理复杂度的首选工具。要在设计类时给予足够的关注，才能实现这一目标

# 7 第七章-高质量的子程序

## 7.1 核对表

### 7.1.1 子程序质量核对表

__大局事项__

1. 创建子程序的理由充分吗？
1. 一个程序中所有适于单独提出的部分是不是已经被提出到单独的子程序中了？
1. 过程的名字中是否用了强烈、清晰的“动词+宾语”词组？函数的名字是否描述了其返回值？
1. 子程序的名字是否描述了它所作的全部事情？
1. 是否给常用的操作建立了命名规则？
1. 子程序是否具有强烈的功能上的内聚性？即它是否做且只做一件事，并且把它做得很好？
1. 子程序之间是否有较松的耦合？子程序与其他子程序之间的连接是否是小的（small）、明确的（intimate）、可见的（viaible）和灵活的（flexible）？
1. 子程序的长度是否是由其功能和逻辑自然确定，而非遵循任何人为的编码标准？

__参数传递事宜__

1. 整体来看，子程序的参数表是否表现出一种具有整体性且一致的接口抽象？
1. 子程序的参数的排列顺序是否合理？是否与类似的子程序的参数排列顺序相符？
1. 接口假定是否已在文档中说明？
1. 子程序的参数个数是否没超过7个？
1. 是否用到了每一个输入参数？
1. 是否用到了每一个输出参数？
1. 子程序是否避免了把输入参数用作工作变量？
1. 如果子程序是一个函数，那么它是否在所有可能的情况下都能返回一个合法的值？

## 7.2 要点

1. 创建子程序最主要的目的是提高程序的可管理性，当然也有其他一些好的理由。其中，节省代码空间只是一个次要原因：提高可读性、可靠性和可修改性等原因都更重要一些
1. 有时候，把一些简单的操作写成独立的子程序也非常有价值
1. 子程序可以按照其内聚性分为很多类，而你应该让大多数子程序具有功能上的内聚性，这是最佳的一种内聚性
1. 子程序的名字是它的质量的指示器。如果名字糟糕但恰如其分，那就说明这个子程序设计得很差经。如果名字糟糕而且又不准确，那么它就反映不出程序是干什么的。不管怎样，糟糕的名字都意味着程序需要修改
1. 只有在某个子程序的主要目的是返回其名字所描述的特定结果时，才应该使用函数
1. 细心的程序员会非常谨慎地使用宏，而且只有在万不得已时才用

# 8 第八章-防御式编程

## 8.1 核对表

### 8.1.1 防御式编程核对表

__一般事宜__

1. 子程序是否保护自己免遭有害输入数据的破坏？
1. 你用断言来说明编程假定吗？其中包括了前条件和候条件吗？
1. 断言是否只是用来说明从不应该发生的情况？
1. 你是否在架构或高层设计中规定了一组特定的错误处理技术？
1. 你是否在架构或高层设计中规定了是让错误处理更倾向于健壮性还是正确性？
1. 你是否建立了隔栏来遏制错误可能造成的破坏？是否减少了其他需要关注错误处的代码的数量？
1. 代码中用到辅助调试的代码了吗？
1. 如果需要启用或禁用添加的辅助助手的话，是否无须大动干戈？
1. 在防御式编程时引入的代码量是否适宜--既不过多，也不过少？
1. 你在开发阶段是否采用了进攻式编程来使错误难以被忽视？

__异常__

1. 你在项目中定义了一套标准化的异常处理方案？
1. 是否考虑过异常之外的其他替代方案？
1. 如果可能的话，是否在局部处理了错误而不是把它当成一个异常抛到外部？
1. 代码中是否避免了在构造函数和析构函数中抛出异常？
1. 所有的异常是否都与抛出它们的子程序处于同一抽象层次上？
1. 每个异常是否都包含了关于异常发生的所有背景信息？
1. 代码中是否没有使用空的catch语句？（或者如果使用空的catch语句确实合适，那么明确说明了吗？）

__安全事宜__

1. 检查有害输入数据的代码是否也检查了故意的缓冲区溢出、SQL注入、HTML注入、整数溢出以及其他恶意输入的数据？
1. 是否检查了所有的错误返回码？
1. 是否捕获了所有的异常？
1. 出错消息中是否避免出现有助于攻击者攻入系统所需的信息？

## 8.2 要点

1. 最终产品代码中对错误的处理方式要比“垃圾进，垃圾出”复杂得多
1. 防御式编程技术可以让错误更容易发现、更容易修改，并减少错误对产品代码的破坏
1. 断言可以帮助人尽早发现错误，尤其是在大型系统和高可靠性的系统中，以及快速变化的代码中
1. 关于如何处理错误输入的决策是一项关键的错误处理决策，也是一项关键的高层设计决策
1. 异常提供了一种与代码正常流程角度不同的错误处理手段。如果留心使用异常，它可以成为程序员们知识工具箱中的一项有益补充，同时也应该在异常和其他错误处理手段之间进行权衡比较
1. 针对产品代码的限制并不适用于开发中的软件。你可以利用这一优势在开发中添加有助于更快地排查错误的代码

# 9 第九章-伪代码编程过程

## 9.1 核对表

### 9.1.1 伪代码编程核对表

1. 是否检查过以满足所有的先决条件？
1. 定义好这个类要解决的问题了吗？
1. 高层次的设计是否足够清晰？能给这个类和其中的每一个子程序起一个好的名字吗？
1. 考虑过该如何测试这个类及其中每一个子程序了吗？
1. 关于效率的问题，你主要从稳定的接口和可读的实现这两个角度考虑吗？还是主要从满足资源和速度的预期目标的角度考虑过呢？
1. 在函数标准库或其他代码库中寻找过可用的子程序或者组件了吗？
1. 在参考书籍中查找过有用的算法了吗？
1. 是否用详尽的伪代码设计好每一个子程序？
1. 你在脑海里检查过伪代码吗？这些伪代码容易理解吗？
1. 关注过那些可能会让你重返设计的警告信息了吗？（比如说关于全局数据的使用、一些看上去更适合放在另一个类或子程序中的操作等）
1. 是否把伪代码正确地翻译成代码了？
1. 你反复使用伪代码编程过程了吗？有没有根据需要把一些子程序拆分成更小的子程序？
1. 在做出假定（assumptions）的时候有没有对它们加以说明？
1. 已经删除掉那些冗余的注释了吗？
1. 你是否采取了几次迭代中最好的那个结果？还是在第一次迭代之后就停止了？
1. 你完全理解你的代码了吗？这些代码是否容易理解？

## 9.2 要点

1. 创建类和子程序通常都是一个迭代的过程。在创建子程序的过程中获得的知识常常会反过来影响类的设计
1. 编写好的伪代码需要使用易懂的英语，要避免使用特定编程语言中才有的特性，同时要在意图的层面上写伪代码（即描述该做什么，而不是要怎么去做）
1. 伪代码编写过程是一个行之有效的做详细设计的工具，它同时让编码工作更容易。伪代码会直接转化为注释，从而确保了注释的准确度和实用性
1. 不要只停留在你所想到的第一个设计方案上。反复使用伪代码做出多种方案，然后选出其中最佳的一种方案再开始编码
1. 每一步完成后都要检查你的工作成果，还要鼓励其他人帮你来检查，这样你就会在投入精力最少的时候，用最低的成本发现错误

# 10 第十章-变量

## 10.1 核对表

### 10.1.1 数据使用注意事项核对表

__初始化变量__

1. 每一个子程序都检查其输入参数的正确性了吗？
1. 变量声明位置靠近变量第一次使用的位置吗？
1. 尽可能地在声明变量的同时初始化变量吗？
1. 如果无法同时声明和初始化变量，有没有在靠近第一次使用变量的位置声明变量？
1. 计数器和累加器经过了适当的初始化吗？如果需要再一次使用，之前重新初始化了吗？
1. 适当地重新初始化“需要重复执行的代码里的变量”了吗？
1. 代码在通过编译器编译的时候是不是没有警告信息？（你启用了所有可用的警告选项了吗？）
1. 如果你用的语言允许隐式声明，你为由此可能引发的问题做好补偿措施了吗？

__使用数据的其他事项__

1. 如果可能，所有变量都被定义为具有最小的作用域了吗？
1. 各变量的引用点都尽可能集中在一起吗？对同一变量的两次相邻引用，或者变量的整个生命周期都这样做了吗？
1. 控制结构符合数据类型吗？
1. 所有声明的变量都用到了吗？
1. 变量都在合适的时间绑定了吗？--也就是说，你有意识地在晚期绑定所带来的灵活性和增加的复杂度之间做出平衡了吗？
1. 每个变量都有且仅有一项用途吗？
1. 每个变量的含义都明确且没有隐含含义吗？

## 10.2 要点

1. 数据初始化过程很容易出错，所以请用本章描述的初始化方法（P240)来避免非预期的初始值而造成的错误
1. 最小化每个变量的作用域。把同一变量的引用点集中在一起。把变量限定在子程序或类的范围之内。避免使用全局数据
1. 把使用相同变量的语句尽可能地集中子在一起
1. 早期绑定会减低灵活性，但有助于减小复杂度。晚期绑定可以增加灵活性，同时增加复杂度
1. 把每个变量用于唯一的用途

# 11 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《代码大全》
