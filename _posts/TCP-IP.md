---
title: TCP/IP
date: 2017-07-10 18:45:39
tags: 
- 原创
categories:
- 网络
---

__目录__

<!-- toc -->
<!--more-->

# 1 前言

TCP（Transmission Control Protocol 传输控制协议）是一种__面向连接的、可靠的、基于字节流__的传输层通信协议，由IETF的RFC 793定义。

# 2 TCP报文格式以及11种状态

__TCP报文中重要的字段：__

1. __序号__：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 
1. __确认序号__：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
1. __标志位__：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
1. __URG__：紧急指针（urgent pointer）有效。
1. __ACK__：确认序号有效。
1. __PSH__：接收方应该尽快将这个报文交给应用层。
1. __RST__：重置连接。
1. __SYN__：发起一个新连接。
1. __FIN__：释放一个连接。

__需要注意的是：__

1. 不要将确认序号Ack与标志位中的ACK搞混了。
2. 确认方Ack=发起方Req+1，两端配对。

__TCP连接中的11种状态：__

1. __`CLOSED`__：起始点，不在连接状态。可以主动打开连接，或者等待对端的连接。
    * 收到“被动打开”报文，进入LISTEN状态。
    * 收到“主动打开”报文，进入SYN_SENT状态。
    * 收到任何报文段，发送RST报文段。
    * 收到其它任何报文段，发出差错报文。
1. __`LISTEN`__：被动打开，TCP正在等待对端的连接请求。
    * 收到“发送数据”报文，发送SYN报文段，进入SYN_SENT状态。
    * 收到任何SYN报文段，发送SYN+ACK报文段，进入SYN_RECEIVED状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`SYN_SENT`__：主动打开，发送完一个连接请求后等待回复。
    * 超时，进入CLOSED状态。
    * 收到SYN报文段，发送SYN+ACK报文段，进入SYN_RECEIVED状态。
    * 收到SYN+ACK报文段，发送ACK报文段，进入ESTABLISHED状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`SYN_RECEIVED`__：被动打开，接受连接请求以后进行确认同时也向对端发送连接请求发送，等待对方的回复。
    * 超时，发送RST报文段，进入CLOSED状态。
    * 收到ACK报文段，进入ESTABLISHED状态。
    * 收到"关闭"报文，发送FIN报文段，进入FIN_WAIT_1状态。
    * 收到RST报文段，进入LISTEN状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`ESTABLISHED`__：三次握手完毕，TCP连接建立完成，可以传输数据。
    * 收到FIN报文段，进入CLOSED_WAIT状态。
    * 收到“关闭”报文，发送FIN报文段，进入FIN_WAIT_1状态。
    * 收到RST或SYN报文段，发出差错报文。
    * 收到数据或ACK报文段，调用输入模块。
    * 收到“发送”报文，调用输出模块。
1. __`FIN_WAIT_1`__：四次挥手开始，主动关闭，发送断开连接请求，等待对端确认。
    * 收到FIN报文段，发送ACK报文段，进入CLOSING状态（同时关闭）。
    * 收到FIN+ACK报文段，发送ACK报文段，进入FIN_WAIT状态（？）。
    * 收到ACK报文段，进入FIN_WAIT_2状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`FIN_WAIT_2`__：接收对方确认，但未接受对方的断开连接请求。
    * 收到FIN报文段，发送ACK报文段，进入TIME_WAIT状态。
1. __`CLOSING`__：主动关闭的一方本希望收到对方的ACK却收到了对方的断开连接请求。
    * 收到ACK报文段，进入TIME_WAIT状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`TIME_WAIT`__：对方确认后发起断开连接请求，需要等待2MSL保证正常关闭。
    * 超时，进入CLOSED状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`CLOSE_WAIT`__：被动关闭，确认对端的连接终止请求，但是未向对端发送连接终止请求（可能数据没传完）。
    * 收到"关闭"报文，发送FIN报文段，进入LAST_ACK状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`LAST_ACK`__：数据传完，向对端发起断开连接请求后等待确认。
    * 收到ACK报文段，进入CLOSED状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`CLOSED`__：终点，不在连接状态。可以主动打开连接，或者等待对端的连接。

# 3 三次握手

所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示： 

![三次握手](/images/TCP-IP/三次握手.png)

__三次握手流程如下__

1. 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 
1. 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 
1. 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 

__SYN攻击__： 

> 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行： `netstat -nap | grep SYN_RECV`

__为什么需要三次握手__：

> __为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误__。举例来说，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”
这就很明白了，防止了服务器端的一直等待而浪费资源。

> 我们换一种说法。设想：如果只有两次握手，那么第二次握手后服务器只向客户端发送ACK包，此时客户端与服务器端建立连接。在这种握手规则下：假设：如果发送网络阻塞，由于TCP/IP协议定时重传机制，B向A发送了两次SYN请求，分别是`x1`和`x2`，且因为阻塞原因，导致`x1`连接请求和`x2`连接请求的TCP窗口大小和数据报文长度不一致，如果最终`x1`达到A，`x2`丢失，此时A同B建立了`x1`的连接，这个时候，因为AB已经连接，B无法知道是请求`x1`还是请求`x2`同B连接，如果B默认是最近的请求`x2`同A建立了连接，此时B开始向A发送数据，数据报文长度为`x2`定义的长度，窗口大小为`x2`定义的大小，而A建立的连接是`x1`，其数据包长度大小为`x1`，TCP窗口大小为`x1`定义，这就会导致A处理数据时出错。很显然，如果A接收到B的请求后，A向B发送SYN请求y3（y3的窗口大小和数据报长度等信息为`x1`所定义），确认了连接建立的窗口大小和数据报长度为`x1`所定义，A再次确认回答建立`x1`连接，然后开始相互传送数据，那么就不会导致数据处理出错了。

# 4 四次挥手

所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：

![四次挥手1](/images/TCP-IP/四次挥手1.png)

__由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭__，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，__收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN__。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

1. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入`FIN_WAIT_1`状态。 
1. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入`CLOSE_WAIT`状态。
1. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入`LAST_ACK`状态。 
1. 第四次挥手：Client收到FIN后，Client进入`TIME_WAIT`状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：

![四次挥手2](/images/TCP-IP/四次挥手2.png)

# 5 参考

* [TCP/IP协议三次握手与四次握手流程解析](http://www.2cto.com/net/201310/251896.html)
* [TCP/IP为什么要进行三次握手？](http://blog.csdn.net/zhushuai1221/article/details/51008950)
