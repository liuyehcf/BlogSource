---
title: TCP/IP
date: 2017-07-10 18:45:39
tags: 
- 摘录
categories: 
- 网络
---

__目录__

<!-- toc -->
<!--more-->

# 1 前言

TCP（Transmission Control Protocol 传输控制协议）是一种__面向连接的、可靠的、基于字节流__的传输层通信协议，由IETF的RFC 793定义。

# 2 TCP报文格式以及11种状态

__TCP报文中重要的字段：__

1. __序号__：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 
1. __确认序号__：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
1. __标志位__：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
1. __URG__：紧急指针（urgent pointer）有效。
1. __ACK__：确认序号有效。
1. __PSH__：接收方应该尽快将这个报文交给应用层。
1. __RST__：重置连接。
1. __SYN__：发起一个新连接。
1. __FIN__：释放一个连接。

__需要注意的是：__

1. 不要将确认序号Ack与标志位中的ACK搞混了。
2. 确认方Ack=发起方Req+1，两端配对。

__TCP连接中的11种状态：__

1. __`CLOSED`__：起始点，不在连接状态。可以主动打开连接，或者等待对端的连接。
    * 收到"被动打开"报文，进入LISTEN状态。
    * 收到"主动打开"报文，进入SYN_SENT状态。
    * 收到任何报文段，发送RST报文段。
    * 收到其它任何报文段，发出差错报文。
1. __`LISTEN`__：被动打开，TCP正在等待对端的连接请求。
    * 收到"发送数据"报文，发送SYN报文段，进入SYN_SENT状态。
    * 收到任何SYN报文段，发送SYN+ACK报文段，进入SYN_RECEIVED状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`SYN_SENT`__：主动打开，发送完一个连接请求后等待回复。
    * 超时，进入CLOSED状态。
    * 收到SYN报文段，发送SYN+ACK报文段，进入SYN_RECEIVED状态。
    * 收到SYN+ACK报文段，发送ACK报文段，进入ESTABLISHED状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`SYN_RECEIVED`__：被动打开，接受连接请求以后进行确认同时也向对端发送连接请求发送，等待对方的回复。
    * 超时，发送RST报文段，进入CLOSED状态。
    * 收到ACK报文段，进入ESTABLISHED状态。
    * 收到"关闭"报文，发送FIN报文段，进入FIN_WAIT_1状态。
    * 收到RST报文段，进入LISTEN状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`ESTABLISHED`__：三次握手完毕，TCP连接建立完成，可以传输数据。
    * 收到FIN报文段，进入CLOSED_WAIT状态。
    * 收到"关闭"报文，发送FIN报文段，进入FIN_WAIT_1状态。
    * 收到RST或SYN报文段，发出差错报文。
    * 收到数据或ACK报文段，调用输入模块。
    * 收到"发送"报文，调用输出模块。
1. __`FIN_WAIT_1`__：四次挥手开始，主动关闭，发送断开连接请求，等待对端确认。
    * 收到FIN报文段，发送ACK报文段，进入CLOSING状态（同时关闭）。
    * 收到FIN+ACK报文段，发送ACK报文段，进入FIN_WAIT状态（？）。
    * 收到ACK报文段，进入FIN_WAIT_2状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`FIN_WAIT_2`__：接收对方确认，但未接受对方的断开连接请求。
    * 收到FIN报文段，发送ACK报文段，进入`TIME_WAIT`状态。
1. __`CLOSING`__：主动关闭的一方本希望收到对方的ACK却收到了对方的断开连接请求。
    * 收到ACK报文段，进入`TIME_WAIT`状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`TIME_WAIT`__：对方确认后发起断开连接请求，需要等待2MSL保证正常关闭。
    * 超时，进入CLOSED状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`CLOSE_WAIT`__：被动关闭，确认对端的连接终止请求，但是未向对端发送连接终止请求（可能数据没传完）。
    * 收到"关闭"报文，发送FIN报文段，进入LAST_ACK状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`LAST_ACK`__：数据传完，向对端发起断开连接请求后等待确认。
    * 收到ACK报文段，进入CLOSED状态。
    * 收到任何其它报文段或者报文，发送差错报文。
1. __`CLOSED`__：终点，不在连接状态。可以主动打开连接，或者等待对端的连接。

__MSL是Maximum Segment Lifetime英文的缩写__，中文可以译为"报文最大生存时间"，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为tcp报文（segment）是ip数据报（datagram）的数据部分，具体称谓请参见《数据在网络各层中的称呼》一文，而ip头中有一个TTL域，TTL是time to live的缩写，中文可以译为"生存时间"，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。

2MSL即两倍的MSL，TCP的`TIME_WAIT`状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了`TIME_WAIT`状态，必须在此状态上停留两倍的MSL时间，__等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包__。在`TIME_WAIT`状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。

# 3 三次握手

所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示： 

![三次握手](/images/TCP-IP/三次握手.png)

__三次握手流程如下__

1. 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 
1. 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 
1. 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 

__SYN攻击__： 

> 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行： `netstat -nap | grep SYN_RECV`

__为什么需要三次握手__：

> __为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误__。举例来说，"已失效的连接请求报文段"的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用"三次握手"，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用"三次握手"的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。"
这就很明白了，防止了服务器端的一直等待而浪费资源。

> 我们换一种说法。设想：如果只有两次握手，那么第二次握手后服务器只向客户端发送ACK包，此时客户端与服务器端建立连接。在这种握手规则下：假设：如果发送网络阻塞，由于TCP/IP协议定时重传机制，B向A发送了两次SYN请求，分别是`x1`和`x2`，且因为阻塞原因，导致`x1`连接请求和`x2`连接请求的TCP窗口大小和数据报文长度不一致，如果最终`x1`达到A，`x2`丢失，此时A同B建立了`x1`的连接，这个时候，因为AB已经连接，B无法知道是请求`x1`还是请求`x2`同B连接，如果B默认是最近的请求`x2`同A建立了连接，此时B开始向A发送数据，数据报文长度为`x2`定义的长度，窗口大小为`x2`定义的大小，而A建立的连接是`x1`，其数据包长度大小为`x1`，TCP窗口大小为`x1`定义，这就会导致A处理数据时出错。很显然，如果A接收到B的请求后，A向B发送SYN请求y3（y3的窗口大小和数据报长度等信息为`x1`所定义），确认了连接建立的窗口大小和数据报长度为`x1`所定义，A再次确认回答建立`x1`连接，然后开始相互传送数据，那么就不会导致数据处理出错了。

# 4 四次挥手

所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：

![四次挥手1](/images/TCP-IP/四次挥手1.png)

__由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭__，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，__收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN__。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

1. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入`FIN_WAIT_1`状态。 
1. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入`CLOSE_WAIT`状态。
1. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入`LAST_ACK`状态。 
1. 第四次挥手：Client收到FIN后，Client进入`TIME_WAIT`状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：

![四次挥手2](/images/TCP-IP/四次挥手2.png)

# 5 RST

__在TCP协议中RST(Reset the connection)表示复位，用来异常的关闭连接__，在TCP的设计中它是不可或缺的。发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。

其实在网络编程过程中，各种RST错误其实是比较难排查和找到原因的。下面我列出几种会出现RST的情况。

1. 端口未打开
1. 请求超时
1. 提前关闭
1. 在一个已关闭的socket上收到数据

# 6 `TIME_WAIT`状态

`TIME_WAIT`状态存在的理由
TCP/IP协议就是这样设计的，是不可避免的。主要有两个原因:

1. __可靠地实现TCP全双工连接的终止__
    * TCP协议在关闭连接的四次握手过程中，最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，__如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（`TIME_WAIT`）允许它重发最终的ACK__。如果A端不维持`TIME_WAIT`状态，而是处于CLOSED状态，那么A端在收到FIN后将会响应RST而不是ACK，B端收到RST后将此分节解释成一个错误。
    * 因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持`TIME_WAIT`状态。
1. __允许老的重复分节在网络中消逝__
    * TCP分节可能由于路由器异常而"迷途"，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个迟到的迷途分节到达时可能会引起问题。在关闭"前一个连接"之后，马上又重新建立起一个相同的IP和端口之间的"新连接"，__"前一个连接"的迷途重复分组在"前一个连接"终止后到达，而被"新连接"收到了__。为了避免这个情况，TCP协议不允许处于`TIME_WAIT`状态的连接启动一个新的可用连接，__因为`TIME_WAIT`状态持续2MSL，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。__

# 7 参考

* [TCP/IP协议三次握手与四次握手流程解析](http://www.2cto.com/net/201310/251896.html)
* [TCP/IP为什么要进行三次握手？](http://blog.csdn.net/zhushuai1221/article/details/51008950)
* [计算机网络——TCP协议中的三次握手四次挥手以及11种状态转换](http://blog.csdn.net/a987073381/article/details/52206215)
* [TIME_WAIT状态作用!](https://my.oschina.net/woyaoxue/blog/510669?p=1)
* [](http://www.360doc.com/content/13/0702/10/1073512_297069771.shtml)
