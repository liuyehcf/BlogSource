---
title: 编译原理-中间代码生成3
date: 2017-11-14 13:30:40
mathjax: true
tags: 
- 摘录
categories: 
- 编译
---

__目录__

<!-- toc -->
<!--more-->

# 1 控制流语句及其SDT

## 1.1 控制流语句的基本文法

$$
P \to S \\
S \to S_1S_2 \\
S \to id = E; | L = E; \\
S \to\;if\;B\;then \;S_1\;|\;if\;B\;then\;S_1\;else\;S_2\;|\;while\;B\;do\;S_1
$$

## 1.2 控制流语句的代码结构

布尔表达式$B$被翻译成由__跳转指令__构成的跳转代码，非终结符$B$包含如下__继承属性__

1. $S.next$：是一个地址，该地址中存放了紧跟在$S$代码之后的指令(S的__后继指令__)的__标号__
1. $B.true$：是一个地址，该地址中存放了当$B$为__真__时控制流转向的__指令的标号__
1. $B.false$：是一个地址，该地址中存放了当$B$为__假__时控制流转向的__指令的标号__
* 用指令的__标号__标识一条三地址指令

## 1.3 控制流语句的语义动作

1. $newlabel()$：生成一个用于存放标号的新的临时变量$L$，返回变量地址
1. $label(L)$：将__下一条__三地址指令的标号赋给$L$

## 1.4 控制流语句的SDT

### 1.4.1 $if-then-else$语句的SDT

![fig1](/images/编译原理-中间代码生成3/fig1.jpg)

### 1.4.2 $if-then$语句的SDT

![fig2](/images/编译原理-中间代码生成3/fig2.jpg)

### 1.4.3 $while-do$语句的SDT

![fig3](/images/编译原理-中间代码生成3/fig3.jpg)

# 2 布尔表达式及其SDT

## 2.1 布尔表达式的基本文法

$$
B \to B\;or\;B \\
|\;B\;and\;B \\
|\;not\;B \\
|\;(B)\; \\
|\;E\;relop\;E \\
|\;true \\
|\;false
$$

__优先级__：`not` \> `and` \> `or`
__relop（关系运算符）__：`<`, `<=`, `>`, `>=`，`==`, `!=`

在跳转代码中，逻辑运算符`&&`、`||` 和`!`被翻译成跳转指令。运算符本身不出现在代码中，布尔表达式的值是通过代码序列中的位置来表示的

![fig4](/images/编译原理-中间代码生成3/fig4.jpg)

## 2.2 布尔表达式的SDT

![fig5](/images/编译原理-中间代码生成3/fig5.jpg)

### 2.2.1 $B \to B_1\;or\;B_2$ 的SDT

![fig6](/images/编译原理-中间代码生成3/fig6.jpg)

### 2.2.2 $B \to B_1\;and\;B_2$ 的SDT

![fig7](/images/编译原理-中间代码生成3/fig7.jpg)

# 3 控制流翻译的例子

## 3.1 控制流语句的SDT

![fig8](/images/编译原理-中间代码生成3/fig8.jpg)

## 3.2 SDT的通用实现方法

任何SDT都可以通过下面的方法实现：首先建立一棵语法分析树，然后按照__从左到右__的__深度优先顺序__来执行这些动作

![fig9](/images/编译原理-中间代码生成3/fig9.jpg)

* 首先生成$L_1$用于存放$S.next$
* 执行完$S$后，才能确定$L_1$的值

![fig10](/images/编译原理-中间代码生成3/fig10.jpg)

* 生成$L_2$用于存放$S.begin$
* 确定$S.begin$的值，即$L_2=1$，即__下一条__三地址指令的标号
* 生成$L_3$用于存放$B.true$
* 将$B.false$__绑定为__$S.next$（这里用到绑定一词，当$S.next$最终确定后，$B.false$才会确定，因此这里只是绑定关系，而非最终确定$B.false$的值）

---

* 将$B$生成两条三地址指令
    * $1.\;if\;a<b\;goto\;L_3$
    * $2.\;goto\;L_1$
* 确定$B.true$的值，即$L_3=3$，即__下一条__三地址指令的标号
* 将$S_3.next$__绑定为__$S.begin$

![fig11](/images/编译原理-中间代码生成3/fig11.jpg)

* $S_3$展开为$if\;B\;then\;S_1\;else\;S_2$
* 生成$L_4$用于存放$B1.true$
* 生成$L_5$用于存放$B1.false$
* 将$B_1$生成两条三地址指令
    * $3.\;if\;c<d\;goto\;L_4$
    * $4.\;goto\;L_5$
* 确定$B1.true$的值，即$L_4=5$，即__下一条__三地址指令的标号
* $S_1.next$__绑定为__$S_3.next$
* 将$S_1$生成三地址指令
    * $5.\;t_1 = y+z$
    * $6.\;x = t_1$
* 生成三地址指令
    * $7.\;goto\;S_3.next$，即$7.\;goto\;S.begin$
* 确定$B1.false$的值，为即$L_5=8$，即__下一条__三地址指令的标号
* 将$S_2.next$__绑定为__$S_3.next$
* 将$S_2$生成三地址指令
    * $8.\;t_2 = y-z$
    * $9.\;x = t_2$
* 生成三地址指令
    * $10.\;goto\;S.begin$
* 确定$S.next$的值，即$L_1=11$，即__下一条__三地址指令的标号

![fig12](/images/编译原理-中间代码生成3/fig12.jpg)

![fig13](/images/编译原理-中间代码生成3/fig13.jpg)

# 4 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf#163.com，#替换成@)，博主将在第一时间删除__

* 《MOOC-编译原理-陈鄞》
