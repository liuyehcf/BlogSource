---
title: Java-垃圾收集算法
date: 2017-07-10 14:28:54
tags: 
- 摘录
categories: 
- Java
- Java Virtual Machine
- Garbage Collection
---

**阅读更多**

<!--more-->

# 1 前言

本篇博客主要介绍几种常用的垃圾收集算法以及分析他们的优劣势，并且给出这些算法在商用JVM中的使用情况

# 2 标记-清除算法

最基础的收集算法是"标记-清除"(Mark-Sweep)算法，算法分为"标记"和"清除"两个阶段：

1. 首先标记出所有需要回收的对象
1. 在标记完后统一回收所有被标记的对象

**优势：**

* 实现复杂度：实现简单
* 内存利用率：高

**劣势：**

* 内存碎片：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
* 算法执行效率：通过链表维护内存信息，存在大量链表遍历的操作

# 3 复制算法

为了解决效率问题，一种称为"复制"(Copying)的收集算法出现了

* 它将可用内存按容量划分为大小相等的两块，每次只使用其中一块
* 当一块的内存用完了，将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉

这使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效

复制算法的代价也是显而易见的：将可用内存缩小为原来的一半

现在商业虚拟机都采用这种收集算法来回收**新生代**，IBM公司专门研究表明，新生代中的对象98%是"朝生夕死"，因此并不需要按1：1的比例来划分内存空间

* 将内存分为一块较大的Eden空间和两块较小的Survivor空间
* 每次使用Eden和其中一块Survivor
* 当回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间
* HotSpot默认Eden和Survivor的大小比例是8：1，即每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的空间会被"浪费"
* 98%是一般场景下的数据，我们没法保证每次回收都只有不多于10%的对象存活，当Survivor不够用时，需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion)

**优势：**

* 实现复杂度：实现简单
* 内存碎片：无内存碎片

**劣势：**

* 内存利用率：要想不浪费50%的空间，就需要有额外的空间进行分配担保
* 算法执行效率：在对象存活率较高时就要进行较多的复制操作，效率将会变低

# 4 标记-整理算法

根据老年代的特点，提出了"标记-整理"(Mark-Compact)算法

* 标记过程仍然与"标记-清除"算法一样
* 但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

**优势：**

* 内存碎片：无内存碎片
* 内存利用率：内存利用率高

**劣势：**

* 实现复杂度：算法实现复杂度较高
* 算法执行效率：存在大量对象移动内存的操作，效率偏低

# 5 分代收集算法

当前商业虚拟机的垃圾收集都采用"分代收集"(Generational Collection)算法。这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块，一般把Java堆分为**新生代**和**老年代**，这样就可以根据各个年代的特点采用最适当的收集算法

* **在新生代中**：每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集
* **在老年代中**：对象存活率高，没有额外空间对它进行分配担保，就必须使用"标记-清理"或者"标记-整理"算法进行回收

# 6 总结

| 算法 | 实现复杂度 | 是否会产生内存碎片 | 内存利用率 | 算法执行效率 |
|:--|:--|:--|:--|:--|
| 标记-清除 | 低 | 是 | 高 | 低。内存组织方式是链表，存在大量遍历链表的操作 |
| 复制 | 低 | 否 | 低 | 通常情况较高。若在大量对象存活的情况下，效率降低 |
| 标记-整理 | 高 | 否 | 高 | 低。涉及到大量对象移动的操作 |

# 7 参考

* 《深入理解Java虚拟机》
