---
title: CMU-15-721
date: 2022-03-02 09:04:53
mathjax: true
tags: 
- 摘录
categories: 
- Database
---

**阅读更多**

<!--more-->

# 1 history

**`1960s - Integrated Data Store, IDS`**

* `Network data model`：见下图
* `Tuple-at-a-time`
* ![1-1](/images/CMU-15-721/1-1.png)

**`1960s - Information Management System, IMS`**

* `Hierarchical data model`：见下图
* `Programmer-defined physical storage format`
* `Tuple-at-a-time`
* ![1-2](/images/CMU-15-721/1-2.png)

**`1970s - Relational Model`**

* `Store database in simple data structures`
* `Access data through high-level language`
* `Physical storage left up to implementation`
* ![1-3](/images/CMU-15-721/1-3.png)
* 早期的实现包括
    * `System R`
    * `INGRES`
    * `Oracle`

**`1980s - Relational Model`**

* `Relation Model`在角逐中胜出，`SEQUEL`演变成为`SQL`
* `Oracle`在商业角逐中胜出
* `Stonebraker`创立了`Postgre`

**`1980s - Object-Oriented Databases`**

* 大多数这一阶段产生的`DBMS`在今天都不存在了，但是这些技术以另一种方式存在，比如`JSON/XML`等
* ![1-4](/images/CMU-15-721/1-4.png)
* ![1-5](/images/CMU-15-721/1-5.png)

**`1990s - Boring Days`**

* 这十年中，数据库系统没有重大进步
* 微软借鉴了`Sybase`，创立了`SQL Server`
* `Mysql`出现，作为`mSQL`的一种替代方案
* `Postgres`支持`SQL`
* `SQLite`在2000年早期出现

**`2000s - Internet Boom`**

* 网络大发展，分布式兴起
* 原有的数据库都是重量级且及其昂贵的，在分布式的场景中不再有优势
* 各大公司都独立开发中间件，用以支持`DBMS`的水平伸缩

**`2000s - Data Warehouses`**

* `OLAP`兴起
* `Relational / SQL`
* 分布式、`Shared-Noting`架构
* 列存大放异彩

**`2000s - NoSQL Systems`**

* 专注于高可用和高可扩展
* `Non-relational data model`，例如键值对
* 无`ACID`事务
* `API`取代了`SQL`

**`2010s - NewSQL`**

* 在支持`ACID`事务的同时，提供与`NoSQL`相当的性能
* `Relational / SQL`
* 分布式

**`2010s - Hybrid Systems`**

* `Hybrid Transactional-Analytical Processing, HTAP`
* 同时提供`OLTP`和`OLAP`的功能和性能
* 分布式、`Shared-Noting`架构
* `Relational / SQL`

**`2010s - Cloud Systems`**

* `DBaaS, Database-as-a-service`

**`2010s - Shared-Disk Engines`**

* 存储计算分离
* 通常用于数据湖（`Data Lake`）

**`2010s - Graph Systems`**

* 提供了针对图形的API
* 研究表明，尚不清楚使用以图形为中心的执行引擎和存储管理器是否有任何好处

**`2010s - Timeseries Systems`**

* 时序数据库，主要存储时序相关的数据

**`Andy's Thoughts`**

* 随着专用系统扩展其领域范围，`DBMS`类别的分界线将随着时间的推移而继续模糊
* 我相信关系模型和声明式查询语言促进了更好的数据工程

# 2 inmemory

## 2.1 Disk-Oriented DBMSs

**`Buffer Pool`**

**`Steal + No-Force`**

**示意图参考课件中的`7 ~ 13`页**

## 2.2 In-Memory DBMSs

**首批商用的`In-Memory DBMS`在`1990s`发布，包括：**

* `TimesTen`
* `DataBlitz`
* `Altibase`

**索引：**

* `1980s`提出了专门的主存索引，当时高速缓存和内存访问速度大致相当
* 但后来高速缓存的速度远远大于内存的访问速度时，内存优化索引的性能比`B+`树差，因为它们不支持缓存（为啥会不支持缓存）

**执行查询计划：**

* 由于数据都在内存中，顺序访问不再比随机访问快
* 传统的`tuple-at-a-time`的访问方式会因为函数调用的开销而变得很慢。这一情况在`OLAP`中更加突出

**`Logging & Recovery`**

* `In-Memory DBMS`也需要将`WAL`写入非易失性存储上，因为系统可能随时崩溃
* 由于不存在`Dirty Page`，因此无需追踪整个系统中的`LSN`

**性能瓶颈：对于`In-Memory DBMS`来说，`I/O`不再是性能瓶颈，同时其他开销也会被放大：**

* `Locking/Latching`
* `Cache-line misses`
* `Pointer chasing`
* `Predicate evaluations`
* `Data movement & copying`
* `Networking`

## 2.3 Concurrency Control Bottlenecks

对于`In-Memory DBMS`而言，事务获取锁的开销和访问数据的开销相当

* `DBMS`可以将`Lock Information`与数据存储在一起，提高`CPU Cache Locality`
* 需要用`CAS`替代`Mutex`

**`Concurrency Control Schemes`**

* `Two-Phase Locking, 2PL`
    * `DeadLock Detection`
    * `DeadLock Prevention`
    * **示意图参考课件中的`30 ~ 37`页**
* `Timestamp Ordering, T/O`
    * `Basic T/O`
    * `Optimistic Concurrency Control, OCC`
    * **示意图参考课件中的`40 ~ 63`页**

**仿真结果参考课件中的`71 ~ 75`页**

* `Schemes`
    * `DL_DETECT`：`2PL w/ DeadLock Detection`
    * `NO_WAIT`：`2PL w/ Non-waiting Prevention`
    * `WAIT_DIE``2PL w/ Wait-and-Die Prevention`
    * `TIMESTAMP`：`Basic T/O Algorithm`
    * `MVCC`：`Multi-Version T/O`
    * `OCC`：`Optimistic Concurrency Control`
* `Bottlenecks`
    * `Lock Thrashing`：`DL_DETECT`、`WAIT_DIE`
        * 按照`primary key`的顺序来获取锁，彻底消除死锁
    * `Timestamp Allocation`：`WAIT_DIE`、`All T/O Algorithm`
        * `Mutex`
        * `Atomic Addition`
        * `Batched Atomic Addition`
        * `Hardware Clock`
        * `Hardware Counter`
    * `Memory Allocations`：`OCC`、`MVCC`
        * 不要使用默认的`malloc`

# 3 mvcc1

# 4 mvcc2

# 5 mvcc3

# 6 oltpindexes1

# 7 oltpindexes2

# 8 storage

# 9 compression

# 10 recovery

# 11 networking

# 12 scheduling

# 13 execution

# 14 compilation

# 15 vectorization1

# 16 vectorization2

# 17 hashjoins

# 18 sortmergejoins

# 19 optimizer1

# 20 optimizer2

# 21 optimizer3

# 22 costmodels

# 23 largerthanmemory

# 24 udfs

# 25 hardware

# 26 课件

* [Index of /spring2020/slides](https://15721.courses.cs.cmu.edu/spring2020/slides/)
1. [01-history](/resources/CMU-15-721/01-history.pdf)
1. [02-inmemory](/resources/CMU-15-721/02-inmemory.pdf)
1. [03-mvcc1](/resources/CMU-15-721/03-mvcc1.pdf)
1. [04-mvcc2](/resources/CMU-15-721/04-mvcc2.pdf)
1. [05-mvcc3](/resources/CMU-15-721/05-mvcc3.pdf)
1. [06-oltpindexes1](/resources/CMU-15-721/06-oltpindexes1.pdf)
1. [07-oltpindexes2](/resources/CMU-15-721/07-oltpindexes2.pdf)
1. [08-storage](/resources/CMU-15-721/08-storage.pdf)
1. [09-compression](/resources/CMU-15-721/09-compression.pdf)
1. [10-recovery](/resources/CMU-15-721/10-recovery.pdf)
1. [11-networking](/resources/CMU-15-721/11-networking.pdf)
1. [12-scheduling](/resources/CMU-15-721/12-scheduling.pdf)
1. [13-execution](/resources/CMU-15-721/13-execution.pdf)
1. [14-compilation](/resources/CMU-15-721/14-compilation.pdf)
1. [15-vectorization1](/resources/CMU-15-721/15-vectorization1.pdf)
1. [16-vectorization2](/resources/CMU-15-721/16-vectorization2.pdf)
1. [17-hashjoins](/resources/CMU-15-721/17-hashjoins.pdf)
1. [18-sortmergejoins](/resources/CMU-15-721/18-sortmergejoins.pdf)
1. [19-optimizer1](/resources/CMU-15-721/19-optimizer1.pdf)
1. [20-optimizer2](/resources/CMU-15-721/20-optimizer2.pdf)
1. [21-optimizer3](/resources/CMU-15-721/21-optimizer3.pdf)
1. [22-costmodels](/resources/CMU-15-721/22-costmodels.pdf)
1. [23-largerthanmemory](/resources/CMU-15-721/23-largerthanmemory.pdf)
1. [24-udfs](/resources/CMU-15-721/24-udfs.pdf)
1. [25-hardware](/resources/CMU-15-721/25-hardware.pdf)
