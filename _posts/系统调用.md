---
title: 系统调用
date: 2017-08-20 17:23:51
tags: 
- 摘录
categories: 
- 操作系统
- 基本概念
---

__目录__

<!-- toc -->
<!--more-->

# 1 内核态与用户态

![fig1](/images/系统调用/fig1)

__用户态__：

* Ring3运行于用户态的代码则要受到处理器的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段（TSS）中I/O许可位图（I/O Permission Bitmap）中规定的可访问端口进行直接访问
* 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈

__内核态__：

* Ring0在处理器的存储保护中，核心态，或者特权态（与之相对应的是用户态），是__操作系统内核所运行的模式__。运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。
* 当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈

# 2 用户/内核态切换过程

进程从用户态到内核态切换过程中，Linux主要做的事：

1. 读取tr寄存器，访问TSS段
1. 从TSS段中的sp0获取进程内核栈的栈顶指针
1. 由控制单元在内核栈中保存当前eflags，cs，ss，eip，esp寄存器的值。
1. 由SAVE_ALL保存其寄存器的值到内核栈
1. 把内核代码选择符写入CS寄存器，内核栈指针写入ESP寄存器，把内核入口点的线性地址写入EIP寄存器

此时，CPU已经切换到内核态，根据EIP中的值开始执行内核入口点的第一条指令。

# 3 上下文Context

用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等。__所谓的"进程上下文"，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。__

相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。

1. __用户级上下文__：正文、数据、用户堆栈以及共享存储区
1. __寄存器上下文__：通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)
1. __系统级上下文__：进程控制块`task_struct`、内存管理信息(`mm_struct`、`vm_area_struct`、`pgd`、`pte`)、内核栈

当发生进程调度时，进行进程切换就是上下文切换(context switch)。操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。而系统调用进行的模式切换(mode switch)。模式切换与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切换。

硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的"中断上下文"，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。中断时，内核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一般不会阻塞。

# 4 用户态切换到内核态的3种方式

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

1. __系统调用__：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用__申请使用操作系统提供的服务程序__完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。
1. __异常__：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
1. __外围设备的中断__：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

# 5 什么是系统调用

![fig2](/images/系统调用/fig2.jpg)

__系统调用是给操作系统通信用的。顺便说一句，操作系统的职责是进程管理、地址空间管理、设备管理、文件管理等。所以，用到系统调用的大多是__：

* 让当前进程／线程睡觉，或让别的进程／线程醒来（进程管理）
* 内存映射，粗粒度地大块分配内存（内存管理）
* 对键盘、鼠标、硬盘、网络、显示器什么的进行操作（设备管理）
* 读写文件（文件管理）

__如果不需要和操作系统通信，就不需要系统调用。比如：__

* malloc，动态分配内存。偶尔需要和操作系统通信申请大块内存，但在当前进程已经有足够的内存的情况下，是不用系统调用的。
* spin lock。就是通过循环来进行的锁操作。它靠CPU的原子内存操作来实现互斥，也不需要系统调用。但是，如果是blocking lock，就是那种如果无法获取，就阻塞等待的那种锁，就需要，因为要告诉操作系统“请让我停下来，然后在锁准备好的时候叫醒我”。
* 写文件。如果是用内存映射的形式写文件，那么只要一开始用mmap系统调用映射内存，到最后用系统调用同步一下，中间就是普通的内存读写了，也不需要系统调用。但是，如果你用write函数，那么……没准，看操作系统如何实现了。
* 共享内存的进程间通信。和写文件一样，建立内存映射的过程需要系统调用，就是让两个进程的地址空间有重叠。但是，一旦建立好了，只要写内存就可以了，另一个进程是可以看到写入的内容的，因为本质就是从同样的物理内存地址读东西。
* math.h里的东西。这些东西就是数值运算，会翻译成特殊CPU指令，但不是系统调用。
* 异常处理（C++的throw、catch什么的），这些是特殊的控制流，可能需要特殊的库函数来做，这些库函数知道编译器生成的代码和栈的形状。但这完全在用户态就能做了，还是不涉及系统调用。
* C++标准库里的数据结构（数组、链表、映射什么的）和算法（查找、排序...），就是普通的C++代码实现的。
* 字符串处理函数（strcmp，strcpy，strcat，strstr什么的）还有内存拷贝（memcpy，memset什么的），有可能会为了性能而用汇编实现，但还是不需要系统调用。

# 6 参考

* [Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈](http://blog.csdn.net/yangkuanqaz85988/article/details/52403726)
* [用户空间与内核空间，进程上下文与中断上下文](http://www.cnblogs.com/Anker/p/3269106.html)
* [Linux 内核态与用户态](http://blog.csdn.net/xifeijian/article/details/9080895)
* [Linux探秘之用户态与内核态](http://www.cnblogs.com/bakari/p/5520860.html)
* [系统调用与过程调用](http://blog.csdn.net/shuyangxiaogou/article/details/5666098)
* [用户态到内核态切换之奥秘解析](http://www.cnblogs.com/justcxtoworld/p/3155741.html)
