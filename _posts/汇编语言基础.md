---
title: 汇编语言基础
date: 2021-10-15 16:17:52
tags: 
- 原创
categories: 
- Assembly
---

**阅读更多**

<!--more-->

# 1 Intel and AT&T Syntax

汇编语言有2种不同的语法，分别是`Intel Syntax`以及`AT&T Syntax`。它们在形式上大致相同，但是在细节上存在很大差异。极易混淆

|  | Intel | AT&T |
|:--|:--|:--|
| 注释 | `;` | `#` |
| 指令 | 无后缀，例如`add` | 有后缀，会带上操作数的类型大小，例如`addq` |
| 寄存器 | `eax`、`ebx`等等 | `%eax`、`%ebx`等等 |
| 立即数 | `0x100` | `$0x100` |
| 直接寻址 | `[eax]` | `(%eax)` |
| 间接寻址 | `[base + reg + reg * scale + displacement]` | `displacement(reg, reg, scale)` |

## 1.1 内存引用

**`Intel Syntax`的间接内存引用的格式为：`section:[base + index*scale + displacement]`**
**`AT&T Syntax`的间接内存引用的格式为：section:displacement(base, index, scale)**

* 其中，`base`和`index`是任意的`32-bit`的`base`和`index`寄存器
* `scale`可以取值`1`，`2`，`4`，`8`。如果不指定`scale`值，则默认值为`1`
* `section`可以指定任意的段寄存器作为段前缀，默认的段寄存器在不同的情况下不一样

**一些例子：**

1. `-4(%ebp)`
    * `base`：`%ebp`
    * `displacement`：`-4`
    * `section`：未指定
    * `index`：未指定，默认为0
    * `scale`：未指定，默认为1

# 2 指令

| 指令 | 描述 | 用法 |
|:--|:--|:--|
| lea | 加载有效地址 |  | 
| sar | 算数右移 |  |

## 2.1 如何查指令

* [Intel x86/x64 开发者手册 卷1](https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html)
* [Intel x86/x64 开发者手册 卷2](https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-manual.html)

# 3 寄存器

| 64-bit register	| Lower 32 bits	| Lower 16 bits	| Lower 8 bits |
|:--|:--|:--|:--|
| rax | eax | ax | al |
| rbx | ebx | bx | bl |
| rcx | ecx | cx | cl |
| rdx | edx | dx | dl |
| rsi | esi | si | sil |
| rdi | edi | di | dil |
| rbp | ebp | bp | bpl |
| rsp | esp | sp | spl |
| r8 | r8d | r8w | r8b |
| r9 | r9d | r9w | r9b |
| r10 | r10d | r10w | r10b |
| r11 | r11d | r11w | r11b |
| r12 | r12d | r12w | r12b |
| r13 | r13d | r13w | r13b |
| r14 | r14d | r14w | r14b |
| r15 | r15d | r15w | r15b |

**向量化相关寄存器**

| 寄存器名 | 位数 |
|:--|:--|
| xmm | 128 |
| ymm | 256 |
| zmm | 512 |

# 4 如何生成易读的汇编

**方式1：（并不容易看懂）**

```sh
# 生成汇编
gcc main.cpp -S -g -fverbose-asm

# 查看汇编
cat main.s
```

**方式2：**

```sh
# 生成目标文件
gcc main.cpp -c -g

# 反汇编（AT&T Syntax)
# -d: 仅显式可执行部分的汇编
# -r: 在重定位时显示符号名称
# -w: 以多于 80 列的宽度对输出进行格式化
# -C: 对修饰过的 (mangled) 符号名进行解码
# -S: 将源代码与反汇编混合在一起，便于阅读
objdump -drwCS main.o

# 反汇编（Intel Syntax）
objdump -drwCS -M intel main.o
```

# 5 参考

* [Assembly Programming Tutorial](https://www.tutorialspoint.com/assembly_programming/index.htm)
* [x86 instruction listings](https://en.wikipedia.org/wiki/X86_instruction_listings)
* [汇编语言入门一：环境准备](https://zhuanlan.zhihu.com/p/23618489)
* [汇编语言入门二：环境有了先过把瘾](https://zhuanlan.zhihu.com/p/23639191)
* [汇编语言入门三：是时候上内存了](https://zhuanlan.zhihu.com/p/23722940)
* [汇编语言入门四：打通C和汇编语言](https://zhuanlan.zhihu.com/p/23779935)
* [汇编语言入门五：流程控制（一）](https://zhuanlan.zhihu.com/p/23845369)
* [汇编语言入门六：流程控制（二）](https://zhuanlan.zhihu.com/p/23902265)
* [汇编语言入门七：函数调用（一）](https://zhuanlan.zhihu.com/p/24129384)
* [汇编语言入门八：函数调用（二）](https://zhuanlan.zhihu.com/p/24265088)
* [汇编语言入门九：总结与后续（闲扯）](https://zhuanlan.zhihu.com/p/24424432)
* [What is the difference between "mov (%rax),%eax" and "mov %rax,%eax"?](https://stackoverflow.com/questions/41232333/what-is-the-difference-between-mov-rax-eax-and-mov-rax-eax)
* [Using GCC to produce readable assembly?](https://stackoverflow.com/questions/1289881/using-gcc-to-produce-readable-assembly)
* [AT&T ASM Syntax详解](https://blog.csdn.net/opendba/article/details/6104485)
* [汇编语言--x86汇编指令集大全](https://zhuanlan.zhihu.com/p/53394807)