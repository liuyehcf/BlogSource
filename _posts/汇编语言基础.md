---
title: 汇编语言基础
date: 2021-10-15 16:17:52
tags: 
- 原创
categories: 
- Assembly
---

**阅读更多**

<!--more-->

# 1 Intel and AT&T Syntax

汇编语言有2种不同的语法，分别是`Intel Syntax`以及`AT&T Syntax`。它们在形式上大致相同，但是在细节上存在很大差异。极易混淆

|  | Intel | AT&T |
|:--|:--|:--|
| 注释 | `;` | `#` |
| 指令 | 无后缀，例如`add` | 有后缀，会带上操作数的类型大小，例如`addq` |
| 寄存器 | `eax`、`ebx`等等 | `%eax`、`%ebx`等等 |
| 立即数 | `0x100` | `$0x100` |
| 直接寻址 | `[eax]` | `(%eax)` |
| 间接寻址 | `[base + reg + reg * scale + displacement]` | `displacement(reg, reg, scale)` |

## 1.1 内存引用

**`Intel Syntax`的间接内存引用的格式为：`section:[base + index*scale + displacement]`**
**`AT&T Syntax`的间接内存引用的格式为：section:displacement(base, index, scale)**

* 其中，`base`和`index`是任意的`32-bit`的`base`和`index`寄存器
* `scale`可以取值`1`，`2`，`4`，`8`。如果不指定`scale`值，则默认值为`1`
* `section`可以指定任意的段寄存器作为段前缀，默认的段寄存器在不同的情况下不一样

**一些例子：**

1. `-4(%ebp)`
    * `base`：`%ebp`
    * `displacement`：`-4`
    * `section`：未指定
    * `index`：未指定，默认为0
    * `scale`：未指定，默认为1

# 2 指令

GNU汇编器语法的特点是：

```
助记符 源操作数 目的操作数
```

**数据传送指令：**

| 指令格式 | 描述 |
|:--|:--|
| `movl src dst` | 传双字 |
| `movw src dst` | 传单字 |
| `movb src dst` | 传字节 |
| `movsbl src dst` | 对`src`（字节）进行符号位填充，变为`dst`（双字） |
| `movzbl src dst` | 对`src`（字节）进行零填充，变为`dst`（双字） |
| `pushl src` | 压栈</br>`R[%esp] -= 4`</br>`M[R[%esp]] = src` |
| `popl dst` | 出栈</br>`dst = M[R[%esp]]`</br>`R[%esp] += 4` |
| `xchg mem/reg mem/reg` | 交换两个寄存器或者交换寄存器和内存之间的内容（至少有一个是寄存器）</br>两个操作数的数据类型要相同，比如一个是字节另一个也得是字节 |

**算数和逻辑操作指令：**

| 指令格式 | 描述 |
|:--|:--|
| `leal src dst` | `dst = &src`，`dst`只能是寄存器 |
| `incl dst` | `dst += 1` |
| `decl dst` | `dst -= 1` |
| `negl dst` | `dst = -dst` |
| `notl dst` | `dst = ~dst` |
| `addl src dst` | `dst += src` |
| `subl src dst` | `dst -= src` |
| `imull src dst` | `dst *= src` |
| `xorl src dst` | `dst ^= src` |
| `orl src dst` | `dst |= src` |
| `andl src dst` | `dst &= src` |
| `sall k dst` | `dst << k` |
| `shll k dst` | `dst << k`（同`sall`） |
| `sarl k dst` | `dst >> k` |
| `shrl k dst` | `dst >> k`（同`sarl`） |

**比较指令：**

| 指令格式 | 描述 |
|:--|:--|
| `cmpb s2 s1` | `s2 - s1`，比较字节，差关系 |
| `testb s2 s1` | `s2 & s1`，比较字节，与关系 |
| `cmpw s2 s1` | `s2 - s1`，比较字，差关系 |
| `testw s2 s1` | `s2 & s1`，比较字，与关系 |
| `cmpl s2 s1` | `s2 - s1`，比较双字，差关系 |
| `testl s2 s1` | `s2 & s1`，比较双字，与关系 |

**跳转指令：**

| 指令格式 | 描述 |
|:--|:--|
| `jmp Label` | 直接跳转 |
| `jmp *Operand` | 间接跳转 |
| `je Label` | 相等跳转 |
| `jne Label` | 不相等跳转 |
| `jz Label` | 零跳转 |
| `jnz Label` | 非零跳转 |
| `js Label` | 负数跳转 |
| `jns Label` | 非负跳转 |
| `jg Label` | 大于跳转 |
| `jnle Label` | 大于跳转 |
| `jge Label` | 大于等于跳转 |
| `jnl Label` | 大于等于跳转 |
| `jl Label` | 小于跳转 |
| `jnge Label` | 小于跳转 |
| `jle Label` | 小于等于跳转 |
| `jng Label` | 小于等于跳转 |

**其他：**

| 指令 | 描述 |
|:--|:--|
| `cli` | 关中断，ring0 |
| `sti` | 开中断，ring0 |

## 2.1 如何查指令

* [Intel x86/x64 开发者手册 卷1](https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html)
* [Intel x86/x64 开发者手册 卷2](https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-manual.html)
* [汇编指令速查](https://www.cnblogs.com/lsgxeva/p/8948153.html)

# 3 寄存器

| 64-bit register	| Lower 32 bits	| Lower 16 bits	| Lower 8 bits |
|:--|:--|:--|:--|
| rax | eax | ax | al |
| rbx | ebx | bx | bl |
| rcx | ecx | cx | cl |
| rdx | edx | dx | dl |
| rsi | esi | si | sil |
| rdi | edi | di | dil |
| rbp | ebp | bp | bpl |
| rsp | esp | sp | spl |
| r8 | r8d | r8w | r8b |
| r9 | r9d | r9w | r9b |
| r10 | r10d | r10w | r10b |
| r11 | r11d | r11w | r11b |
| r12 | r12d | r12w | r12b |
| r13 | r13d | r13w | r13b |
| r14 | r14d | r14w | r14b |
| r15 | r15d | r15w | r15b |

**向量化相关寄存器**

| 寄存器名 | 位数 |
|:--|:--|
| xmm | 128 |
| ymm | 256 |
| zmm | 512 |

# 4 如何生成易读的汇编

**方式1：（并不容易看懂）**

```sh
# 生成汇编
gcc main.cpp -S -g -fverbose-asm

# 查看汇编
cat main.s
```

**方式2：**

```sh
# 生成目标文件
gcc main.cpp -c -g

# 反汇编（AT&T Syntax)
# -d: 仅显式可执行部分的汇编
# -r: 在重定位时显示符号名称
# -w: 以多于 80 列的宽度对输出进行格式化
# -C: 对修饰过的 (mangled) 符号名进行解码
# -S: 将源代码与反汇编混合在一起，便于阅读
objdump -drwCS main.o

# 反汇编（Intel Syntax）
objdump -drwCS -M intel main.o
```

# 5 参考

* [Assembly Programming Tutorial](https://www.tutorialspoint.com/assembly_programming/index.htm)
* [x86 instruction listings](https://en.wikipedia.org/wiki/X86_instruction_listings)
* [汇编语言入门一：环境准备](https://zhuanlan.zhihu.com/p/23618489)
* [汇编语言入门二：环境有了先过把瘾](https://zhuanlan.zhihu.com/p/23639191)
* [汇编语言入门三：是时候上内存了](https://zhuanlan.zhihu.com/p/23722940)
* [汇编语言入门四：打通C和汇编语言](https://zhuanlan.zhihu.com/p/23779935)
* [汇编语言入门五：流程控制（一）](https://zhuanlan.zhihu.com/p/23845369)
* [汇编语言入门六：流程控制（二）](https://zhuanlan.zhihu.com/p/23902265)
* [汇编语言入门七：函数调用（一）](https://zhuanlan.zhihu.com/p/24129384)
* [汇编语言入门八：函数调用（二）](https://zhuanlan.zhihu.com/p/24265088)
* [汇编语言入门九：总结与后续（闲扯）](https://zhuanlan.zhihu.com/p/24424432)
* [What is the difference between "mov (%rax),%eax" and "mov %rax,%eax"?](https://stackoverflow.com/questions/41232333/what-is-the-difference-between-mov-rax-eax-and-mov-rax-eax)
* [Using GCC to produce readable assembly?](https://stackoverflow.com/questions/1289881/using-gcc-to-produce-readable-assembly)
* [AT&T ASM Syntax详解](https://blog.csdn.net/opendba/article/details/6104485)
* [汇编语言--x86汇编指令集大全](https://zhuanlan.zhihu.com/p/53394807)
