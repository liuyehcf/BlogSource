---
title: 操作系统原理-同步机制1
date: 2017-09-25 15:23:22
tags: 
- 摘录
categories: 
- 操作系统
- 操作系统原理
---

__目录__

<!-- toc -->
<!--more-->

# 1 程序并发执行

并发是所有问题产生的基础，同时并发是操作系统设计的基础

# 2 进程互斥

两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序

__由于各进程要求使用共享资源（变量、文件等），而这些资源需要排他性使用各进程之间竞争使用这些资源——这一关系称为进程互斥__

* __临界资源 critical resource__：系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源或共享变量
* __临界区(互斥区) critical section(region)__：各个进程中对某个临界资源（共享变量）实施操作的程序片段

__临界区的使用原则__

1. 没有进程在临界区时，想进入临界区的进程可进入
1. 不允许两个进程同时处于其临界区中
1. 临界区外运行的进程不得阻塞其他进程进入临界区
1. 不得使进程无限期等待进入临界区

![fig1](/images/操作系统原理-同步机制1/fig1.jpg)

__实现进程互斥的方案__

* 软件方案
    * Dekker解法、Peterson解法
* 硬件方案
    * 屏蔽中断、TSL(XCHG)指令

# 3 进程互斥的软件解决方案

## 3.1 错误的解法

P
```C
...
pturn = true;
while (qturn) ;
临界区
pturn = false;
...
```

Q
```C
...
qturn = true;
while (pturn) ;
临界区
qturn = false;
...
```

如果进程P在执行完`pturn = true;`后时间片用完，且进程Q在执行完`qturn = true;`后时间片用完，那么之后P和Q将永远无法退出while循环了。

## 3.2 DEKKER算法

DEKKER算法对上面那种错误的解法进行了改进，避免两个进程同时都无法退出while循环

P
```C
...
pturn = true;
while (qturn) {
    // 进入while循环内部，此时说明进程Q已经执行过qturn = true;了
    // 如果进程Q尚未修改tun的值，可能Q也卡在循环里面，那么此时需要放行进程Q，使得Q能够退出while循环
    if (turn == 2) {
        pturn = false;// 放行进程Q
        while (turn == 2);// 自旋等待Q进入临界区
        pturn = true;// 此时Q已经进临界区，因此可以将pturn重新赋值为true
    }
}
临界区
turn = 2;
pturn = false;
...
```

Q
```C
...
qturn = true;
while (pturn) {
    if (turn == 1) {
        qturn = false;
        while (turn == 1);
        qturn = true;
    }
}
临界区
turn = 1;
qturn = false;
...
```

## 3.3 PETERSON算法

```C
#define FALSE 0
#define TRUE 1
#define N 2 // 进程的个数
int turn; // 轮到谁？
int interested[N];
// 兴趣数组，初始值均为FALSE
void enter_region ( int process) // process = 0 或 1
{ 
    int other = 1 - process;// 另外一个进程的进程号
    interested[process] = TRUE; // 表明本进程感兴趣
    turn = process;// 设置标志位
    while( turn == process && interested[other] == TRUE); // 最有意思的一句
}

void leave_region ( int process)
{
    interested[process] = FALSE;
    // 本进程已离开临界区
}
```

现在我们来分析一下`while( turn == process && interested[other] == TRUE);`这个while循环条件的作用

1. `interested[other] == TRUE`这个条件不满足，说明并没有发生竞争，只需要放行当前进程即可
1. `interested[other] == TRUE`这个条件如果在两个进程中都成立，说明两个进程存在竞争，那么接下来由turn的值来确定竞争的成功或失败。这里用的是`turn == process`这个条件，即阻塞后修改turn变量的进程

# 4 进程互斥的硬件解决方案

## 4.1 硬件解法1-中断屏蔽

__开关中断指令__

```
执行“关中断”指令
临界区操作
执行“开中断”指令
```

__优缺点：__

* 简单，高效
* 代价高，限制CPU并发能力（临界区大小）
* 不适用于多处理器
* 适用于操作系统本身，不适于用户进程

## 4.2 硬件解法2-测试并加锁指令

TSL指令是一种需要硬件支持的方案。许多计算机，特别是那些为多处理机设计的计算机，都有一条指令叫做测试并上锁(TSL)。
```
TSL RX，LOCK
```
__这条指令的含义是，读取内存单元`LOCK`中的内容到寄存器`RX`中，并且为内存单元`LOCK`重新设置一个非0值。TSL指令的操作被设计为不可分的，也就是说，整个读写操作都完成之前，其他进程是没办法访问LOCK这个内存单元的。这一点是通过锁定内存总线（lock memory bus）来实现的。__

```
enter_region
    TSL REGISTER, LOCK // 复制锁到寄存器，并将锁置1
    CMP REGISTER, #0 // 判断寄存器内容是否为0
    JNE enter_region // 若不是0，说明已经有人上锁了，此时需要自旋等待，跳转到enter_region
    RET // 返回调用者，进入临界区

leave_region
    MOVE LOCK, #0 // 在锁中置0
    RET // 返回调用者
```

## 4.3 硬件解法3-交换指令

XCHG指令交换两个寄存器，或者寄存器和内存变量的内容，且保证操作的原子性

```
enter_region
    MOVE REGISTER, #1 // 给寄存器置1
    XCHG REGISTER, LOCK // 交换寄存器与锁变量的内容，反正无论如何LOCK的值都要设置为1（原来是0，那么加锁成功，设置为1；原来为1，那么继续等待，仍然是1）
    CMP REGISTER, #0 // 判断寄存器内容是否是0
    JNE enter_region // 若不是0，跳转到enter_region
    RET // 返回调用者，进入临界区

leave_region
    MOVE LOCK, #0 // 将锁变量置0
    RET // 返回调用者
```

# 5 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《MOOC-操作系统原理-陈向群》
