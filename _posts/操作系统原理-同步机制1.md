---
title: 操作系统原理-同步机制1
date: 2017-09-25 15:23:22
tags: 
- 摘录
categories: 
- 操作系统
- 操作系统原理
---

__目录__

<!-- toc -->
<!--more-->

# 1 程序并发执行

并发是所有问题产生的基础，同时并发是操作系统设计的基础

# 2 进程互斥

两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序

__由于各进程要求使用共享资源（变量、文件等），而这些资源需要排他性使用各进程之间竞争使用这些资源——这一关系称为进程互斥__

* __临界资源 critical resource__：系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源或共享变量
* __临界区(互斥区) critical section(region)__：各个进程中对某个临界资源（共享变量）实施操作的程序片段

__临界区的使用原则__

1. 没有进程在临界区时，想进入临界区的进程可进入
1. 不允许两个进程同时处于其临界区中
1. 临界区外运行的进程不得阻塞其他进程进入临界区
1. 不得使进程无限期等待进入临界区

![fig1](/images/操作系统原理-同步机制1/fig1.jpg)

__实现进程互斥的方案__

* 软件方案
    * Dekker解法、Peterson解法
* 硬件方案
    * 屏蔽中断、TSL(XCHG)指令

# 3 进程互斥的软件解决方案

## 3.1 错误的解法

P
```
...
pturn = true;
while (qturn) ;
临界区
pturn = false;
...
```

Q
```
...
qturn = true;
while (pturn) ;
临界区
qturn = false;
...
```

如果进程P在执行完`pturn = true;`后时间片用完，且进程Q在执行完`qturn = true;`后时间片用完，那么之后P和Q将永远无法退出while循环了。

## 3.2 DEKKER算法

DEKKER算法对上面那种错误的解法进行了改进，避免两个进程同时都无法退出while循环

P
```
...
pturn = true;
while (qturn) {
    // 进入while循环内部，此时说明进程Q已经执行过qturn = true;了
    // 如果进程Q尚未修改tun的值，可能Q也卡在循环里面，那么此时需要放行进程Q，使得Q能够退出while循环
    if (turn == 2) {
        pturn = false;// 放行进程Q
        while (turn == 2);
        pturn = true;
    }
}
临界区
turn = 2;
pturn = false;
...
```

Q
```
...
qturn = true;
while (pturn) {
    if (turn == 1) {
        qturn = false;
        while (turn == 1);
        qturn = true;
    }
}
临界区
turn = 1;
qturn = false;
...
```

# 4 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《MOOC-操作系统原理-陈向群》
