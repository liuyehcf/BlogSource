---
title: 消息中间件简介
date: 2017-07-18 19:23:49
tags: 摘录
categories:
- 分布式
- 消息中间件
---

__目录__

<!-- toc -->
<!--more-->

# 1 Message Queue

提到消息中间件，那么首先就必须理解一下所谓的Message Queue。

在平常的开发中，应用开发人员完全可以通过发送和接受消息的方式来方便地与应用程序进行可靠的通信，并且消息的处理为我们提供了方便的消息传递和许多业务处理的可靠的防止故障的方法。

但消息传递与传统的应用程序交互又有区别？最明显的区别就是实时性了。__Message Queue不适合实时性要求比较高的场景，因为Message Queue通过异步的方式与server端进行交互，不用担心server端的长时间处理过程。__

举个例子，平常的应用程序之间的调用大部分都是通过暴露接口的形式进行相互的调用，一旦业务复杂起来，接口之间的管理也会很麻烦。这时候如果通过Message Queue的话，只要在需要的时候把消息发送到Queue Manage就可以，__这时候Message Queue就成了嫁接各个系统之间的桥梁。__

上面也提到了实时性的问题，比如一个生成报表的功能，为了给用户更好的体验度，我们不可能让用户等待很长的时间，这时对报表的处理可以使用MQ，客户端只需要把必要的报表请求和一些必要的报表条件放置到Queue中处理，处理好后，再给用户发送一个消息即可。

# 2 几个术语

__消息__：两台计算机之间传送的数据单位，例如字符串、文本等

__消息队列__：消息的容器，用于在消息传递的过程中保存消息的容器，充当消息源和目标之间的中间桥梁。__队列的主要目的就在于提供路由保证消息的传递。__

__消息队列网络__：是指能够相互之间发送消息的一组计算机。网络中不同的计算机在消息处理过程中扮演着不同的角色，有的是发送者，有的是接受者。

# 3 消息中间件

__中间件是指利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。__通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。

消息中间件可以即支持同步方式，又支持异步方式。异步中间件比同步中间件具有更强的容错性，在系统故障时可以保证消息的正常传输。__异步中间件技术又分为两类：广播方式和发布/订阅方式。__由于发布/订阅方式可以指定哪种类型的用户可以接受哪种类型的消息，更加有针对性，事实上已成为异步中间件的非正式标准。目前主流的消息中间件产品有IBM的MQSeries，BEA的MessageQ和Sun的JMS等

那么对于消息中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者）、Broker（中转角色），有这么几个主要的角色，那么消息中间件能为我们带来哪些功能呢？

## 3.1 Message Priority

Producer把消息发送给Broker来存储，那么我们就可以在消息队列中对我们的消息来进行排序，实现不同的优先级。从而满足我们复杂的业务需求。

## 3.2 Message Order

消息排序，有的消息的处理是需要按照一定的顺序进行处理的，比如用户的创建订单、订单付款、订单完成。那么对于消费者也需要按照这个流程来消费，否则就没有意义了。

## 3.3 Message Filter

在消息队列中，也可以对我们的消息进行过滤，比如按照消息类型等条件来过滤

## 3.4 Message Persistence

消息的持久化，一般有以下几种方式

1. 持久化到数据库，比如MySQL
1. 持久哈到KV存储，比如Redis
1. 文件形式持久化

消息的持久化，防止了系统挂掉后，仍然能够从之前备份中恢复出来。

## 3.5 Broker的Buffer满了怎么办？

我们知道Broker是用来存储需要处理的消息，如果消息过多，导致Buffer满了怎么办？这时候就会采取一定的策略来丢弃已有的消息。

## 3.6 事务的支持

正如上面所谈到的订单的操作，因此消息中间件中也会提供对分布式事务的支持。

## 3.7 定时消息

在实际应用中，有时也会需要定时消费的功能，因此中间件中，也会对消息进行排序，然后实现定时发送或者消费消息的业务需求。

## 3.8 消息重试

考虑一下这个问题，如果消息消费失败后，怎么办，是等待处理这个消息呢？还是让消费者再次消费一次呢？通常情况下，采取后者的形式，因为大多数情况下，消费失败的原因在于该消息本身的原因，如果再次消费这个消息的话，还是会出现失败的情况，因此通常采取再次发送消息再次消费消息的方式。

## 3.9 回溯消费

什么是回溯消费呢？对于已经消费成功的消息，是不是在Broker中就丢弃该消息呢？显而易见是不能的，因此需要中间件对该功能支持，支持对已经消费的消息进行一段时间的存储，等待某一刻该消息会被重新消费的可能。

# 4 参考

* [我对消息中间件的理解](http://blog.csdn.net/luckyzhoustar/article/details/50411500)
