---
title: 编译原理-语法分析2
date: 2017-10-17 10:24:07
mathjax: true
tags: 
- 摘录
categories: 
- 编译
---

__目录__

<!-- toc -->
<!--more-->

# 1 $FIRST$集和$FOLLOW$集的计算

## 1.1 $FIRST$集

首先回顾一下$FIRST$的定义

* $FIRST(X)$：可以从$X$推导出的所有__串首终结符__构成的集合
* 如果$X \Rightarrow^* \varepsilon$，那么$\varepsilon \in FIRST(X)$

### 1.1.1 算法

__不断应用下列规则__，__直到没有__新的__终结符__或$\varepsilon$可以被加入到__任何__$FIRST$集合中为止

* 如果$X$是一个__终结符__，那么$FIRST(X) = \{ X \}$
* 如果$X$是一个__非终结符__，且$X \to Y_1 ... Y_k \in P (k \ge 1)$，那么如果对于某个$i$，$a$在$FIRST(Y_i)$中且$\varepsilon$在所有的$FIRST(Y_1), ..., FIRST(Y_{i-1})$中(即$Y_1 ... Y_{i-1} \Rightarrow^* \varepsilon$)，就把$a$加入到$FIRST(X)$中。如果对于所有的$j = 1, 2, ..., k，\varepsilon$在$FIRST(Y_j)$中，那么将$\varepsilon$加入到$FIRST(X)$
* 如果$X \to \varepsilon \in P$，那么将$\varepsilon$加入到$FIRST(X)$中

__计算串$X_1 X_2 ... X_n$的$FIRST$集合（上述算法的另一种描述过程）__

* 向$FIRST(X_1 X_2 ... X_n)$加入$FIRST(X_1)$中所有的__非__$\varepsilon$符号
* 如果$\varepsilon$在$FIRST(X_1)$中，再加入$FIRST(X_2)$中的所有__非__$\varepsilon$符号；如果$\varepsilon$在$FIRST(X_1)$和$FIRST(X_2)$中，再加入$FIRST(X_3)$中的所有__非__$\varepsilon$符号，以此类推
* 最后，如果对__所有的__$i$，$\varepsilon$都在$FIRST(X_i)$中，那么将$\varepsilon$加入到，$FIRST(X_1 X_2 ... X_n)$中

## 1.2 $FOLLOW$集

首先回顾一下$FOLLOW$的定义

* $FOLLOW(A)$：可能在某个句型中紧跟在$A$后边的__终结符__$a$的集合

$$FOLLOW(A) = \{ a | S \Rightarrow^\* \alpha A a \beta, a \in V_T,\; \alpha, \beta \in (V_T \cup V_N)^\* \}$$

* 如果A是某个句型的的最右符号，则将结束符`$`添加到$FOLLOW(A)$中

### 1.2.1 算法

__不断应用下列规则__，__直到__没有新的终结符可以被加入到__任何__$FOLLOW$集合中为止

* 将`$`放入$FOLLOW(S)$中，其中$S$是开始符号，`$`是输入右端的__结束标记__
* 如果存在一个产生式$A \to \alpha B \beta $，那么$FIRST(\beta)$中__除$\varepsilon$之外__的所有符号都在$FOLLOW(B)$中
* 如果存在一个产生式$A \to \alpha B$，或存在产生式$A \to \alpha B \beta $且$FIRST(\beta)$包含$\varepsilon$，那么$FOLLOW(A)$中的所有符号都在$FOLLOW(B)$中

# 2 预测分析法

$LL(1)$文法的分析方法

1. 递归的预测分析法
1. 非递归的预测分析法

## 2.1 递归的预测分析法

递归的预测分析法是指：在递归下降分析中，根据__预测分析表__进行产生式的选择

* 根据每个非终结符的产生式和$LL(1)$文法的预测分析表，为每个非终结符编写对应的过程
* ![fig1](/images/编译原理-语法分析2/fig1.jpg)

## 2.2 非递归的预测分析法

非递归的预测分析__不需要__为每个非终结符编写递归下降过程，而是根据预测分析表构造一个自动机，也叫__表驱动的预测分析__

![fig2](/images/编译原理-语法分析2/fig2.jpg)

参考下面例子：

![fig3](/images/编译原理-语法分析2/fig3.jpg)

### 2.2.1 表驱动的预测分析法

__输入__：一个串$w$和文法$G$的分析表$M$
__输出__：如果$w$在$L(G)$中，输出$w$的最左推导；否则给出错误指示
__方法__：最初，语法分析器的格局如下：输入缓冲区中是`w$`，$G$的开始符号位于栈顶
其下面是`$`。下面的程序使用预测分析表$M$生成了处理这个输入的预测分析过程

![fig4](/images/编译原理-语法分析2/fig4.jpg)

## 2.3 递归与非递归预测分析法对比

|  | 递归的预测分析法 | 非递归的预测分析法 |
|:--|:--|:--|
| 程序规模 | 程序规模__较大__，不需载入分析表 | 主控程序规模__较小__，需载入分析表（表较小） |
| 直观性 | 较好 | 较差 |
| 效率 | 较低 | 分析时间大约正比于待分析程序的长度 |
| 自动生成 | 较难 | 较易 |

## 2.4 预测分析法实现步骤

1. 构造文法
1. 改造文法：消除二义性、消除左递归、消除回溯
1. 求每个变量的$FIRST$集和$FOLLOW$集，从而求得__每个候选式的$SELECT$集__
1. 检查是不是$LL(1)$文法。若是，__构造预测分析表__
1. 对于__递归的__预测分析，根据预测分析表为每一个非终结符编写一个过程；对于__非递归的__预测分析，实现表驱动的预测分析算法

## 2.5 预测分析中的错误检测

两种情况下可以检测到错误

1. 栈顶的__终结符__和__当前输入符号__不匹配
1. 栈顶__非终结符__与__当前输入符号__在预测分析表对应项中的信息为空

__恐慌模式__

* 忽略输入中的一些符号，直到输入中出现由设计者选定的同步词法单元(synchronizing token)集合中的某个词法单元
    * 其效果依赖于__同步集合的选取__。集合的选取应该使得语法分析器能从实际遇到的错误中__快速恢复__
    * 例如可以把__$FOLLOW(A)$中的所有终结符__放入非终结符A的同步记号集合
* 如果终结符在栈顶而不能匹配，一个简单的办法就是弹出此终结符

![fig5](/images/编译原理-语法分析2/fig5.jpg)

__带有同步记号的分析表的使用方法__

* 如果$M[A,a]$是空，表示检测到错误，根据恐慌模式，__忽略输入符号$a$__
* 如果$M[A,a]$是$synch$，则__弹出栈顶的非终结符$A$__，试图继续分析后面的语法成分
* 如果__栈顶的终结符__和输入符号不匹配，则__弹出栈顶的终结符__

# 3 参考

__本篇博客摘录、整理自以下博文。若存在版权侵犯，请及时联系博主(邮箱：liuyehcf@163.com)，博主将在第一时间删除__

* 《MOOC-编译原理-陈鄞》

